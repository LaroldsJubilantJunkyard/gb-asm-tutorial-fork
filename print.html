<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GB ASM Tutorial</title>
        <meta name="robots" content="noindex" />

        <!-- Custom HTML head -->
        <meta name="twitter:card" content="summary_large_image"/>
        <meta name="twitter:site:id" content="@gbdev0"/>
        <meta property="og:title" content="GB ASM Tutorial" />
        <meta property="og:image" content="https://gbdev.io/gb-asm-tutorial/assets/banner/1200x628.png" />
        <meta property="og:site_name" content="GB ASM Tutorial"/>
        
        <!-- Matomo tracking -->
        <script>
          var _paq = window._paq = window._paq || [];
          /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
          _paq.push(['trackPageView']);
          _paq.push(['enableLinkTracking']);
          (function() {
            var u="//stats.gbdev.io/";
            _paq.push(['setTrackerUrl', u+'matomo.php']);
            _paq.push(['setSiteId', '1']);
            var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
            g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
          })();
        </script>
        <!-- End Matomo Code -->

        <meta name="description" content="A complete guide to programming Game Boy games in assembly.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="css/custom.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Home</a></li><li class="chapter-item affix "><a href="roadmap.html">Roadmap</a></li><li class="chapter-item affix "><a href="help-feedback.html">Help</a></li><li class="chapter-item affix "><li class="part-title">Part ‚Ö† ‚Äî Hello World!</li><li class="chapter-item "><a href="part1/setup.html"><strong aria-hidden="true">1.</strong> Setup</a></li><li class="chapter-item "><a href="part1/hello_world.html"><strong aria-hidden="true">2.</strong> Hello World!</a></li><li class="chapter-item "><a href="part1/toolchain.html"><strong aria-hidden="true">3.</strong> The toolchain</a></li><li class="chapter-item "><a href="part1/bin_and_hex.html"><strong aria-hidden="true">4.</strong> Binary and hexadecimal</a></li><li class="chapter-item "><a href="part1/registers.html"><strong aria-hidden="true">5.</strong> Registers</a></li><li class="chapter-item "><a href="part1/assembly.html"><strong aria-hidden="true">6.</strong> Assembly basics</a></li><li class="chapter-item "><a href="part1/memory.html"><strong aria-hidden="true">7.</strong> Memory</a></li><li class="chapter-item "><a href="part1/header.html"><strong aria-hidden="true">8.</strong> The header</a></li><li class="chapter-item "><a href="part1/operations.html"><strong aria-hidden="true">9.</strong> Operations & flags</a></li><li class="chapter-item "><a href="part1/jumps.html"><strong aria-hidden="true">10.</strong> Jumps</a></li><li class="chapter-item "><a href="part1/tracing.html"><strong aria-hidden="true">11.</strong> Tracing</a></li><li class="chapter-item "><div><strong aria-hidden="true">12.</strong> Graphics</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/tiles.html"><strong aria-hidden="true">12.1.</strong> Tiles</a></li><li class="chapter-item "><a href="part1/palettes.html"><strong aria-hidden="true">12.2.</strong> Palettes</a></li><li class="chapter-item "><a href="part1/tilemap.html"><strong aria-hidden="true">12.3.</strong> Tilemap</a></li></ol></li><li class="chapter-item "><a href="part1/wrapup.html"><strong aria-hidden="true">13.</strong> Wrapping up</a></li><li class="chapter-item affix "><li class="part-title">Part ‚Ö° ‚Äî Our first game</li><li class="chapter-item "><a href="part2/getting-started.html"><strong aria-hidden="true">14.</strong> Getting started</a></li><li class="chapter-item "><a href="part2/objects.html"><strong aria-hidden="true">15.</strong> Objects</a></li><li class="chapter-item "><a href="part2/functions.html"><strong aria-hidden="true">16.</strong> Functions</a></li><li class="chapter-item "><a href="part2/input.html"><strong aria-hidden="true">17.</strong> Input</a></li><li class="chapter-item "><a href="part2/collision.html"><strong aria-hidden="true">18.</strong> Collision</a></li><li class="chapter-item "><a href="part2/bricks.html"><strong aria-hidden="true">19.</strong> Bricks</a></li><li class="chapter-item "><a href="part2/wip.html"><strong aria-hidden="true">20.</strong> Work in progress</a></li><li class="chapter-item affix "><li class="part-title">Part III ‚Äî Our second game</li><li class="chapter-item "><a href="part3/getting-started.html"><strong aria-hidden="true">21.</strong> Getting Started</a></li><li class="chapter-item "><a href="part3/project-structure.html"><strong aria-hidden="true">22.</strong> Project Structure</a></li><li class="chapter-item "><a href="part3/entry-point.html"><strong aria-hidden="true">23.</strong> Entry Point</a></li><li class="chapter-item "><a href="part3/changing-game-states.html"><strong aria-hidden="true">24.</strong> Changing Game States</a></li><li class="chapter-item "><a href="part3/title-screen.html"><strong aria-hidden="true">25.</strong> Title Screen</a></li><li class="chapter-item "><a href="part3/story-screen.html"><strong aria-hidden="true">26.</strong> Story Screen</a></li><li class="chapter-item "><a href="part3/gameplay.html"><strong aria-hidden="true">27.</strong> Gameplay</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part3/scrolling-background.html"><strong aria-hidden="true">27.1.</strong> Scrolling Background</a></li><li class="chapter-item "><a href="part3/heads-up-interface.html"><strong aria-hidden="true">27.2.</strong> Heads-Up Interface</a></li><li class="chapter-item "><a href="part3/sprites-metasprites.html"><strong aria-hidden="true">27.3.</strong> Sprites & Metasprites</a></li><li class="chapter-item "><a href="part3/object-pools.html"><strong aria-hidden="true">27.4.</strong> Object Pools</a></li><li class="chapter-item "><a href="part3/the-player.html"><strong aria-hidden="true">27.5.</strong> The Player</a></li><li class="chapter-item "><a href="part3/bullets.html"><strong aria-hidden="true">27.6.</strong> Bullets</a></li><li class="chapter-item "><a href="part3/enemies.html"><strong aria-hidden="true">27.7.</strong> Enemies</a></li><li class="chapter-item "><a href="part3/collision.html"><strong aria-hidden="true">27.8.</strong> Collision Detection</a></li><li class="chapter-item "><a href="part3/enemy-player-collision.html"><strong aria-hidden="true">27.9.</strong> Enemy-Player Collision</a></li><li class="chapter-item "><a href="part3/enemy-bullet-collision.html"><strong aria-hidden="true">27.10.</strong> Enemy-Bullet Collision</a></li></ol></li><li class="chapter-item "><a href="part3/conclusion.html"><strong aria-hidden="true">28.</strong> Conclusion</a></li><li class="chapter-item affix "><a href="next.html">Where to go next</a></li><li class="chapter-item affix "><a href="cheatsheet.html">Cheatsheet</a></li><li class="chapter-item affix "><a href="resources.html">Resources</a></li><li class="chapter-item affix "><a href="thanks.html">Thanks</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GB ASM Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="it">Italian</a>
                          </button></li>
                        </ul>

                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("en");
                          selectedLang.parentNode.classList.add("theme-selected");

                          // The path to the root, taking the current
                          // language into account.
                          let full_path_to_root = "";
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                              if (lang.id == "en") {
                                  lang.href = `${full_path_to_root}${path}`;
                              } else {
                                  lang.href = `${full_path_to_root}${lang.id}/${path}`;
                              }
                          }
                        </script>

                        
                        <a href="https://github.com/gbdev/gb-asm-tutorial" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="home"><a class="header" href="#home">Home</a></h1>
<p>üëã Welcome to gb-asm-tutorial!
This tutorial will teach you how to make games for the Game Boy and Game Boy Color.</p>
<div class="box warning decorated"><p>‚ö†Ô∏è</p>
<p>While the Game Boy and Game Boy Color are almost the same console, <strong>the Game Boy Advance is entirely different</strong>.
However, the GBA is able to run GB and GBC games!
If you are looking to program GBC games and run them on a GBA, you‚Äôre at the right place; however, if you want to make games specifically for the GBA, please check out the <a href="https://gbadev.net/tonc/">Tonc</a> tutorial instead.</p>
</div>
<h2 id="controls"><a class="header" href="#controls">Controls</a></h2>
<p>There are some handy icons near the top of your screen!</p>
<ul>
<li>The ‚Äúburger‚Äù <i class="fa fa-bars"></i> toggles the navigation side panel;</li>
<li>The brush <i class="fa fa-paint-brush"></i> allows selecting a different color theme;</li>
<li>The magnifying glass <i class="fa fa-search"></i> pops up a search bar;</li>
<li>The world icon <i class="fa fa-globe"></i> lets you change the language of the tutorial;</li>
<li>The printer <i class="fa fa-print"></i> gives a single-page version of the <em>entire</em> tutorial, which you can print if you want;</li>
<li>The GitHub icon <i class="fa fa-github"></i> links to the tutorial‚Äôs source repository;</li>
<li>The edit button <i class="fa fa-edit"></i> allows you to suggest changes to the tutorial, provided that you have a GitHub account.</li>
</ul>
<p>Additionally, there are arrows to the left and to the right of the page (they are at the bottom instead on mobile) to more easily navigate to the next page.</p>
<p>With that said, you can get started by simply navigating to the following page :)</p>
<h2 id="authors"><a class="header" href="#authors">Authors</a></h2>
<p>The tutorial was written by <a href="https://eldred.fr/">Eldred ‚ÄúISSOtm‚Äù Habert</a>, <a href="https://evie.gbdev.io/">Evie</a>, <a href="https://github.com/avivace">Antonio Vivace</a>, <a href="https://www.LaroldsJubilantJunkyard.com">LaroldsJubilantJunkyard</a> and <a href="https://github.com/gbdev/gb-asm-tutorial/graphs/contributors">other contributors</a>.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>You can <strong>provide feedback</strong> or send suggestions in the form of Issues on the <a href="https://github.com/gbdev/gb-asm-tutorial">GitHub repository</a>.</p>
<p>We‚Äôre also <a href="https://github.com/gbdev/gb-asm-tutorial/issues">looking for help</a> for <strong>writing new lessons and improving the existing ones</strong>! You can go through the Issues to see what needs to be worked on and send Pull Requests!</p>
<p>You can also help <strong>translating</strong> the tutorial on <a href="https://crowdin.com/project/gb-asm-tutorial">Crowdin</a>.</p>
<h2 id="licensing"><a class="header" href="#licensing">Licensing</a></h2>
<p><strong>In short</strong>:</p>
<ul>
<li>Code within the tutorial is essentially <strong>public domain</strong>, meaning that you are allowed to copy it freely without restrictions.</li>
<li>You are free to copy the tutorial‚Äôs contents (prose, diagrams, etc.), modify them, and share that, but you must give credit and license any copies permissively.</li>
<li>This site‚Äôs <em>source code</em> can be freely copied, but you must give a license and copyright notice.</li>
</ul>
<p><strong>Full details</strong>, please follow these links for more information on the respective licenses:</p>
<ul>
<li>All the code contained within the tutorial itself is licensed under <a rel="license" href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a>. <em>To the extent possible under law, all copyright and related or neighboring rights to code presented within GB ASM Tutorial have been waived.</em></li>
<li>The contents (prose, images, etc.) of this tutorial are licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>Code used to display and format the site is licensed under the <a href="https://github.com/gbdev/gb-asm-tutorial/blob/master/LICENSE">MIT License</a> unless otherwise specified.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<p>The tutorial is split into three sections.
<strong>I strongly advise you go through the tutorial in order!</strong></p>
<p>In Part ‚Ö†, we run our first ‚ÄúHello World!‚Äù program, which we then dissect to learn what makes the Game Boy tick.</p>
<p>In Part ‚Ö°, we program our first game, a clone of <em>Arkanoid</em>; we learn how to prod the hardware into having something we can call a ‚Äúgame‚Äù.
Along the way, we will make plenty of mistakes, so we can learn how to debug our code.</p>
<p>And finally, Part ‚Ö¢ is about ‚Äúadvanced‚Äù use of the hardware, where we learn how to make even better-looking games, and we program a Shoot ‚ÄôEm Up!</p>
<div class="box tip">
<p>We hope this tutorial will work for you.</p>
<p>But if it doesn‚Äôt (the format may not work well for everyone, and that‚Äôs okay), I encourage you to look at <a href="resources.html">some other resources</a>, which might work better for you.</p>
<p>It‚Äôs also fine to <strong>take a break from time to time</strong>; feel free to read at your own pace, and to <a href="https://gbdev.io/chat">ask for clarifications</a> if anything isn‚Äôt clear to you.</p>
</div>
<hr />
<p>This tutorial is a work in progress.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="help"><a class="header" href="#help">Help</a></h1>
<p>If you are stuck in a certain part of the tutorial, want some advice, or just wish to chat with us, <a href="https://gbdev.io/chat">the GBDev community chat</a> is the place to go!
The authors actively participate there so don‚Äôt be afraid to ask questions!
(The ‚ÄúASM‚Äù channel should be the most appropriate to discuss the tutorial, by the way.)</p>
<p>If you prefer email, you can reach us at <code>tutorial@&lt;domain&gt;</code>, where you replace <code>&lt;domain&gt;</code> with this website‚Äôs domain name.
Anti-spam measure, I hope you understand.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>First, we should set up our dev environment.
We will need:</p>
<ol>
<li>A POSIX environment</li>
<li><a href="https://rgbds.gbdev.io/install">RGBDS</a> v0.5.1 (though v0.5.0 should be compatible)</li>
<li>GNU Make (preferably a recent version)</li>
<li>A code editor</li>
<li>A debugging emulator</li>
</ol>
<div class="box tip decorated"><p>‚ùìüòï</p>
<p>The following install instructions are provided on a ‚Äúbest-effort‚Äù basis, but may be outdated, or not work for you for some reason.
Don‚Äôt worry, we‚Äôre here to help: <a href="part1/../help-feedback.html">ask away</a>, and we‚Äôll help you with installing everything!</p>
</div>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<h3 id="linux--macos"><a class="header" href="#linux--macos">Linux &amp; macOS</a></h3>
<p>Good news: you‚Äôre already fulfilling step 1!
You just need to <a href="https://rgbds.gbdev.io/install">install RGBDS</a>, and maybe update GNU Make.</p>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<p>At the time of writing this, macOS (up to 11.0, the current latest release) ships a very outdated GNU Make.
You can check it by opening a terminal, and running <code>make --version</code>, which should indicate ‚ÄúGNU Make‚Äù and a date, among other things.</p>
<p>If your Make is too old, you can update it using <a href="https://brew.sh">Homebrew</a>‚Äôs formula <a href="https://formulae.brew.sh/formula/make#default"><code>make</code></a>.
At the time of writing, this should print a warning that the updated Make has been installed as <code>gmake</code>; you can either follow the suggestion to use it as your ‚Äúdefault‚Äù <code>make</code>, or use <code>gmake</code> instead of <code>make</code> in this tutorial.</p>
<h4 id="linux"><a class="header" href="#linux">Linux</a></h4>
<p>Once RGBDS is installed, open a terminal and run <code>make --version</code> to check your Make version (which is likely GNU Make).</p>
<p>If <code>make</code> cannot be found, you may need to install your distribution‚Äôs <code>build-essentials</code>.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>The sad truth is that Windows is a terrible OS for development; however, you can install environments that solve most issues.</p>
<p>On Windows 10, your best bet is <a href="https://docs.microsoft.com/en-us/windows/wsl">WSL</a>, which sort of allows running a Linux distribution within Windows.
Install WSL 1 or WSL 2, then a distribution of your choice, and then follow these steps again, but for the Linux distribution you installed.</p>
<p>If WSL is not an option, you can use <a href="https://www.msys2.org">MSYS2</a> or <a href="https://www.cygwin.com">Cygwin</a> instead; then check out <a href="https://rgbds.gbdev.io/install">RGBDS‚Äô Windows install instructions</a>.
As far as I‚Äôm aware, both of these provide a sufficiently up-to-date version of GNU Make.</p>
<div class="box tip">
<p>If you have programmed for other consoles, such as the GBA, check if MSYS2 isn‚Äôt already installed on your machine.
This is because devkitPro, a popular homebrew development bundle, includes MSYS2.</p>
</div>
<h2 id="code-editor"><a class="header" href="#code-editor">Code editor</a></h2>
<p>Any code editor is fine; I personally use <a href="https://www.sublimetext.com">Sublime Text</a> with its <a href="https://packagecontrol.io/packages/RGBDS">RGBDS syntax package</a>; however, you can use any text editor, including Notepad, if you‚Äôre crazy enough.
Awesome GBDev has <a href="https://gbdev.io/resources#syntax-highlighting-packages">a section on syntax highlighting packages</a>, see there if your favorite editor supports RGBDS.</p>
<h2 id="emulator"><a class="header" href="#emulator">Emulator</a></h2>
<p>Using an emulator to play games is one thing; using it to program games is another.
The two aspects an emulator must fulfill to allow an enjoyable programming experience are:</p>
<ul>
<li><strong>Debugging tools</strong>:
When your code goes haywire on an actual console, it‚Äôs very difficult to figure out why or how.
There is no console output, no way to <code>gdb</code> the program, nothing.
However, an emulator can provide debugging tools, allowing you to control execution, inspect memory, etc.
These are vital if you want GB dev to be <em>fun</em>, trust me!</li>
<li><strong>Good accuracy</strong>:
Accuracy means ‚Äúhow faithful to the original console something is‚Äù.
Using a bad emulator for playing games can work (to some extent, and even then‚Ä¶), but using it for <em>developing</em> a game makes it likely to accidentally render your game incompatible with the actual console.
For more info, read <a href="https://arstechnica.com/?post_type=post&amp;p=44524">this article on Ars Technica</a> (especially the <q>An emulator for every game</q> section at the top of page 2).
You can compare GB emulator accuracy on <a href="https://daid.github.io/GBEmulatorShootout/">Daid‚Äôs GB-emulator-shootout</a>.</li>
</ul>
<p>The emulator I will be using for this tutorial is <a href="https://emulicious.net/">Emulicious</a>.
Users on all OSes can install the Java runtime to be able to run it.
Other debugging emulators are available, such as <a href="https://www.mesen.ca/">Mesen2</a>, <a href="https://bgb.bircd.org">BGB</a> (Windows/Wine only), <a href="https://sameboy.github.io">SameBoy</a> (graphical interface on macOS only); they should have similar capabilities, but accessed through different menu options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>In this lesson, we will begin by assembling our first program.
The rest of this chapter will be dedicated to explaining how and why it works.</p>
<p>Note that we will need to type a lot of commands, so open a terminal now.
It‚Äôs a good idea to create a new directory (<code>mkdir gb_hello_world</code>, for example, then <code>cd gb_hello_world</code> to enter the new directory).</p>
<p>Grab the following files (right-click each link, ‚ÄúSave Link As‚Ä¶‚Äù), and place them all in this new directory:</p>
<ul>
<li><a href="part1/../assets/hello-world.asm"><code>hello-world.asm</code></a></li>
<li><a href="https://raw.githubusercontent.com/gbdev/hardware.inc/v4.0/hardware.inc"><code>hardware.inc</code></a></li>
</ul>
<p>Then, still from a terminal within that directory, run the following three commands.</p>
<div class="box warning decorated"><p>‚ö†Ô∏è</p>
<p>To clarify where each individual command begins, I‚Äôve added a <code>$</code> before each command, but don‚Äôt type them!</p>
</div>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgbasm -L -o hello-world.o hello-world.asm</span>
<span class="console-line hljs-meta"></span><span class="language-bash">rgblink -o hello-world.gb hello-world.o</span>
<span class="console-line hljs-meta"></span><span class="language-bash">rgbfix -v -p 0xFF hello-world.gb</span>
</code></pre>
<style>
	.box.danger ol {
		list-style-type: symbols(fixed "üëé" "üëç" "üëç");
	}
</style>
<div class="box danger decorated"><p>‚ÄºÔ∏è</p>
<p>Be careful with arguments! Some options, such as <code>-o</code> here, use the argument after them as a parameter:</p>
<ol>
<li><code>rgbasm -L -o hello-world.asm hello-world.o</code> won‚Äôt work (and may corrupt <code>hello-world.asm</code>!)</li>
<li><code>rgbasm -L hello-world.asm -o hello-world.o</code> will work</li>
<li><code>rgbasm hello-world.asm -o hello-world.o -L</code> will also work</li>
</ol>
<p>If you need whitespace within an argument, you must quote it:</p>
<ol>
<li><code>rgbasm -L -o hello world.o hello world.asm</code> won‚Äôt work</li>
<li><code>rgbasm -L -o &quot;hello world.o&quot; &quot;hello world.asm&quot;</code> will work</li>
</ol>
</div>
<p>It should look like this:</p>
<script id="asciicast-weljUlcp1KC5GqS9jqV62dy5m" src="https://asciinema.celforyon.fr/a/weljUlcp1KC5GqS9jqV62dy5m.js" async></script>
<p>(If you encounter an error you can‚Äôt figure out by yourself, don‚Äôt be afraid to <a href="part1/../index.html#feedback">ask us</a>! We‚Äôll sort it out.)</p>
<p>Congrats!
You just assembled your first Game Boy ROM!
Now, we just need to run it; open Emulicious, then go ‚ÄúFile‚Äù, then ‚ÄúOpen File‚Äù, and load <code>hello-world.gb</code>.</p>
<video controls poster="../assets/vid/hello_world.poster.png">
	<source src="../assets/vid/hello_world.webm" type="video/webm">
	<source src="../assets/vid/hello_world.mp4" type="video/mp4">
<pre><code>&lt;img src=&quot;../assets/vid/hello_world.gif&quot; alt=&quot;Video demonstration in Emulicious&quot;&gt;
</code></pre>
</video>
<p>You could also take a flash cart (I use the <a href="https://krikzz.com/store/home/47-everdrive-gb.html">EverDrive GB X5</a>, but there are plenty of alternatives), load up your ROM onto it, and run it on an actual console!</p>
<p><img src="part1/../assets/img/hello_dmg.jpg" alt="Picture of the Hello World running on a physical DMG" /></p>
<p>Well, now that we have something working, it‚Äôs time to peel back the curtains‚Ä¶</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-toolchain"><a class="header" href="#the-toolchain">The toolchain</a></h1>
<p>So, in the previous lesson, we built a nice little ‚ÄúHello World!‚Äù ROM.
Now, let‚Äôs find out exactly what we did.</p>
<h2 id="rgbasm-and-rgblink"><a class="header" href="#rgbasm-and-rgblink">RGBASM and RGBLINK</a></h2>
<p>Let‚Äôs begin by explaining what <code>rgbasm</code> and <code>rgblink</code> do.</p>
<p>RGBASM is an <em>assembler</em>.
It is responsible for reading the source code (in our case, <code>hello-world.asm</code> and <code>hardware.inc</code>), and generating blocks of code with some ‚Äúholes‚Äù.
RGBASM does not always have enough information to produce a full ROM, so it does most of the work, and stores its intermediary results in what‚Äôs known as <em>object files</em> (hence the <code>.o</code> extension).</p>
<p>RGBLINK is a <em>linker</em>.
Its job is taking object files (or, like in our case, just one), and ‚Äúlinking‚Äù them into a ROM, which is to say: filling the aforementioned ‚Äúholes‚Äù.
RGBLINK‚Äôs purpose may not be obvious with programs as simple as this Hello World, but it will become much clearer in Part ‚Ö°.</p>
<p>So: Source code ‚Üí <code>rgbasm</code> ‚Üí Object files ‚Üí <code>rgblink</code> ‚Üí ROM, right?
Well, not exactly.</p>
<h2 id="rgbfix"><a class="header" href="#rgbfix">RGBFIX</a></h2>
<p>RGBLINK does produces a ROM, but it‚Äôs not quite usable yet.
See, actual ROMs have what‚Äôs called a <em>header</em>.
It‚Äôs a special area of the ROM that contains <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html">metadata about the ROM</a>; for example, the game‚Äôs name, Game Boy Color compatibility, and more.
For simplicity, we defaulted a lot of these values to 0 for the time being; we‚Äôll come back to them in Part ‚Ö°.</p>
<p>However, the header contains three crucial fields:</p>
<ul>
<li>The <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0104-0133--nintendo-logo">Nintendo logo</a>,</li>
<li>the <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0148--rom-size">ROM‚Äôs size</a>,</li>
<li>and <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#014d--header-checksum">two checksums</a>.</li>
</ul>
<p>When the console first starts up, it runs <a href="https://github.com/ISSOtm/gb-bootroms">a little program</a> known as the <em>boot ROM</em>, which reads and draws the logo from the cartridge, and displays the little boot animation.
When the animation is finished, the console checks if the logo matches a copy that it stores internally; if there is a mismatch, <strong>it locks up!</strong>
And, since it locks up, our game never gets to run‚Ä¶ üò¶
This was meant as an anti-piracy measure; however, that measure <a href="https://en.wikipedia.org/wiki/Sega_v._Accolade">has since then been ruled as invalid</a>, so don‚Äôt worry, we are clear! üòÑ</p>
<p>Similarly, the boot ROM also computes a <em><a href="https://en.wikipedia.org/wiki/Checksum">checksum</a></em> of the header, supposedly to ensure that it isn‚Äôt corrupted.
The header also contains a copy of this checksum; if it doesn‚Äôt match what the boot ROM computed, then the boot ROM <strong>also locks up!</strong></p>
<p>The header also contains a checksum over the whole ROM, but nothing ever uses it.
It doesn‚Äôt hurt to get it right, though.</p>
<p>Finally, the header also contains the ROM‚Äôs size, which is required by emulators and flash carts.</p>
<p>RGBFIX‚Äôs role is to fill in the header, especially these 3 fields, which are required for our ROM to be guaranteed to run fine.
The <code>-v</code> option instructs RGBFIX to make the header <strong>v</strong>alid, by injecting the Nintendo logo and computing the two checksums.
The <code>-p 0xFF</code> option instructs it to <strong>p</strong>ad the ROM to a valid size, and set the corresponding value in the ‚ÄúROM size‚Äù header field.</p>
<p>Alright!
So the full story is: Source code ‚Üí <code>rgbasm</code> ‚Üí Object files ‚Üí <code>rgblink</code> ‚Üí ‚ÄúRaw‚Äù ROM ‚Üí <code>rgbfix</code> ‚Üí ‚ÄúFixed‚Äù ROM.
Good.</p>
<p>You might be wondering why RGBFIX‚Äôs functionality hasn‚Äôt been included directly in RGBLINK.
There are some historical reasons, but RGBLINK can also be used to produce things other than ROMs (especially via the <code>-x</code> option), and RGBFIX is sometimes used without RGBLINK anywhere in sight.</p>
<h2 id="file-names"><a class="header" href="#file-names">File names</a></h2>
<p>Note that RGBDS does not care at all about the files‚Äô extensions.
Some people call their source code <code>.s</code>, for example, or their object files <code>.obj</code>.
The file names don‚Äôt matter, either; it‚Äôs just practical to keep the same name.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-and-hexadecimal"><a class="header" href="#binary-and-hexadecimal">Binary and hexadecimal</a></h1>
<p>Before we talk about the code, a bit of background knowledge is in order.
When programming at a low level, understanding of <em><a href="https://en.wikipedia.org/wiki/Binary_number">binary</a></em> and <em><a href="https://en.wikipedia.org/wiki/Hexadecimal">hexadecimal</a></em> is mandatory.
Since you may already know about both of these, a summary of the RGBDS-specific information is available at the end of this lesson.</p>
<p>So, what‚Äôs binary?
It‚Äôs a different way to represent numbers, in what‚Äôs called <em>base 2</em>.
We‚Äôre used to counting in <a href="https://en.wikipedia.org/wiki/Decimal">base 10</a>, so we have 10 digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9.
Here‚Äôs how digits work:</p>
<pre><code>  42 =                       4 √ó 10   + 2
     =                       4 √ó 10^1 + 2 √ó 10^0
                                  ‚Üë          ‚Üë
    These tens come from us counting in base 10!

1024 = 1 √ó 1000 + 0 √ó 100  + 2 √ó 10   + 4
     = 1 √ó 10^3 + 0 √ó 10^2 + 2 √ó 10^1 + 4 √ó 10^0
       ‚Üë          ‚Üë          ‚Üë          ‚Üë
And here we can see the digits that make up the number!
</code></pre>
<div class="box tip decorated"><p>‚ÑπÔ∏è</p>
<p><code>^</code> here means ‚Äúto the power of‚Äù, where <code>X^N</code> is equal to multiplying <code>X</code> with itself <code>N</code> times, and <code>X ^ 0 = 1</code>.</p>
</div>
<p>Decimal digits form a unique <em>decomposition</em> of numbers in powers of 10 (<em>deci</em>mal is base 10, remember?).
But why stop at powers of 10?
We could use other bases instead, such as base 2.
(Why base 2 specifically will be explained later.)</p>
<p>Binary is base 2, so there are only two digits, called <em>bits</em>: 0 and 1.
Thus, we can generalize the principle outlined above, and write these two numbers in a similar way:</p>
<pre><code>  42 =                                                    1 √ó 32  + 0 √ó 16  + 1 √ó 8   + 0 √ó 4   + 1 √ó 2   + 0
     =                                                    1 √ó 2^5 + 0 √ó 2^4 + 1 √ó 2^3 + 0 √ó 2^2 + 1 √ó 2^1 + 0 √ó 2^0
                                                              ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë
                                          And since now we're counting in base 2, we're seeing twos instead of tens!

1024 = 1 √ó 1024 + 0 √ó 512 + 0 √ó 256 + 0 √ó 128 + 0 √ó 64  + 0 √ó 32  + 0 √ó 16  + 0 √ó 8   + 0 √ó 4   + 0 √ó 2   + 0
     = 1 √ó 2^10 + 0 √ó 2^9 + 0 √ó 2^8 + 0 √ó 2^7 + 0 √ó 2^6 + 0 √ó 2^5 + 0 √ó 2^4 + 0 √ó 2^3 + 0 √ó 2^2 + 0 √ó 2^1 + 0 √ó 2^0
       ‚Üë          ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë
</code></pre>
<p>So, by applying the same principle, we can say that in base 2, 42 is written as <code>101010</code>, and 1024 as <code>10000000000</code>. 
Since you can‚Äôt tell ten (decimal 10) and two (binary 10) apart, RGBDS assembly has binary numbers prefixed by a percent sign: 10 is ten, and %10 is two.</p>
<p>Okay, but why base 2 specifically?
Rather conveniently, a bit can only be 0 or 1, which are easy to represent as ‚ÄúON‚Äù or ‚ÄúOFF‚Äù, empty or full, etc!
If you want, at home, to create a one-bit memory, just take a box.
If it‚Äôs empty, it stores a 0; if it contains <em>something</em>, it stores a 1.
Computers thus primarily manipulate binary numbers, and this has a <em>slew</em> of implications, as we will see throughout this entire tutorial.</p>
<h2 id="hexadecimal"><a class="header" href="#hexadecimal">Hexadecimal</a></h2>
<p>To recap, decimal isn‚Äôt practical for a computer to work with, instead relying on binary (base 2) numbers.
Okay, but binary is really impractical to work with.
Take %10000000000, aka 2048; when in decimal only 4 digits are required, binary instead needs 12!
And, did you notice that I actually wrote one zero too few?
Fortunately, hexadecimal is here to save the day! ü¶∏</p>
<p>Base 16 works just the same as every other base, but with 16 digits, called <em>nibbles</em>: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F.</p>
<pre><code>  42 =            2 √ó 16   + 10
     =            2 √ó 16^1 + A √ó 16^0

1024 = 4 √ó 256  + 0 √ó 16   + 0
     = 4 √ó 16^2 + 0 √ó 16^1 + 0 √ó 16^0
</code></pre>
<p>Like binary, we will use a prefix to denote hexadecimal, namely <code>$</code>.
So, 42 = $2A, and 1024 = $400.
This is <em>much</em> more compact than binary, and slightly more than decimal, too; but what makes hexadecimal very interesting is that one nibble corresponds <em>exactly</em> to 4 bits!</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Nibble</th><th style="text-align: center">Bits</th></tr></thead><tbody>
<tr><td style="text-align: center">$0</td><td style="text-align: center">%0000</td></tr>
<tr><td style="text-align: center">$1</td><td style="text-align: center">%0001</td></tr>
<tr><td style="text-align: center">$2</td><td style="text-align: center">%0010</td></tr>
<tr><td style="text-align: center">$3</td><td style="text-align: center">%0011</td></tr>
<tr><td style="text-align: center">$4</td><td style="text-align: center">%0100</td></tr>
<tr><td style="text-align: center">$5</td><td style="text-align: center">%0101</td></tr>
<tr><td style="text-align: center">$6</td><td style="text-align: center">%0110</td></tr>
<tr><td style="text-align: center">$7</td><td style="text-align: center">%0111</td></tr>
<tr><td style="text-align: center">$8</td><td style="text-align: center">%1000</td></tr>
<tr><td style="text-align: center">$9</td><td style="text-align: center">%1001</td></tr>
<tr><td style="text-align: center">$A</td><td style="text-align: center">%1010</td></tr>
<tr><td style="text-align: center">$B</td><td style="text-align: center">%1011</td></tr>
<tr><td style="text-align: center">$C</td><td style="text-align: center">%1100</td></tr>
<tr><td style="text-align: center">$D</td><td style="text-align: center">%1101</td></tr>
<tr><td style="text-align: center">$E</td><td style="text-align: center">%1110</td></tr>
<tr><td style="text-align: center">$F</td><td style="text-align: center">%1111</td></tr>
</tbody></table>
</div>
<p>This makes it very easy to convert between binary and hexadecimal, while retaining a compact enough notation.
Thus, hexadecimal is used a lot more than binary.
And, don‚Äôt worry, decimal can still be used üòú</p>
<p>(Side note: one could point that octal, i.e. base 8, would also work for this; however, we will primarily deal with units of 8 bits, for which hexadecimal works much better than octal. RGBDS supports octal via the <code>&amp;</code> prefix, but I have yet to see it used.)</p>
<div class="box tip decorated"><p>üí°</p>
<p>If you‚Äôre having trouble converting between decimal and binary/hexadecimal, check if your favorite calculator program doesn‚Äôt have a ‚Äúprogrammer‚Äù mode, or a way to convert between bases.</p>
</div>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>In RGBDS assembly, the hexadecimal prefix is <code>$</code>, and the binary prefix is <code>%</code>.</li>
<li>Hexadecimal can be used as a ‚Äúcompact binary‚Äù notation.</li>
<li>Using binary or hexadecimal is useful when individual bits matter; otherwise, decimal works just as well.</li>
<li>For when numbers get a bit too long, RGBASM allows underscores between digits (<code>123_465</code>, <code>%10_1010</code>, <code>$DE_AD_BE_EF</code>, etc.)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registers"><a class="header" href="#registers">Registers</a></h1>
<p>Alright!
Now that we know what bits are, let‚Äôs talk about how they‚Äôre used.
Don‚Äôt worry, this is mostly prep work for the next section, where we will‚Äîfinally!‚Äîlook at the code üëÄ</p>
<p>First, if you opened Emulicious, you have been greeted with just the Game Boy screen.
So, it‚Äôs time we pop the debugger open!
Go to ‚ÄúTools‚Äù, then click ‚ÄúDebugger‚Äù, or press <kbd><kbd>F1</kbd></kbd>.
Then in the debugger‚Äôs menu, click ‚ÄúView‚Äù, then click ‚ÄúShow Addresses‚Äù</p>
<video controls poster="../assets/vid/debugger.poster.png">
	<source src="../assets/vid/debugger.webm" type="video/webm">
	<source src="../assets/vid/debugger.mp4" type="video/mp4">
<pre><code>&lt;img src=&quot;../assets/vid/debugger.gif&quot; alt=&quot;Video demonstration in Emulicious&quot;&gt;
</code></pre>
</video>
<p>The debugger may look intimidating at first, but don‚Äôt worry, soon we‚Äôll be very familiar with it!
For now, let‚Äôs focus on this small box near the top-right, the <em>register viewer</em>.</p>
<p><img src="part1/../assets/img/reg_viewer.png" alt="Picture of the register viewer‚Äôs location" /></p>
<div class="box warning decorated"><p>‚ö†Ô∏è</p>
<p>The register viewer shows both <em>CPU registers</em> and some <em>hardware registers</em>.
This lesson will only deal with CPU registers, so that‚Äôs why we will be ignoring some of these entries here.</p>
</div>
<p>What are CPU registers?
Well, imagine you‚Äôre preparing a cake.
You will be following a recipe, whose instructions may be ‚Äúmelt 125g of chocolate and 125g of butter, blend with 2 eggs‚Äù and so on.
You will fetch some ingredients from the fridge as needed, but you don‚Äôt cook inside the fridge; for that, you have a small workspace.</p>
<p>Registers are pretty much the CPU‚Äôs workspace.
They are small, tiny chunks of memory embedded directly in the CPU (only 10 bytes for the Game Boy‚Äôs CPU, and even modern CPUs have less than a kilobyte if you don‚Äôt count <a href="https://en.wikipedia.org/wiki/SIMD"><abbr title="Single Instruction, Multiple Data">SIMD</abbr></a> registers).
Operations are not performed directly on data stored in memory, which would be equivalent to breaking eggs directly inside our fridge, but they are performed on registers.</p>
<div class="box tip decorated"><p>‚ÑπÔ∏è</p>
<p>There are exceptions to this rule, like many other ‚Äúrules‚Äù I will give in this tutorial; I will paper over them to keep the mental complexity reasonable, but don‚Äôt treat my word as gospel either.</p>
</div>
<h2 id="general-purpose-registers"><a class="header" href="#general-purpose-registers">General-purpose registers</a></h2>
<p>CPU registers can be placed into two categories: <em>general-purpose</em> and <em>special-purpose</em>.
A ‚Äúgeneral-purpose‚Äù register (<abbr title="General-Purpose Register">GPR</abbr> for short) can be used for storing arbitrary integer numbers.
Some GPRs are special nonetheless, as we will see later; but the distinction is ‚Äúcan I store arbitrary integers in it?‚Äù.</p>
<p>I won‚Äôt introduce special-purpose registers quite yet, as their purpose wouldn‚Äôt make sense yet.
Rather, they will be discussed as the relevant concepts are introduced.</p>
<p>The Game Boy CPU has seven 8-bit GPRs: <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>h</code>, and <code>l</code>.
‚Äú8-bit‚Äù means that, well, they store 8 bits.
Thus, they can store integers from 0 to 255 (%1111_1111 aka $FF).</p>
<p><code>a</code> is the <em>accumulator</em>, and we will see later that it can be used in special ways.</p>
<p>A special feature is that these registers, besides <code>a</code>, are <em>paired up</em>, and the pairs can be treated as the 16-bit registers <code>bc</code>, <code>de</code>, and <code>hl</code>.
The pairs are <em>not</em> separate from the individual registers; for example, if <code>d</code> contains 192 ($C0) and <code>e</code> contains 222 ($DE), then <code>de</code> contains 49374 ($C0DE) = 192 √ó 256 + 222.
The other pairs work similarly.</p>
<p>Modifying <code>de</code> actually modifies both <code>d</code> and <code>e</code> at the same time, and modifying either individually also affects the pair.
How do we modify registers?
Let‚Äôs see how, with our first assembly instructions!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assembly-basics"><a class="header" href="#assembly-basics">Assembly basics</a></h1>
<p>Alright, now that we know what the tools <em>do</em>, let‚Äôs see what language RGBASM speaks.
I will take a short slice of the beginning of <code>hello-world.asm</code>, so that we agree on the line numbers, and you can get some syntax highlighting even if your editor doesn‚Äôt support it.</p>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;hardware.inc&quot;

SECTION &quot;Header&quot;, ROM0[$100]

	jp EntryPoint

	ds $150 - @, 0 ; Make room for the header

EntryPoint:
	; Shut down audio circuitry
	ld a, 0
	ld [rNR52], a
</code></pre>
<p>Let‚Äôs analyze it.
Note that I will be ignoring a <em>lot</em> of RGBASM‚Äôs functionality; if you‚Äôre curious to know more, you should wait until parts II and III, or <a href="https://rgbds.gbdev.io/docs">read the docs</a>.</p>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>We‚Äôll start with line 10, which should appear gray above.
Semicolons <code>;</code> denote <em>comments</em>.
Everything from a semicolon to the end of the line is <em>ignored</em> by RGBASM.
As you can see on line 7, comments need not be on an otherwise empty line.</p>
<p>Comments are a staple of every good programming language; they are useful to give context as to what code is doing.
They‚Äôre the difference between ‚ÄúPre-heat the oven at 180 ¬∞C‚Äù and ‚ÄúPre-heat the oven at 180 ¬∞C, any higher and the cake would burn‚Äù, basically.
In any language, good comments are very useful; in assembly, they play an even more important role, as many common semantic facilities are not available.</p>
<h2 id="instructions"><a class="header" href="#instructions">Instructions</a></h2>
<p>Assembly is a very line-based language.
Each line can contain one of two things:</p>
<ul>
<li>a <em>directive</em>, which instructs RGBASM to do something, or</li>
<li>an <em>instruction</em><sup class="footnote-reference"><a href="#instr_directive">1</a></sup>, which is written directly into the ROM.</li>
</ul>
<p>We will talk about directives later, for now let‚Äôs focus on instructions: for example, in the snippet above, we will ignore lines 1 (<code>INCLUDE</code>), 7 (<code>ds</code>), and 3 (<code>SECTION</code>).</p>
<p>To continue the cake-baking analogy even further, instructions are like steps in a recipe.
The console‚Äôs processor (<abbr title="Central Processing Unit">CPU</abbr>) executes instructions one at a time, and that‚Ä¶ eventually does something!
Like baking a cake, drawing a ‚ÄúHello World‚Äù image, or displaying a Game Boy programming tutorial!
*wink* *wink*</p>
<p>Instructions have a <em>mnemonic</em>, which is a name they are given, and <em>operands</em>, which indicate what they should act upon.
For example, in ‚Äúmelt the chocolate and butter in a saucepan‚Äù, <em>the whole sentence</em> would be the instruction, <em>the verb</em> ‚Äúmelt‚Äù would be the mnemonic, and ‚Äúchocolate‚Äù, ‚Äúbutter‚Äù, and ‚Äúsaucepan‚Äù the operands, i.e. some kind of parameters to the operation.</p>
<p>Let‚Äôs discuss the most fundamental instruction, <strong><code>ld</code></strong>.
<code>ld</code> stands for ‚ÄúLoaD‚Äù, and its purpose is simply to copy data from its right operand (<a href="https://en.wikipedia.org/wiki/Sides_of_an_equation">‚Äú<abbr title="Right-Hand Side">RHS</abbr>‚Äù</a>) into its left operand (<a href="https://en.wikipedia.org/wiki/Sides_of_an_equation">‚Äú<abbr title="Left-Hand Side">LHS</abbr>‚Äù</a>).
For example, take line 11‚Äôs <code>ld a, 0</code>: it copies (‚Äúloads‚Äù) the value 0 into the 8-bit register <code>a</code><sup class="footnote-reference"><a href="#ld_imm_from">2</a></sup>.
If you look further in the file, line 33 has <code>ld a, b</code>, which causes the value in register <code>b</code> to be copied into register <code>a</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Instruction</th><th>Mnemonic</th><th>Effect</th></tr></thead><tbody>
<tr><td>Load</td><td><code>ld</code></td><td>Copies values around</td></tr>
</tbody></table>
</div><div class="box tip decorated"><p>‚ÑπÔ∏è</p>
<p>Due to CPU limitations, not all operand combinations are valid for <code>ld</code> and many other instructions; we will talk about this when writing our own code later.</p>
</div>
<div class="box tip decorated"><p>ü§î</p>
<p>RGBDS has an <a href="https://rgbds.gbdev.io/docs/gbz80.7">instruction reference</a> worth bookmarking, and you can also consult it locally with <code>man 7 gbz80</code> if RGBDS is installed on your machine (except Windows‚Ä¶).
The descriptions there are more succinct, since they‚Äôre intended as reminders, not as tutorials.</p>
</div>
<h2 id="directives"><a class="header" href="#directives">Directives</a></h2>
<p>In a way, instructions are destined to the console‚Äôs CPU, and comments are destined to the programmer.
But some lines are neither, and are instead sort of metadata destined to RGBDS itself.
Those are called <em>directives</em>, and our Hello World actually contains three of those.</p>
<h3 id="including-other-files"><a class="header" href="#including-other-files">Including other files</a></h3>
<pre><code class="language-rgbasm linenos">INCLUDE &quot;hardware.inc&quot;
</code></pre>
<p>Line 1 <em>includes</em> <code>hardware.inc</code><sup class="footnote-reference"><a href="#hw_inc_directives">3</a></sup>.
Including a file has the same effect as if you copy-pasted it, but without having to actually do that.</p>
<p>It allows sharing code across files easily: for example, if two files <code>a.asm</code> and <code>b.asm</code> were to include <code>hardware.inc</code>, you would only need to modify <code>hardware.inc</code> once for the modifications to apply to both <code>a.asm</code> and <code>b.asm</code>.
If you instead copy-pasted the contents manually, you would have to edit both copies in <code>a.asm</code> and <code>b.asm</code> to apply the changes, which is more tedious and error-prone.</p>
<p><code>hardware.inc</code> defines a bunch of constants related to interfacing with the hardware.
Constants are basically names with a value attached, so when you write out their name, they are replaced with their value.
This is useful because, for example, it is easier to remember the address of the <strong>LCD</strong> <strong>C</strong>ontrol register as <code>rLCDC</code> than <code>$FF40</code>.</p>
<p>We will discuss constants in more detail in Part ‚Ö°.</p>
<h3 id="sections"><a class="header" href="#sections">Sections</a></h3>
<p>Let‚Äôs first explain what a ‚Äúsection‚Äù is, then we will see what line 3 does.</p>
<p>A section represents a contiguous range of memory, and by default, ends up <em>somewhere</em> not known in advance.
If you want to see where all the sections end up, you can ask RGBLINK to generate a ‚Äúmap file‚Äù with the <code>-m</code> flag:</p>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgblink hello-world.o -m hello-world.map</span>
</code></pre>
<p>‚Ä¶and we can see, for example, where the <code>&quot;Tilemap&quot;</code> section ended up:</p>
<pre><code>  SECTION: $05a6-$07e5 ($0240 bytes) [&quot;Tilemap&quot;]
</code></pre>
<p>Sections cannot be split by RGBDS, which is useful e.g. for code, since the processor executes instructions one right after the other (except jumps, as we will see later).
There is a balance to be struck between too many and not enough sections, but it typically doesn‚Äôt matter much until banking is introduced into the picture‚Äîand it won‚Äôt be until much, much later.</p>
<p>So, for now, let‚Äôs just assume that one section should contain things that ‚Äúgo together‚Äù topically, and let‚Äôs examine one of ours.</p>
<pre><code class="language-rgbasm linenos start=3">SECTION &quot;Header&quot;, ROM0[$100]
</code></pre>
<p>So!
What‚Äôs happening here?
Well, we are simply declaring a new section; all instructions and data after this line and until the next <code>SECTION</code> one will be placed in this newly-created section.
Before the first <code>SECTION</code> directive, there is no ‚Äúactive‚Äù section, and thus generating code or data will be met with a <code>Cannot output data outside of a SECTION</code> error.</p>
<p>The new section‚Äôs name is ‚Äú<code>Header</code>‚Äù.
Section names can contain any characters (and even be empty, if you want), and must be unique<sup class="footnote-reference"><a href="#sect_name">4</a></sup>.
The <code>ROM0</code> keyword indicates which ‚Äúmemory type‚Äù the section belongs to (<a href="https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.5#SECTIONS">here is a list</a>).
We will discuss them in Part ‚Ö°.</p>
<p>The <code>[$100]</code> part is more interesting, in that it is unique to this section.
See, I said above that:</p>
<blockquote>
<p>a section [‚Ä¶] by default, ends up <em>somewhere</em> not known in advance.</p>
</blockquote>
<p>However, some memory locations are special, and so sometimes we need a specific section to span a specific range of memory.
To enable this, RGBASM provides the <code>[addr]</code> syntax, which <em>forces</em> the section‚Äôs starting address to be <code>addr</code>.</p>
<p>In this case, the memory range $100‚Äì$14F is special, as it is the <em>ROM‚Äôs header</em>.
We will discuss the header in a couple lessons, but for now, just know that we need not to put any of our code or data in that space.
How do we do that?
Well, first, we begin a section at address $100, and then we need to reserve some space.</p>
<h3 id="reserving-space"><a class="header" href="#reserving-space">Reserving space</a></h3>
<pre><code class="language-rgbasm linenos start=5">	jp EntryPoint

	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>Line 7 claims to ‚ÄúMake room for the header‚Äù, which I briefly mentioned just above.
For now, let‚Äôs focus on what <code>ds</code> actually does.</p>
<p><code>ds</code> is used for <em>statically</em> allocating memory.
It simply reserves some amount of bytes, which are set to a given value.
The first argument to <code>ds</code>, here <code>$150 - @</code>, is <em>how many bytes to reserve</em>.
The second (optional) argument, here <code>0</code>, is <em>what value to set each reserved byte to</em><sup class="footnote-reference"><a href="#ds_pattern">5</a></sup>.</p>
<p>We will see why these bytes must be reserved in a couple of lessons.</p>
<p>It is worth mentioning that this first argument here is an <em>expression</em>.
RGBDS (thankfully!) supports arbitrary expressions essentially anywhere.
This expression is a simple subtraction: $150 minus <code>@</code>, which is a special symbol that stands for ‚Äúthe current memory address‚Äù.</p>
<div class="box tip">
<p>A symbol is essentially ‚Äúa name attached to a value‚Äù, usually a number.
We will explore the different types of symbols throughout the tutorial, starting with labels in the next section.</p>
<p>A numerical symbol used in an expression evaluates to its value, which must be known when compiling the ROM‚Äîin particular, it can‚Äôt depend on any register‚Äôs contents.</p>
</div>
<p>Oh, but you may be wondering what the ‚Äúmemory addresses‚Äù I keep mentioning are.
Let‚Äôs see about those!</p>
<hr />
<div class="footnote-definition" id="instr_directive"><sup class="footnote-definition-label">1</sup>
<p>Technically, instructions in RGBASM are implemented as directives, basically writing their encoded form to the ROM; but the distinction between the instructions in the source code and those in the final ROM is not worth bringing up right now.</p>
</div>
<div class="footnote-definition" id="ld_imm_from"><sup class="footnote-definition-label">2</sup>
<p>The curious reader may ask where the value is copied <em>from</em>. The answer is simply that the ‚Äúimmediate‚Äù byte ($00 in this example) is stored in ROM just after the instruction‚Äôs opcode byte, and it‚Äôs what gets copied to <code>a</code>.
We will come back to this when we talk about how instructions are encoded later on.</p>
</div>
<div class="footnote-definition" id="hw_inc_directives"><sup class="footnote-definition-label">3</sup>
<p><code>hardware.inc</code> itself contains more directives, in particular to define a lot of symbols.
They will be touched upon much later, so we won‚Äôt look into <code>hardware.inc</code> yet.</p>
</div>
<div class="footnote-definition" id="sect_name"><sup class="footnote-definition-label">4</sup>
<p>Section names actually only need to be unique for ‚Äúplain‚Äù sections, and function differently with ‚Äúunionized‚Äù and ‚Äúfragment‚Äù sections, which we will discuss much later.</p>
</div>
<div class="footnote-definition" id="ds_pattern"><sup class="footnote-definition-label">5</sup>
<p>Actually, since RGBASM 0.5.0, <code>ds</code> can accept a <em>list</em> of bytes, and will repeat the pattern for as many bytes as specified.
It just complicates the explanation slightly, so I omitted it for now.
Also, if the argument is omitted, it defaults to what is specified using the <code>-p</code> option <strong>to RGBASM</strong>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory"><a class="header" href="#memory">Memory</a></h1>
<div class="box tip decorated"><p>üéâ</p>
<p>Congrats, you have just finished the hardest lessons of the tutorial!
Since you have the basics, from now on, we‚Äôll be looking at more and more concrete code.</p>
</div>
<p>If we look at line 29, we see <code>ld a, [de]</code>.
Given what we just learned, this copies a value into register <code>a</code>‚Ä¶ but where from?
What do these brackets mean?
To answer that, we need to talk about <em>memory</em>.</p>
<h2 id="whats-a-memory"><a class="header" href="#whats-a-memory">What‚Äôs a memory?</a></h2>
<p>The purpose of memory is to store information.
On a piece of paper or a whiteboard, you can write letters to store the grocery list, for example.
But what can you store in a computer memory?
The answer to that question is <em>current</em><sup class="footnote-reference"><a href="#memory_magnetic">1</a></sup>.
Computer memory is made of little cells that can store current.
But, as we saw in the lesson about binary, the presence or absence of current can be used to encode binary numbers!</p>
<p>tl;dr: memory <strong>stores numbers</strong>.
In fact, memory is a <em>long</em> array of numbers, stored in cells.
To uniquely identify each cell, it‚Äôs given a number (what else!) called its <em>address</em>.
Like street numbers!
The first cell has address 0, then address 1, 2, and so on.
On the Game Boy, each cell contains <em>8 bits</em>, i.e. a <em>byte</em>.</p>
<p>How many cells are there?
Well, this is actually a trick question‚Ä¶</p>
<h2 id="the-many-types-of-memory"><a class="header" href="#the-many-types-of-memory">The many types of memory</a></h2>
<p>There are several memory chips in the Game Boy, but we can put them into two categories: <abbr title="Read-Only Memory">ROM</abbr> and <abbr title="Random Access Memory">RAM</abbr>
<sup class="footnote-reference"><a href="#rom_ram_and">2</a></sup>.
ROM simply designates memory that cannot be written to<sup class="footnote-reference"><a href="#rom_ro">3</a></sup>, and RAM memory that can be written to.</p>
<p>Due to how they work, the CPU, as well as the memory chips, can only use a single number for addresses.
Let‚Äôs go back to the ‚Äústreet numbers‚Äù analogy: each memory chip is a street, with its own set of numbers, but the CPU has no idea what a street is, it only deals with street numbers.
To allow the CPU to talk to multiple chips, a sort of ‚Äúpostal service‚Äù, the <em>chip selector</em>, is tasked with translating the CPU‚Äôs street numbers into a street &amp; street number.</p>
<p>For example, let‚Äôs say a convention is established where addresses 0 through 1999 go to chip A‚Äôs addresses 0‚Äì1999, 2000‚Äì2999 to chip B‚Äôs 0‚Äì999, and 3000‚Äì3999 to chip C‚Äôs 0‚Äì999.
Then, if the CPU asks for the byte at address 2791, the chip selector will ask chip B for the byte at its <em>own</em> address 791, and forward the reply to the CPU.</p>
<p>Since addresses dealt with by the CPU do not directly correspond to the chips‚Äô addresses, we talk about <em>logical</em> addresses (here, the CPU‚Äôs) versus <em>physical</em> addresses (here, the chips‚Äô), and the correspondence is called a <em>memory map</em>.
Since we are programming the CPU, we will only be dealing with <strong>logical</strong> addresses, but it‚Äôs crucial to keep in mind that different addresses may be backed by different memory chips, since each chip has unique characteristics.</p>
<p>This may sound complicated, so here is a summary:</p>
<ul>
<li>Memory stores numbers, each 8-bit on the Game Boy.</li>
<li>Memory is accessed byte by byte, and the cell being accessed is determined by an <em>address</em>, which is just a number.</li>
<li>The CPU deals with all memory uniformly, but there are several memory chips each with their own characteristics.</li>
</ul>
<h3 id="game-boy-memory-map"><a class="header" href="#game-boy-memory-map">Game Boy memory map</a></h3>
<p>Let‚Äôs answer the question that introduced this section: how many memory cells are there on the Game Boy?
Well, now, we can reframe this question as ‚Äúhow many logical addresses are there?‚Äù or ‚Äúhow many physical addresses are there in total?‚Äù.</p>
<p>Logical addresses, which again are just numbers, are 16-bit on the Game Boy.
Therefore, there are 2^16 = 65536 logical addresses, from $0000 to $FFFF.
How many physical addresses, though?
Well, here is a memory map <a href="https://gbdev.io/pandocs/Memory_Map.html">courtesy of Pan Docs</a> (though I will simplify it a bit):</p>
<div class="table-wrapper"><table><thead><tr><th>Start</th><th>End</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>$0000</td><td>$7FFF</td><td>ROM</td><td>The game ROM, supplied by the cartridge.</td></tr>
<tr><td>$8000</td><td>$9FFF</td><td>VRAM</td><td>Video RAM, where graphics are stored and arranged.</td></tr>
<tr><td>$A000</td><td>$BFFF</td><td>SRAM</td><td>Save RAM, optionally supplied by the cartridge to save data to.</td></tr>
<tr><td>$C000</td><td>$DFFF</td><td>WRAM</td><td>Work RAM, general-purpose RAM for the game to store things in.</td></tr>
<tr><td>$FE00</td><td>$FE9F</td><td>OAM</td><td>Object Attribute Memory, where ‚Äúobjects‚Äù are stored.</td></tr>
<tr><td>$FF00</td><td>$FF7F</td><td>I/O</td><td>Neither ROM nor RAM, but this is where you control the console.</td></tr>
<tr><td>$FF80</td><td>$FFFE</td><td>HRAM</td><td>High RAM, a tiny bit of general-purpose RAM which can be accessed faster.</td></tr>
<tr><td>$FFFF</td><td>$FFFF</td><td>IE</td><td>A lone I/O byte that‚Äôs separated from the rest for some reason.</td></tr>
</tbody></table>
</div>
<p>$8000 + $2000 + $2000 + $2000 + $A0 + $80 + $7F + 1 adds up to $E1A0, or 57760 bytes of memory that can be <em>actually</em> accessed.
The curious reader will naturally ask, ‚ÄúWhat about the remaining 7776 bytes? What happens when accessing them?‚Äù; the answer is: ‚ÄúIt depends, it‚Äôs complicated; avoid accessing them‚Äù.</p>
<h2 id="labels"><a class="header" href="#labels">Labels</a></h2>
<p>Okay, memory addresses are nice, but you can‚Äôt possibly expect me to keep track of all these addresses manually, right??
Well, fear not, for we have labels!</p>
<p>Labels are <a href="https://rgbds.gbdev.io/docs/v0.5.1/rgbasm.5#SYMBOLS">symbols</a> which basically allow attaching a name to a byte of memory.
A label is declared like at line 9 (<code>EntryPoint:</code>): at the beginning of the line, write the label‚Äôs name, followed by a colon, and it will refer to the byte right after itself.
So, for example, <code>EntryPoint</code> refers to the <code>ld a, 0</code> right below it (more accurately, the first byte of that instruction, but we will get there when we get there).</p>
<div class="box tip">
<p>If you peek inside <code>hardware.inc</code>, you will see that for example <code>rNR52</code> is not defined as a label.
That‚Äôs because they are <em>constants</em>, which we will touch on later; since they can be used mostly like labels, we will conflate the two for now.</p>
</div>
<p>Writing out a label‚Äôs name is equivalent to writing the address of the byte it‚Äôs referencing (with a few exceptions we will see in Part ‚Ö°).
For example, consider the <code>ld de, Tiles</code> at line 25.
<code>Tiles</code> (line 64) is referring to the first byte of the tile data; if we assume that the tile data ends up being stored starting at $0193, then <code>ld de, Tiles</code> is equivalent to <code>ld de, $0193</code>!</p>
<h2 id="whats-with-the-brackets"><a class="header" href="#whats-with-the-brackets">What‚Äôs with the brackets?</a></h2>
<p>Right, we came into this because we wanted to know what the brackets in <code>ld a, [de]</code> mean.
Well, they can basically be read as ‚Äúat address‚Ä¶‚Äù.
For example, <code>ld a, b</code> can be read as ‚Äúcopy into <code>a</code> the value stored in <code>b</code>‚Äù; <code>ld a, [$5414]</code> would be read as ‚Äúcopy into <code>a</code> the value stored at address $5414‚Äù, and <code>ld a, [de]</code> would be read as ‚Äúcopy into <code>a</code> the value stored at address <code>de</code>‚Äù.
Wait, what does that mean?
Well, if <code>de</code> contains the value $5414, then <code>ld a, [de]</code> will do the same thing as <code>ld a, [$5414]</code>.</p>
<div class="box tip">
<p>If you‚Äôre familiar with C, these brackets are basically how the dereference operator is implemented.</p>
</div>
<h3 id="hli"><a class="header" href="#hli"><code>hli</code></a></h3>
<p>An astute reader will have noticed the <code>ld [hli], a</code> just below the <code>ld a, [de]</code> we have just studied.
<code>[de]</code> makes sense because it‚Äôs one of the register pairs we saw a couple lessons ago, but <code>[hli]</code>?
It‚Äôs actually a special notation, which can also be written as <code>[hl+]</code>.
It functions as <code>[hl]</code>, but <code>hl</code> is <em>incremented</em> just after memory is accessed.
<code>[hld]</code>/<code>[hl-]</code> is the mirror of this one, <em>decrementing</em> <code>hl</code> instead of incrementing it.</p>
<h2 id="an-example"><a class="header" href="#an-example">An example</a></h2>
<p>So, if we look at the first two instructions of <code>CopyTiles</code>:</p>
<pre><code class="language-rgbasm linenos start=29">	ld a, [de]
	ld [hli], a
</code></pre>
<p>‚Ä¶we can see that we‚Äôre copying the byte in memory <em>pointed to</em> by <code>de</code> (that is, whose address is contained in <code>de</code>) into the byte pointed to by <code>hl</code>.
Here, <code>a</code> serves as temporary storage, since the CPU is unable to perform <code>ld [hl], [de]</code> directly.</p>
<p>While we‚Äôre at this, let‚Äôs examine the rest of <code>.copyTiles</code> in the following lessons!</p>
<hr />
<div class="footnote-definition" id="memory_magnetic"><sup class="footnote-definition-label">1</sup>
<p>Actually, this depends a lot on the type of memory.
A lot of memory nowadays uses magnetic storage, but to keep the explanation simple, and to parallel the explanation of binary given earlier, let‚Äôs assume that current is being used.</p>
</div>
<div class="footnote-definition" id="rom_ram_and"><sup class="footnote-definition-label">2</sup>
<p>There are other types of memory, such as flash memory or EEPROM, but only Flash has been used on the Game Boy, and for only a handful of games; so we can mostly forget about them.</p>
</div>
<div class="footnote-definition" id="rom_ro"><sup class="footnote-definition-label">3</sup>
<p>No, really!
Mask ROM is created by literally punching holes into a layer of silicon using acid, and e.g. the console‚Äôs boot ROM is made of hard-wired transitors within the CPU die.
Good luck writing to that!
<br>
‚ÄúROM‚Äù is sometimes (mis)used to refer to ‚Äúpersistent memory‚Äù chips, such as flash memory, whose write functionality was disabled.
Most bootleg / ‚Äúrepro‚Äù Game Boy cartridges you can find nowadays actually contain flash; this is why you can reflash them using specialized hardware, but original cartridges cannot be.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="header"><a class="header" href="#header">Header</a></h1>
<p>Let‚Äôs go back to a certain line near the top of <code>hello-world.asm</code>.</p>
<pre><code class="language-rgbasm linenos start=7">	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>What is this mysterious header, why are we making room for it, and more questions answered in this lesson!</p>
<h2 id="what-is-the-header"><a class="header" href="#what-is-the-header">What is the header?</a></h2>
<p>First order of business is explaining what the header <em>is</em>.
It‚Äôs the region of memory from $0104 to $014F (inclusive).
It contains metadata about the ROM, such as its title, Game Boy Color compatibility, size,
two checksums, and interestingly, the Nintendo logo that is displayed during the power-on animation.</p>
<div class="box tip">
<p>You can find this information and more <a href="https://gbdev.io/pandocs/The_Cartridge_Header">in the Pan Docs</a>.</p>
</div>
<p>Interestingly, most of the information in the header does not matter on real hardware (the ROM‚Äôs size is determined only by the capacity of the ROM chip in the cartridge, not the header byte).
In fact, some prototype ROMs actually have incorrect header info!</p>
<p>Most of the header was only used by Nintendo‚Äôs manufacturing department to know what components to put in the cartridge when publishing a ROM.
Thus, only ROMs sent to Nintendo had to have a fully correct header; ROMs used for internal testing only needed to pass the boot ROM‚Äôs checks, explained further below.</p>
<p>However, in our ‚Äúmodern‚Äù day and age, the header actually matters a lot.
Emulators (including hardware emulators such as flashcarts) must emulate the hardware present in the cartridge.
The header being the only source of information about what hardware the ROM‚Äôs cartridge should contain, they rely on some of the values in the header.</p>
<h2 id="boot-rom"><a class="header" href="#boot-rom">Boot ROM</a></h2>
<p>The header is intimately tied to what is called the <strong>boot ROM</strong>.</p>
<p>The most observant and/or nostalgic of you may have noticed the lack of the boot-up animation and the Game Boy‚Äôs signature ‚Äúba-ding!‚Äù in Emulicious.
When the console powers up, the CPU does not begin executing instructions at address $0100 (where our ROM‚Äôs entry point is), but at $0000.</p>
<p>However, at that time, a small program called the <em>boot ROM</em>, burned within the CPU‚Äôs silicon, is ‚Äúoverlaid‚Äù on top of our ROM!
The boot ROM is responsible for the startup animation, but it also checks the ROM‚Äôs header!
Specifically, it verifies that the Nintendo logo and header checksums are correct; if either check fails, the boot ROM intentionally <em>locks up</em>, and our game never gets to run :(</p>
<div class="box tip"><p class="box-title">For the curious</p>
<p>You can find a more detailed description of what the boot ROM does <a href="https://gbdev.io/pandocs/Power_Up_Sequence">in the Pan Docs</a>, as well as an explanation of the logo check.
Beware that it is quite advanced, though.</p>
<p>If you want to enable the boot ROMs in Emulicious, you must obtain a copy of the boot ROM(s), whose SHA256 checksums can be found <a href="https://github.com/ISSOtm/gb-bootroms/blob/master/sha256sums.txt">in their disassembly</a> for verification.
If you wish, you can also compile <a href="https://github.com/LIJI32/SameBoy#compilation">SameBoy‚Äôs boot ROMs</a> and use those instead, as a free-software substitute.</p>
<p>Then, in Emulicious‚Äô options, go to the <code>Options</code> tab, then <code>Emulation</code>‚Üí<code>Game Boy</code>, and choose which of GB and/or GBC boot roms you want to set.
Finally, set the path(s) to the boot ROM(s) you wish to use, and click <code>Open</code>.
Now, just reset the emulator, and voil√†!</p>
</div>
<p>A header is typically called ‚Äúvalid‚Äù if it would pass the boot ROM‚Äôs checks, and ‚Äúinvalid‚Äù otherwise.</p>
<h2 id="rgbfix-1"><a class="header" href="#rgbfix-1">RGBFIX</a></h2>
<p>RGBFIX is the third component of RGBDS, whose purpose is to write a ROM‚Äôs header.
It is separate from RGBLINK so that it can be used as a stand-alone tool.
Its name comes from that RGBLINK typically does not produce a ROM with a valid header, so the ROM must be ‚Äúfixed‚Äù before it‚Äôs production-ready.</p>
<p>RGBFIX has <a href="https://rgbds.gbdev.io/docs/rgbfix.1">a bunch of options</a> to set various parts of the header; but the only two that we are using here are <code>-v</code>, which produces a <strong>v</strong>alid header (so, correct <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0104-0133---nintendo-logo">Nintendo logo</a> and <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#014d---header-checksum">checksums</a>), and <code>-p¬†0xFF</code>, which <strong>p</strong>ads the ROM to the next valid size (using $FF as the filler byte), and writes the appropriate value to the <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0148---rom-size">ROM size byte</a>.</p>
<p>If you look at other projects, you may find RGBFIX invocations with more options, but these two should almost always be present.</p>
<h2 id="so-whats-the-deal-with-that-line"><a class="header" href="#so-whats-the-deal-with-that-line">So, what‚Äôs the deal with that line?</a></h2>
<p>Right!
This line.</p>
<pre><code class="language-rgbasm linenos start=7">	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>Well, let‚Äôs see what happens if we remove it (or comment it out).</p>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgbasm -L -o hello-world.o hello-world.asm</span>
<span class="console-line hljs-meta"></span><span class="language-bash">rgblink -o hello-world.gb -n hello-world.sym hello-world.o</span>
</code></pre>
<p>(I am intentionally not running RGBFIX; we will see why in a minute.)</p>
<p><img src="part1/../assets/img/bad_warnings.png" alt="‚ÄúThis rom would not work on a real gameboy.‚Äù" /></p>
<p>As I explained, RGBFIX is responsible for writing the header, so we should use it to fix this exception.</p>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgbfix -v -p 0xFF hello-world.gb</span>
warning: Overwrote a non-zero byte in the Nintendo logo
warning: Overwrote a non-zero byte in the header checksum
warning: Overwrote a non-zero byte in the global checksum
</code></pre>
<p><em>I‚Äôm sure these warnings are nothing to be worried about‚Ä¶</em>
(Depending on your version of RGBDS, you may have gotten different warnings, or none at all.)</p>
<p>Let‚Äôs run the ROM, click on Console on the debugger‚Äôs bottom window, press <kbd><kbd>F5</kbd></kbd> a few times, and‚Ä¶</p>
<figure>
  <img src="part1/../assets/img/invalid_opcode.png" alt="Screenshot of Emulicious' debugger, PC won't advance past $0105">
  <figcaption>
    When the console reads "Executing illegal instruction", you <i>might</i> have screwed up somewhere.
  </figcaption>
</figure>
<p><img src="part1/../assets/img/fine.png" alt="‚ÄúThis is fine‚Äù meme strip" /></p>
<p>Okay, so, what happened?</p>
<p>As we can see from the screenshot, PC is at $0105.
What is it doing there?</p>
<p>‚Ä¶Oh, <code>EntryPoint</code> is at $0103.
So the <code>jp</code> at $0100 went there, and started executing instructions (<code>3E CE</code> is the raw form of <code>ld a, $CE</code>), but then $ED does not encode any valid instruction, so the CPU locks up.</p>
<p>But why is <code>EntryPoint</code> there?
Well, as you may have figured out from the warnings RGBFIX printed, it <em>overwrites</em> the header area in the ROM.
However, RGBLINK is <strong>not</strong> aware of the header (because RGBLINK is not only used to generate ROMs!), so you must explicitly reserve space for the header area.</p>
<div class="box danger decorated"><p>ü•¥</p>
<p>Forgetting to reserve this space, and having a piece of code or data ending up there then overwritten, is a common beginner mistake that can be quite puzzling.
Fortunately, RGBFIX since version 0.5.1 warns when it detects this mistake, as shown above.</p>
</div>
<p>So, we prevent disaster like this:</p>
<pre><code class="language-rgbasm linenos start=3">SECTION &quot;Header&quot;, ROM0[$100]

	jp EntryPoint

	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>The directive <code>ds</code> stands for ‚Äúdefine space‚Äù, and allows filling a range of memory.
This specific line fills all bytes from $103 to $14F (inclusive) with the value $00.
Since different pieces of code and/or data cannot overlap, this ensures that the header‚Äôs memory range can safely be overwritten by RGBFIX, and that nothing else accidentally gets steamrolled instead.</p>
<p>It may not be obvious how this <code>ds</code> ends up filling that specific memory range.
The 3-byte <code>jp</code> covers memory addresses $100, $101, and $102.
(We start at $100 because that‚Äôs where the <code>SECTION</code> is hardcoded to be.)
When RGBASM processes the <code>ds</code> directive, <code>@</code> (which is a special symbol that evaluates to ‚Äúthe current address‚Äù) thus has the value $103, so it fills <code>$150 - $103 = $4D</code> bytes with zeros, so $103, $104, ‚Ä¶, $14E, $14F.</p>
<h2 id="bonus-the-infinite-loop"><a class="header" href="#bonus-the-infinite-loop">Bonus: the infinite loop</a></h2>
<p>(This is not really linked to the header, but I need to explain it somewhere, and here is as good a place as any.)</p>
<p>You may also be wondering what the point of the infinite loop at the end of the code is for.</p>
<pre><code class="language-rgbasm">Done:
	jp Done
</code></pre>
<p>Well, simply enough, the CPU never stops executing instructions; so when our little Hello World is done and there is nothing left to do, we must still give the CPU some busy-work: so we make it do nothing, forever.</p>
<p>We cannot let the CPU just run off, as it would then start executing other parts of memory as code, possibly crashing.
(See for yourself: remove or comment out these two lines, re-<a href="part1/hello_world.html">compile the ROM</a>, and see what happens!)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operations--flags"><a class="header" href="#operations--flags">Operations &amp; flags</a></h1>
<p>Alright, we know how to pass values around, but just copying numbers is no fun; we want to modify them!</p>
<p>The GB CPU does not provide every operation under the sun (for example, there is no multiplication instruction), but we can just program those ourselves with what we have.
Let‚Äôs talk about some of the operations that it <em>does</em> have; I will be omitting some not used in the Hello World for now.</p>
<h2 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h2>
<p>The simplest arithmetic instructions the CPU supports are <code>inc</code> and <code>dec</code>, which INCrement and DECrement their operand, respectively.
(If you aren‚Äôt sure, ‚Äúto increment‚Äù means ‚Äúto add 1‚Äù, and ‚Äúto decrement‚Äù means ‚Äúto subtract 1‚Äù.)
So for example, the <code>dec bc</code> at line 32 of <code>hello-world.asm</code> simply subtracts 1 from <code>bc</code>.</p>
<p>Okay, cool!
Can we go a bit faster, though?
Sure we can, with <code>add</code> and <code>sub</code>!
These respectively ADD and SUBtract arbitrary values (either a constant, or a register).
Neither is used in the tutorial, but a sibling of <code>sub</code>‚Äôs is: have you noticed little <code>cp</code> over at line 17?
<code>cp</code> allows ComParing values.
It works the same as <code>sub</code>, but it discards the result instead of writing it back.
‚ÄúWait, so it does nothing?‚Äù you may ask; well, it <em>does</em> update the <strong>flags</strong>.</p>
<h2 id="flags"><a class="header" href="#flags">Flags</a></h2>
<p>The time has come to talk about the special-purpose register (remember those?) <code>f</code>, for, well, <em>flags</em>.
The <code>f</code> register contains 4 bits, called ‚Äúflags‚Äù, which are updated depending on an operation‚Äôs results.
These 4 flags are:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>Z</td><td>Zero flag</td></tr>
<tr><td>N</td><td>Addition/subtraction</td></tr>
<tr><td>H</td><td>Half-carry</td></tr>
<tr><td>C</td><td>Carry</td></tr>
</tbody></table>
</div>
<p>Yes, there is a flag called ‚ÄúC‚Äù and a register called ‚Äúc‚Äù, and <strong>they are different, unrelated things</strong>.
This makes the syntax a bit confusing at the beginning, but they are always used in different contexts, so it‚Äôs fine.</p>
<p>We will forget about N and H for now; let‚Äôs focus on Z and C.
Z is the simplest flag: it gets set when an operation‚Äôs result is 0, and gets reset otherwise.
C is set when an operation <em>overflows</em> or <em>underflows</em>.</p>
<p>What‚Äôs an overflow?
Let‚Äôs take the simple instruction <code>add a, 42</code>.
This simply adds 42 to the contents of register <code>a</code>, and writes the result back into <code>a</code>.</p>
<pre><code class="language-rgbasm">    ld a, 200
    add a, 42
</code></pre>
<p>At the end of this snippet, <code>a</code> equals 200 + 42 = 242, great!
But what if I write this instead?</p>
<pre><code class="language-rgbasm">    ld a, 220
    add a, 42
</code></pre>
<p>Well, one could think that <code>a</code> would be equal to 220 + 42 = 262, but that would be incorrect.
Remember, <code>a</code> is an 8-bit register, <em>it can only store eight bits of information</em>!
And if we were to write 262 in binary, we would get %100000110, which requires at least 9 bits‚Ä¶
So what happens?
Simply, that ninth bit is <em>lost</em>, and the value that we end up with is %00000110 = 6.
This is called an <em>overflow</em>: after <strong>adding</strong>, we get a value <strong>smaller</strong> than what we started with.</p>
<p>We can also do the opposite with <code>sub</code>, and‚Äîfor example‚Äîsubtract 42 from 6; as we know, for all <code>X</code> and <code>Y</code>, <code>X + Y - Y = X</code>, and we just saw that 220 + 42 = 6 (this is called <em>modulo 256 arithmetic</em>, by the way); so, 6 - 42 = (220 + 42) - 42 = 220.
This is called an <em>underflow</em>: after <strong>subtracting</strong>, we get a value <strong>greater</strong> than what we started with.</p>
<p>When an operation is performed, it sets the carry flag if an overflow or underflow occurred, and clears it otherwise.
(We will see later that not all operations update the carry flag, though.)</p>
<div class="box tip"><p class="box-title">Summary</p>
<ul>
<li>We can add and subtract numbers.</li>
<li>The Z flag lets us know if the result was 0.</li>
<li>However, registers can only store a limited range of integers.</li>
<li>Going outside this range is called an <strong>overflow</strong> or <strong>underflow</strong>, for addition and subtraction respectively.</li>
<li>The C flag lets us know if either occurred.</li>
</ul>
</div>
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<p>Now, let‚Äôs talk more about how <code>cp</code> is used to compare numbers.
Here is a refresher: <code>cp</code> subtracts its operand from <code>a</code> and updates flags accordingly, but doesn‚Äôt write the result back.
We can use flags to check properties about the values being compared, and we will see in the next lesson how to use the flags.</p>
<p>The simplest interaction is with the Z flag.
If it‚Äôs set, we know that the subtraction yielded 0, i.e. <code>a - operand == 0</code>; therefore, <code>a == operand</code>!
If it‚Äôs not set, well, then we know that <code>a != operand</code>.</p>
<p>Okay, checking for equality is nice, but we may also want to perform <em>comparisons</em>.
Fret not, for the carry flag is here to do just that!
See, when performing a subtraction, the carry flag gets set when the result goes below 0‚Äîbut that‚Äôs just a fancy way of saying ‚Äúbecomes negative‚Äù!</p>
<p>So, when the carry flag gets set, we know that <code>a - operand &lt; 0</code>, therefore that <code>a &lt; operand</code>..!
And, conversely, we know that if it‚Äôs <em>not</em> set, <code>a &gt;= operand</code>.
Great!</p>
<h2 id="instruction-summary"><a class="header" href="#instruction-summary">Instruction summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Instruction</th><th>Mnemonic</th><th>Effect</th></tr></thead><tbody>
<tr><td>Add</td><td><code>add</code></td><td>Adds values to <code>a</code></td></tr>
<tr><td>Subtract</td><td><code>sub</code></td><td>Subtracts values from <code>a</code></td></tr>
<tr><td>Compare</td><td><code>cp</code></td><td>Compares values with what‚Äôs contained in <code>a</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="jumps"><a class="header" href="#jumps">Jumps</a></h1>
<div class="box tip">
<p>Once this lesson is done, we will be able to understand all of <code>CopyTiles</code>!</p>
</div>
<p>So far, all the code we have seen was linear: it executes top to bottom.
But this doesn‚Äôt scale: sometimes, we need to perform certain actions depending on the result of others (‚Äúif the cr√™pes start sticking, grease the pan again‚Äù), and sometimes, we need to perform actions repeatedly (‚ÄúIf there is some batter left, repeat from step 5‚Äù).</p>
<p>Both of these imply reading the recipe non-linearly.
In assembly, this is achieved using <em>jumps</em>.</p>
<p>The CPU has a special-purpose register called ‚ÄúPC‚Äù, for Program Counter.
It contains the address of the instruction currently being executed<sup class="footnote-reference"><a href="#pc_updates">1</a></sup>, like how you‚Äôd keep in mind the number of the recipe step you‚Äôre currently doing.
PC increases automatically as the CPU reads instructions, so ‚Äúby default‚Äù they are read sequentially; however, jump instructions allow writing a different value to PC, effectively <em>jumping</em> to another piece of the program.
Hence the name.</p>
<p>Okay, so, let‚Äôs talk about those jump instructions, shall we?
There are four of them:</p>
<div class="table-wrapper"><table><thead><tr><th>Instruction</th><th>Mnemonic</th><th>Effect</th></tr></thead><tbody>
<tr><td>Jump</td><td><code>jp</code></td><td>Jump execution to a location</td></tr>
<tr><td>Jump Relative</td><td><code>jr</code></td><td>Jump to a location close by</td></tr>
<tr><td>Call</td><td><code>call</code></td><td>Call a subroutine</td></tr>
<tr><td>Return</td><td><code>ret</code></td><td>Return from a subroutine</td></tr>
</tbody></table>
</div>
<p>We will focus on <code>jp</code> for now.
<code>jp</code>, such as the one line 5, simply sets PC to its argument, jumping execution there.
In other words, after executing <code>jp EntryPoint</code> (line 5), the next instruction executed is the one below <code>EntryPoint</code> (line <!-- should be 9 + 1 --> 16).</p>
<div class="box tip decorated"><p>ü§î</p>
<p>You may be wondering what is the point of that specific <code>jp</code>.
Don‚Äôt worry, we will see later why it‚Äôs required.</p>
</div>
<h2 id="conditional-jumps"><a class="header" href="#conditional-jumps">Conditional jumps</a></h2>
<p>Now to the <em>really</em> interesting part.
Let‚Äôs examine the loop responsible for copying tiles:</p>
<pre><code class="language-rgbasm linenos start=24">	; Copy the tile data
	ld de, Tiles
	ld hl, $9000
	ld bc, TilesEnd - Tiles
CopyTiles:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTiles
</code></pre>
<div class="box tip">
<p>Don‚Äôt worry if you don‚Äôt quite get all the following, as we‚Äôll see it live in action in the next lesson.
If you‚Äôre having trouble, try going to the next lesson, watch the code execute step by step; then, coming back here, it should make more sense.</p>
</div>
<p>First, we copy <code>Tiles</code>, the address of the first byte of tile data, into <code>de</code>.
Then, we set <code>hl</code> to $9000, which is the address where we will start copying the tile data to.
<code>ld bc, TilesEnd - Tiles</code> sets <code>bc</code> to the length of the tile data: <code>TilesEnd</code> is the address of the first byte <em>after</em> the tile data, so subtracting <code>Tiles</code> to that yields the length.</p>
<p>So, basically:</p>
<ul>
<li><code>de</code> contains the address where data will be copied from;</li>
<li><code>hl</code> contains the address where data will be copied to;</li>
<li><code>bc</code> contains how many bytes we have to copy.</li>
</ul>
<p>Then we arrive at the main loop.
We read one byte from the source (line 29), and write it to the destination (line 30).
We increment the destination (via the implicit <code>inc hl</code> done by <code>ld [hli], a</code>) and source pointers (line 31), so the following loop iteration processes the next byte.</p>
<p>Here‚Äôs the interesting part: since we‚Äôve just copied one byte, that means we have one less to go, so we <code>dec bc</code>.
(We have seen <code>dec</code> two lessons ago; as a refresher, it simply decreases the value stored in <code>bc</code> by one.)
Since <code>bc</code> contains the amount of bytes that still need to be copied, it‚Äôs trivial to see that we should simply repeat the operation if <code>bc</code> != 0.</p>
<div class="box danger decorated"><p>üòì</p>
<p><code>dec</code> usually updates flags, but unfortunately <code>dec bc</code> doesn‚Äôt, so we must check if <code>bc</code> reached 0 manually.</p>
</div>
<p><code>ld a, b</code> and <code>or a, c</code> ‚Äúbitwise OR‚Äù <code>b</code> and <code>c</code> together; it‚Äôs enough to know for now that it leaves 0 in <code>a</code> if and only if <code>bc</code> == 0.
And <code>or</code> updates the Z flag!
So, after line 34, the Z flag is set if and only if <code>bc</code> == 0, that is, if we should exit the loop.</p>
<p>And this is where conditional jumps come into the picture!
See, it‚Äôs possible to <strong>conditionally</strong> ‚Äútake‚Äù a jump depending on the state of the flags.</p>
<p>There are four ‚Äúconditions‚Äù:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Mnemonic</th><th>Description</th></tr></thead><tbody>
<tr><td>Zero</td><td><code>z</code></td><td>Z is set (last operation had a result of 0)</td></tr>
<tr><td>Non-zero</td><td><code>nz</code></td><td>Z is not set (last operation had a non-zero result)</td></tr>
<tr><td>Carry</td><td><code>c</code></td><td>C is set (last operation overflowed)</td></tr>
<tr><td>No carry</td><td><code>nc</code></td><td>C is not set (last operation did not overflow)</td></tr>
</tbody></table>
</div>
<p>Thus, <code>jp nz, CopyTiles</code> can be read as ‚Äúif the Z flag is not set, then jump to <code>CopyTiles</code>‚Äù.
Since we‚Äôre jumping <em>backwards</em>, we will repeat the instructions again: we have just created a <strong>loop</strong>!</p>
<p>Okay, we‚Äôve been talking about the code a lot, and we have seen it run, but we haven‚Äôt really seen <em>how</em> it runs.
Let‚Äôs watch the magic unfold in slow-motion in the next lesson!</p>
<hr />
<div class="footnote-definition" id="pc_updates"><sup class="footnote-definition-label">1</sup>
<p>Not exactly; instructions may be several bytes long, and PC increments after reading each byte.
Notably, this means that when an instruction finishes executing, PC is pointing to the following instruction.
Still, it‚Äôs pretty much ‚Äúwhere the CPU is currently reading from‚Äù, but it‚Äôs better to keep it simple and avoid mentioning instruction encoding for now.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracing"><a class="header" href="#tracing">Tracing</a></h1>
<p>Ever dreamed of being a wizard?
Well, this won‚Äôt give you magical powers, but let‚Äôs see how emulators can be used to control time!</p>
<p>First, make sure to focus the debugger window.
Let‚Äôs first explain the debugger‚Äôs layout:
<img src="part1/../assets/img/debugger.png" alt="" />
Top-left is the code viewer, bottom-left is the data viewer, top-right are some registers (as we saw in <a href="part1/registers.html">the registers lesson</a>), and bottom-right is the stack viewer.
What‚Äôs the stack?
We will answer that question a bit later‚Ä¶ in Part ‚Ö° üòÖ</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>For now, let‚Äôs focus on the code viewer.</p>
<p>As Emulicious can load our source code, our code‚Äôs labels and comments are automatically shown in the debugger.
As we have seen a couple of lessons ago, labels are merely a convenience provided by RGBASM, but they are not part of the ROM itself.
In other emulators, it is very much inconvenient to debug without them, and so sym files (for ‚Äú<strong>sym</strong>bols‚Äù) have been developed.
Let‚Äôs run RGBLINK to generate a sym file for our ROM:</p>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgblink -n hello-world.sym hello-world.o</span>
</code></pre>
<div class="box warning decorated"><p>‚ÄºÔ∏è</p>
<p>The file names matter!
When looking for a ROM‚Äôs sym file, emulators take the ROM‚Äôs file name, strip the extension (here, <code>.gb</code>), replace it with <code>.sym</code>, and look for a file <strong>in the same directory</strong> with that name.</p>
</div>
<h2 id="stepping"><a class="header" href="#stepping">Stepping</a></h2>
<p>When pausing execution, the debugger will automatically focus on the instruction the CPU is about to execute, as indicated by the line highlighted in blue.
<img src="part1/../assets/img/pc.png" alt="Screenshot of the debugger showing that the highlighted line corresponds to PC" /></p>
<div class="box tip decorated"><p>‚ÑπÔ∏è</p>
<p>The instruction highlighted in blue is always what the CPU is <em>about to execute</em>, not what it <em>just executed</em>. Keep this in mind.</p>
</div>
<p>If we want to watch execution from the beginning, we need to reset the emulator.
Go into the emulator‚Äôs ‚ÄúFile‚Äù menu, and select ‚ÄúReset‚Äù, or press <kbd><kbd>Ctrl</kbd>+<kbd>Backspace</kbd></kbd>.</p>
<p>The blue line should automatically move to address $0100<sup class="footnote-reference"><a href="#boot_addr">1</a></sup>, and now we‚Äôre ready to trace!
All the commands for that are in the ‚ÄúRun‚Äù menu.</p>
<ul>
<li>‚ÄúResume‚Äù simply unpauses the emulator.</li>
<li>‚ÄúStep Into‚Äù and ‚ÄúStep Over‚Äù advance the emulator by one instruction.
They only really differ on the <code>call</code> instruction, interrupts, and when encountering a conditional jump, neither of which we are using here, so we will use ‚ÄúStep Into‚Äù.</li>
<li>The other options are not relevant for now.</li>
</ul>
<p>We will have to ‚ÄúStep Into‚Äù a bunch of times, so it‚Äôs a good idea to use the key shortcut.
If we press <kbd><kbd>F5</kbd></kbd> once, the <code>jp EntryPoint</code> is executed.
And if we press it a few more times, can see the instructions being executed, one by one!</p>
<video controls poster="../assets/vid/reset_trace.poster.png">
  <source src="../assets/vid/reset_trace.webm" type="video/webm">
  <source src="../assets/vid/reset_trace.mp4" type="video/mp4">
<img src="part1/../assets/vid/reset_trace.gif" alt="Video demonstration in Emulicious">
</video>
<p>Now, you may notice the <code>WaitVBlank</code> loop runs a <em>lot</em> of times, but what we are interested in is the <code>CopyTiles</code> loop.
We can easily skip over it in several ways; this time, we will use a <em>breakpoint</em>.
We will place the breakpoint on the <code>ld de, Tiles</code> at <code>00:0162</code>; either double-click on that line, or select it and press <kbd><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>B</kbd></kbd>.</p>
<p><img src="part1/../assets/img/breakpoint.png" alt="Debugger screenshot showcasing the breakpoint" /></p>
<p>Then you can resume execution by pressing <kbd><kbd>F8</kbd></kbd>.
Whenever Emulicious is running, and the (emulated) CPU is about to execute an instruction a breakpoint was placed on, it automatically pauses.</p>
<p><img src="part1/../assets/img/bkpt_pause.png" alt="Debugger screenshot showcasing execution paused on the breakpoint" /></p>
<p>You can see where execution is being paused both from the green arrow and the value of PC.</p>
<p>If we trace the next three instructions, we can see the three arguments to the <code>CopyTiles</code> loop getting loaded into registers.</p>
<p><img src="part1/../assets/img/regs_copytiles.png" alt="The state of some registers at the beginning of the CopyTiles loop" /></p>
<p>For fun, let‚Äôs watch the tiles as they‚Äôre being copied.
For that, obviously, we will use the Memory Editor, and position it at the destination.
As we can see from the image above, that would be $9000!</p>
<p>Click on ‚ÄúMemory‚Äù on the bottom window, then ‚ÄúVRAM‚Äù, and press <kbd><kbd>Ctrl</kbd>+<kbd>G</kbd></kbd> (for ‚ÄúGoto‚Äù).</p>
<video controls poster="../assets/vid/trace_copy.poster.png">
  <source src="../assets/vid/trace_copy.webm" type="video/webm">
  <source src="../assets/vid/trace_copy.mp4" type="video/mp4">
<img src="part1/../assets/vid/trace_copy.gif" alt="Video demonstration in Emulicious">
</video>
<p>Awesome, right?</p>
<h2 id="what-next"><a class="header" href="#what-next">What next?</a></h2>
<p>Congrats, you have just learned how to use a debugger!
We have only scratched the surface, though; we will use more of Emulicious‚Äô tools to illustrate the next parts.
Don‚Äôt worry, from here on, lessons will go with a lot more images‚Äîyou‚Äôve made it through the hardest part!</p>
<hr />
<div class="footnote-definition" id="boot_addr"><sup class="footnote-definition-label">1</sup>
<p>Why does execution start at $0100?
That‚Äôs because it‚Äôs where the <a href="https://gbdev.io/pandocs/Power_Up_Sequence">boot ROM</a> hands off control to our game once it‚Äôs done.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tiles"><a class="header" href="#tiles">Tiles</a></h1>
<div class="box tip decorated"><p>üí≠</p>
<p>‚ÄúTiles‚Äù were called differently in documentation of yore.
They were usually called ‚Äúpatterns‚Äù or ‚Äúcharacters‚Äù, the latter giving birth to the ‚ÄúCHR‚Äù abbreviation which is sometimes used to refer to tiles.</p>
<p>For example, on the NES, tile data is usually provided by the cartridge in either <a href="http://wiki.nesdev.com/w/index.php/CHR_ROM_vs._CHR_RAM">CHR ROM or CHR RAM</a>.
The term ‚ÄúCHR‚Äù is typically not used on the Game Boy, though exchanges between communities cause terms to ‚Äúleak‚Äù, so some refer to the area of VRAM where tiles are stored as ‚ÄúCHR RAM‚Äù or ‚ÄúCHR VRAM‚Äù, for example.</p>
<p>As with all such jargon whose meaning may depend on who you are talking to, I will stick to ‚Äútiles‚Äù across this entire tutorial for consistency, being what is the most standard in the GB dev community now.</p>
</div>
<p>Well, copying this data blindly is fine and dandy, but why exactly is the data ‚Äúgraphics‚Äù?</p>
<figure>
  <img src="part1/../assets/img/ah_yes_pixels.png" alt="Screenshot of some tile definitions in the code">
  <figcaption><q>Ah, yes, pixels.</q></figcaption>
</figure>
<p>Let‚Äôs see about that!</p>
<h2 id="helpful-hand"><a class="header" href="#helpful-hand">Helpful hand</a></h2>
<p>Now, figuring out the format with an explanation alone is going to be very confusing; but fortunately, Emulicious got us covered thanks to its <em>Tile Viewer</em>.
You can open it either by selecting ‚ÄúTools‚Äù then ‚ÄúTile Viewer‚Äù, or by clicking on the grid of colored tiles in the debugger‚Äôs toolbar.</p>
<p><img src="part1/../assets/img/vram_viewer.png" alt="Screenshot of the Tile Viewer" /></p>
<p>You can combine the various VRAM viewers by going to ‚ÄúView‚Äù, then ‚ÄúCombine Video Viewers‚Äù.
We will come to the other viewers in due time.
This one shows the tiles present in the Game Boy‚Äôs video memory (or ‚Äú<abbr title="Video RAM">VRAM</abbr>‚Äù).</p>
<div class="box tip decorated"><p>ü§î</p>
<p>I encourage you to experiment with the VRAM viewer, hover over things, tick and untick checkboxes, see by yourself what‚Äôs what. Any questions you might have will be answered in due time, don‚Äôt worry! And if what you‚Äôre seeing later on doesn‚Äôt match my screenshots, ensure that the checkboxes match mine.</p>
</div>
<p>Don‚Äôt mind the ‚Äú¬Æ‚Äù icon in the top-left; we did not put it there ourselves, and we will see why it‚Äôs there later.</p>
<h2 id="short-primer"><a class="header" href="#short-primer">Short primer</a></h2>
<p>You may have heard of tiles before, especially as they were really popular in 8-bit and 16-bit systems.
That‚Äôs no coincidence: tiles are very useful.
Instead of storing every on-screen pixel (144 √ó 160 pixels √ó 2 bits/pixel = 46080 bits = 5760 bytes, compared to the console‚Äôs 8192 bytes of VRAM), pixels are grouped into tiles, and then tiles are assembled in various ways to produce the final image.</p>
<p>In particular, tiles can be reused very easily and at basically no cost, saving a lot of memory!
In addition, manipulating whole tiles at once is much cheaper than manipulating the individual pixels, so this spares processing time as well.</p>
<p>The concept of a ‚Äútile‚Äù is very general, but on the Game Boy, tiles are <em>always</em> 8 by 8 pixels.
Often, hardware tiles are grouped to manipulate them as larger tiles (often 16√ó16); to avoid the confusion, those are referred to as <strong>meta-tiles</strong>.</p>
<h3 id="bpp"><a class="header" href="#bpp">‚Äúbpp‚Äù?</a></h3>
<p>You may be wondering where that ‚Äú2 bits/pixel‚Äù figure earlier came from‚Ä¶
This is something called ‚Äúbit depth‚Äù.</p>
<p>See, colors are <em>not</em> stored in the tiles themselves!
Instead, it works like a coloring book: the tile itself contains 8 by 8 <em>indices</em>, not colors; you give the hardware a tile and a set of colors‚Äîa <strong>palette</strong>‚Äîand it colorizes them!
(This is also why color swaps were very common back then: you could create enemy variations by storing tiny palettes instead of large different graphics.)</p>
<p>Anyway, as it is, Game Boy palettes are 4 colors large.<sup class="footnote-reference"><a href="#pal_size">1</a></sup>
This means that the indices into those palettes, stored in the tiles, can be represented in only <em>two bits</em>!
This is called ‚Äú2 bits per pixel‚Äù, noted ‚Äú2bpp‚Äù.</p>
<p>With that in mind, we are ready to explain how these bytes turn into pixels!</p>
<h2 id="encoding"><a class="header" href="#encoding">Encoding</a></h2>
<p>As I explained, each pixel takes up 2 bits.
Since there are 8 bits in a byte, you might expect each byte to contain 4 pixels‚Ä¶ and you would be neither entirely right, nor entirely wrong.
See, each row of 8 pixels is stored in 2 bytes, but neither of these bytes contains the info for 4 pixels.
(Think of it like a 10 ‚Ç¨ banknote torn in half: neither half is worth anything, but the full bill is worth, well, 10 ‚Ç¨.)</p>
<p>For each pixel, the least significant bit of its index is stored in the first byte, and the most significant bit is stored in the second byte.
Since each byte is a collection of one of the bits for each pixel, it‚Äôs called a <strong>bitplane</strong>.</p>
<p>The leftmost pixel is stored in the leftmost bit of both bytes, the pixel to its right in the second leftmost bit, and so on.
The first pair of bytes stores the topmost row, the second byte the row below that, and so on.</p>
<p>Here is a more visual demonstration:</p>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/txkHN6izK2Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>This encoding may seem a little weird at first, and it can be; it‚Äôs made to be more convenient for the hardware to decode, keeping the circuitry simple and low-power.
It even makes a few cool tricks possible, as we will see (much) later!</p>
<p>You can read up more about the encoding <a href="https://gbdev.io/pandocs/Tile_Data.html">in the Pan Docs</a> and <a href="https://www.huderlem.com/demos/gameboy2bpp.html">ShantyTown‚Äôs site</a>.</p>
<p>In the next lesson, we shall see how colors are applied!</p>
<hr />
<div class="footnote-definition" id="pal_size"><sup class="footnote-definition-label">1</sup>
<p>Other consoles can have varying bit depths; for example, the SNES has 2bpp, 4bpp, and 8bpp depending on the graphics mode and a few other parameters.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="palettes"><a class="header" href="#palettes">Palettes</a></h1>
<p>In the previous lesson, I briefly mentioned that colors are applied to tiles via <em>palettes</em>, but we haven‚Äôt talked much about those yet.</p>
<p>The black &amp; white Game Boy has three palettes, one for the background called <a href="https://gbdev.io/pandocs/Palettes.html#ff47---bgp-bg-palette-data-rw---non-cgb-mode-only"><code>BGP</code></a> (‚ÄúBackGround Palette‚Äù), and two for the objects called <a href="https://gbdev.io/pandocs/Palettes.html#ff48---obp0-object-palette-0-data-rw---non-cgb-mode-only"><code>OBP0</code></a> and <a href="https://gbdev.io/pandocs/Palettes.html#ff48---obp1-object-palette-1-data-rw---non-cgb-mode-only"><code>OBP1</code></a> (‚ÄúOBject Palette 0/1‚Äù).
If you are wondering what ‚Äúobjects‚Äù are, you will have to wait until Part ‚Ö° to find out; for now, let‚Äôs focus on the background.</p>
<div class="box tip decorated"><p>üåà</p>
<p>The Game Boy Color introduced, obviously, colors, and this was mainly done by reworking the way palettes are handled.
We will not talk about Game Boy Color features in Part ‚Ö† for the sake of simplicity, but we will do so in later parts.</p>
</div>
<p>If you chose to combine the video viewers in the previous chapter, the palette viewer should show up on the bottom right of the video viewer.
Otherwise, please select Emulicious‚Äô ‚ÄúTools‚Äù tab, then select <code>Palette Viewer</code>.</p>
<p><img src="part1/../assets/img/pal_viewer.png" alt="Screenshot of the VRAM viewer‚Äôs Palette tab" /></p>
<p>We will be taking a look at the ‚ÄúBGP‚Äù line.
As I explained before, tiles store ‚Äúcolor indices‚Äù for each pixel, which are used to index into the palette.
Color number 0<sup class="footnote-reference"><a href="#numbering_zero">1</a></sup> is the leftmost in that line, and number 3 is the rightmost.</p>
<p>So, in our case, color number 0 is ‚Äúwhite‚Äù, color number 1 is ‚Äúlight gray‚Äù, number 2 is ‚Äúdark gray‚Äù, and number 3 ‚Äúblack‚Äù.
I put air quotes because ‚Äúblack‚Äù isn‚Äôt true black, and ‚Äúwhite‚Äù isn‚Äôt true white.
Further, note that the original Game Boy had shades of green, but the later Game Boy Pocket‚Äôs screen produced shades of gray instead.
And, even better, the Game Boy Color will automatically colorize games that lack Game Boy Color support!</p>
<p><img src="part1/../assets/img/hello_world_autocolor.png" alt="Screenshot of our Hello World, automatically colorized by the Game Boy Color" /></p>
<p>All this to say, one shouldn‚Äôt expect specific colors out of a Game Boy game<sup class="footnote-reference"><a href="#console_detection">2</a></sup>, just four more or less bright colors.</p>
<h2 id="getting-our-hands-dirty"><a class="header" href="#getting-our-hands-dirty">Getting our hands dirty</a></h2>
<p>Well, so far in this tutorial, besides running the Hello World, we have been pretty passive, watching it unfold.
What do you say we start prodding the ROM a bit?</p>
<p>In Emulicious‚Äô debugger, select the ‚ÄúVariables‚Äù tab on the left to show the IO registers.</p>
<p><img src="part1/../assets/img/io_map.png" alt="Screenshot of the IO map" /></p>
<p>While the VRAM viewer offers a visual representation of the palette, the IO map shows the nitty-gritty: how it‚Äôs encoded.
The IO map also lets us modify BGP easily; but to do so, we need to understand <em>how</em> values we write are turned into colors.</p>
<h3 id="encoding-1"><a class="header" href="#encoding-1">Encoding</a></h3>
<p>Fortunately, the encoding is very simple.
I will explain it, and at the same time, give an example with the palette we have at hand, $E4.</p>
<p>Take the byte, break its 8 bits into 4 groups of 2.</p>
<pre><code>[BGP] = $E4
$E4 = %11100100 (refresh your memory in the &quot;Binary and hexadecimal&quot; lesson if needed!)
That gets broken down into %11, %10, %01, %00
</code></pre>
<p>Color number 0 is the rightmost ‚Äúgroup‚Äù, color number 3 is the leftmost one.
Simple!
And this matches what the VRAM viewer is showing us: color number 0, the rightmost, is the brightest (%00), up to color number 3, the leftmost and the darkest (%11).</p>
<h3 id="lights-out"><a class="header" href="#lights-out">Lights out</a></h3>
<p>For fun, let‚Äôs make the screen completely black.
We can easily do this by setting all colors in the palette to black (%11).
This would be <code>%11 %11 %11 %11 = $FF</code>.</p>
<p>In the ‚ÄúVariables‚Äù tab in the debugger, click on the byte to the right of BGP, erase the ‚ÄúE4‚Äù, type ‚ÄúFF‚Äù, and hit Enter.
BGP immediately updates, turning the screen black!</p>
<figure>
	<img src="part1/../assets/img/pal_viewer_black.png" alt="Screenshot of the palette viewer with the BGP line entirely black">
	<figcaption>Observe how the BGP line is entirely black now. Also, I could have shown a screenshot of the black screen, but that would have been silly.</figcaption>
</figure>
<p>What if we wanted to take the original palette, but invert it?
%11 would become %00, %01 would become %10, %10 would become %01, and %00 would become %11.
We would get thus:</p>
<pre><code>%11_10_01_00
 ‚Üì  ‚Üì  ‚Üì  ‚Üì
%00_01_10_11
</code></pre>
<p>(I‚Äôm not giving the value in hexadecimal, use this as an opportunity to exercise your bin-to-hex conversions!)</p>
<figure>
	<img src="part1/../assets/img/hello_world_inv.png" alt="Screenshot of the color-inverted Hello World">
	<figcaption>If you got it right, it should look like this!</figcaption>
</figure>
<p>If you go to the Tile Viewer and change ‚ÄúPalette‚Äù to ‚ÄúGray‚Äù, you will notice that the tile data stays the same regardless of how the palette is modified!
This is an advantage of using palettes: fading the screen in and out is very cheap, just modifying a single byte, instead of having to update every single on-screen pixel.</p>
<p>Got all that?
Then let‚Äôs take a look at the last missing puzzle piece in the Hello World‚Äôs rendering process, the <strong>tilemap</strong>!</p>
<hr />
<div class="footnote-definition" id="numbering_zero"><sup class="footnote-definition-label">1</sup>
<p>Numbering often starts at 0 when working with computers.
We will understand why later, but for now, please bear with it!</p>
</div>
<div class="footnote-definition" id="console_detection"><sup class="footnote-definition-label">2</sup>
<p>Well, it is possible to detect these different models and account for them, but this would require taking plenty of corner cases into consideration, so it‚Äôs probably not worth the effort.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tilemap"><a class="header" href="#tilemap">Tilemap</a></h1>
<div class="box tip decorated"><p>üßê</p>
<p>Some spell them ‚Äútile map‚Äù, some ‚Äútilemap‚Äù.
I will be using the latter by preference, but I also stay consistent with it in the code (<code>Tilemap</code> and not <code>TileMap</code>), as well as later when we will talk about attribute maps (‚Äúattrmap‚Äù and <code>Attrmap</code> instead of <code>AttrMap</code>).</p>
</div>
<p>We are <em>almost</em> there.
We have seen how graphics on the Game Boy are composed of 8√ó8 ‚Äútiles‚Äù, and we have seen how color is added into the mix.</p>
<p>But we have not seen yet how those tiles are arranged into a final picture!</p>
<p>Tiles are basically a grid of pixels; well, the tilemaps are basically a grid of tiles!
To allow for cheap reuse, tiles aren‚Äôt stored in the tilemap directly; instead, tiles are referred to by an <em>ID</em>, which you can see in Emulicious‚Äô Tile Viewer.</p>
<figure>
  <img src="part1/../assets/img/tile_id.png" alt="Screenshot highlighting where a tile's ID can be seen">
  <figcaption>
    The ID is displayed in hexadecimal without a prefix, so this is tile number $10, aka 16.
    As you may have noticed, the tiles are displayed in rows of 16, so it's easier to locate them by hexadecimal ID.
    Nifty!
  </figcaption>
</figure>
<p>Now, of course, tile IDs are numbers, like everything that computers deal with.
IDs are stored in bytes, so there are 256 possible tile IDs.
However, the astute reader will have noticed that there are 384 tiles in total<sup class="footnote-reference"><a href="#tile_blocks">1</a></sup>!
By virtue of the <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">pigeonhole principle</a>, this means that some IDs refer to several tiles at the same time.</p>
<p>Indeed, Emulicious reports that the first 128 tiles have the same IDs as the last 128.
There exists a mechanism to select whether IDs 0‚Äì127 reference the first or last 128 tiles, but for simplicity‚Äôs sake, we will overlook this for now, so please ignore the first (topmost) 128 tiles for the time being.</p>
<p>Now, please turn your attention to Emulicious‚Äô Tilemap Viewer, pictured below.</p>
<p><img src="part1/../assets/img/tilemap_viewer.png" alt="Screenshot of the tilemap viewer" /></p>
<div class="box tip">
<p>You may notice that the image shown is larger than what is displayed on-screen.
Only part of the tilemap, outlined by a thicker border in the Tilemap Viewer, is displayed on-screen at a given time.
We will explain this in more detail in Part ‚Ö°.</p>
</div>
<p>Here we will be able to see the power of tile reuse in full force.
As a convenience and a refresher, here are the tiles our Hello World loads into VRAM:</p>
<p><img src="part1/../assets/img/hello_world_tiles.png" alt="Enlarged view of the tiles loaded in VRAM" /></p>
<p>You can see that we only loaded a single ‚Äúblank‚Äù tile ($00, the first aka. top-left one), but it can be repeated to cover the whole background at no extra cost!</p>
<p>Repetition can be more subtle: for example, tile $01 is used for the top-left corner of the H, E, L, L, and W (red lines below)!
The R, L, and D also both share their top-left tile ($2D, blue lines below); and so on.
You can confirm this by hovering over tiles in the BG map tab, which shows the ID of the tile at that position.</p>
<figure>
  <img src="part1/../assets/img/hello_world_mappings.svg" alt="Diagram of some tile mappings">
  <figcaption>
    Here are some examples of tile reuse. Not everything is drawn, as it would become a mess.
  </figcaption>
</figure>
<p>All in all, we can surmise that displaying graphics on the Game Boy consists of loading ‚Äúpatterns‚Äù (the tiles), and then telling the console which tile to display for each given location.</p>
<hr />
<div class="footnote-definition" id="tile_blocks"><sup class="footnote-definition-label">1</sup>
<p>The even more astute (astuter?) reader will have noticed that 384 = 3 √ó 128.
Thus, tiles are often conceptually grouped into three ‚Äúblocks‚Äù of 128 tiles each, which Emulicious shows as separated by thicker horizontal lines.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping up</a></h1>
<p>Congrats!
You have made it through the first part of this tutorial.
By this point, you have a basic enough understanding of the console that you know how to display a picture.
And hey, that doesn‚Äôt sound like much, but consider everything you have seen so far‚Äîthere <em>is</em> a lot that goes into it!</p>
<div class="box tip decorated"><p>ü•≥</p>
<p>Honestly, congrats on coming this far‚Äîmany people have given up earlier than this.
So you can give yourself a pat on the back, you honestly deserve it!
<strong>Now may also be a good time to take a break</strong> if you are reading all this in a single trait.
I encourage you to give it a little time to sink in, and maybe go back to the lessons you struggled on the most.
Maybe a second read can help.</p>
</div>
<hr />
<p>And yes, you could simply have let a library handle all that.
However, the details always leak through eventually, so knowing about them is helpful, if only for debugging.</p>
<p>Plus, understanding what‚Äôs really going on under the hood makes you a better programmer, even if you don‚Äôt end up using ASM in the long run.
Amusingly, even modern systems work similarly to older ones in unexpected places, so some things you just learned will carry over!
Trust me, everything you have learned and will learn is worth it! ‚úä</p>
<p>That said, right now, you may have a lot of questions.</p>
<ul>
<li>Why do we turn off the LCD?</li>
<li>We know how to make a static picture, but how to we add motion into the mix?</li>
<li>Also, how do I get input from the player?</li>
<li>The code mentions shutting down audio, but how do I play some of those famed beeps and bloops?</li>
<li>Writing graphics in that way sound tedious, is there no other way?</li>
<li>Actually, wait, how do we make a game out of all this??</li>
</ul>
<p>‚Ä¶ All of that answered, and more, in Part ‚Ö°! üëÄ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>In this lesson, we will start a new project from scratch.
We will make a <a href="https://en.wikipedia.org/wiki/Breakout_%28video_game%29">Breakout</a> / <a href="https://en.wikipedia.org/wiki/Arkanoid">Arkanoid</a> clone, which we‚Äôll call ‚ÄúUnbricked‚Äù!
(Though you are free to give it any other name you like, as it will be <em>your</em> project.)</p>
<p>Open a terminal and make a new directory (<code>mkdir unbricked</code>), and then enter it (<code>cd unbricked</code>), just like you did for <a href="part2/../part1/hello_world.html">‚ÄúHello, world!‚Äù</a>.</p>
<p>Start by creating a file called <code>main.asm</code>, and include <code>hardware.inc</code> in your code.</p>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;hardware.inc&quot;
</code></pre>
<p>You may be wondering what purpose <code>hardware.inc</code> serves.
Well, the code we write only really affects the CPU, but does not do anything with the rest of the console (not directly, anyway).
To interact with other components (like the graphics system, say), <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">Memory-Mapped <abbr title="Input/Output">I/O</abbr></a> (MMIO) is used: basically, <a href="part2/../part1/memory.html">memory</a> in a certain range (addresses $FF00‚ÄìFF7F) does special things when accessed.</p>
<p>These bytes of memory being interfaces to the hardware, they are called <em>hardware registers</em> (not to be mistaken with <a href="part2/../part1/registers.html">the CPU registers</a>).
For example, the ‚ÄúPPU status‚Äù register is located at address $FF41.
Reading from that address reports various bits of info regarding the graphics system, and writing to it allows changing some parameters.
But, having to remember all the numbers (<a href="https://gbdev.io/pandocs/Power_Up_Sequence.html#hardware-registers">non-exhaustive list</a>) would be very tedious‚Äîand this is where <code>hardware.inc</code> comes into play!
<code>hardware.inc</code> defines one constant for each of these registers (for example, <code>rSTAT</code> for the aforementioned ‚ÄúPPU status‚Äù register), plus some additional constants for values read from or written to these registers.</p>
<div class="box tip">
<p>Don‚Äôt worry if this flew over your head, we‚Äôll see an example below with <code>rLCDC</code> and <code>LCDCF_ON</code>.</p>
<p>By the way, the <code>r</code> stands for ‚Äúregister‚Äù, and the <code>F</code> in <code>LCDCF</code> stands for ‚Äúflag‚Äù.</p>
</div>
<p>Next, make room for the header.
<a href="part2/../part1/header.html">Remember from Part ‚Ö†</a> that the header is where some information that the Game Boy relies on is stored, so you don‚Äôt want to accidentally leave it out.</p>
<pre><code class="language-rgbasm linenos start=3">SECTION &quot;Header&quot;, ROM0[$100]

	jp EntryPoint

	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>The header jumps to <code>EntryPoint</code>, so let‚Äôs write that now:</p>
<pre><code class="language-rgbasm linenos start=9">EntryPoint:
	; Do not turn the LCD off outside of VBlank
WaitVBlank:
	ld a, [rLY]
	cp 144
	jp c, WaitVBlank

	; Turn the LCD off
	ld a, 0
	ld [rLCDC], a
</code></pre>
<p>The next few lines wait until ‚ÄúVBlank‚Äù, which is the only time you can safely turn off the screen (doing so at the wrong time could damage a real Game Boy, so this is very crucial).
We‚Äôll explain what VBlank is and talk about it more later in the tutorial.</p>
<p>Turning off the screen is important because loading new tiles while the screen is on is tricky‚Äîwe‚Äôll touch on how to do that in Part 3.</p>
<p>Speaking of tiles, we‚Äôre going to load some into VRAM next, using the following code:</p>
<pre><code class="language-rgbasm linenos start=20">	; Copy the tile data
	ld de, Tiles
	ld hl, $9000
	ld bc, TilesEnd - Tiles
CopyTiles:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTiles
</code></pre>
<p>This loop might be <a href="part2/../part1/jumps.html#conditional-jumps">reminiscent of part ‚Ö†</a>.
It copies starting at <code>Tiles</code> to <code>$9000</code> onwards, which is the part of VRAM where our <a href="part2/../part1/tiles.html">tiles</a> are going to be stored.
Recall that <code>$9000</code> is where the data of background tile $00 lies, and the data of subsequent tiles follows right after.
To get the number of bytes to copy, we will do just like in Part ‚Ö†: using another label at the end, called <code>TilesEnd</code>, the difference between it (= the address after the last byte of tile data) and <code>Tiles</code> (= the address of the first byte) will be exactly that length.</p>
<p>That said, we haven‚Äôt written <code>Tiles</code> nor any of the related data yet.
We‚Äôll get to that later!</p>
<p>Almost done now‚Äînext, write another loop, this time for copying <a href="part2/../part1/tilemap.html">the tilemap</a>.</p>
<pre><code class="language-rgbasm linenos start=33">	; Copy the tilemap
	ld de, Tilemap
	ld hl, $9800
	ld bc, TilemapEnd - Tilemap
CopyTilemap:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTilemap
</code></pre>
<p>Note that while this loop‚Äôs body is exactly the same as <code>CopyTiles</code>‚Äôs, the 3 values loaded into <code>de</code>, <code>hl</code>, and <code>bc</code> are different.
These determine the source, destination, and size of the copy, respectively.</p>
<p>:::tip ‚Äú<a href="https://en.wikipedia.org/wiki/Don&#x27;t_Repeat_Yourself"><abbr title="Don't Repeat Yourself">DRY</abbr></a>‚Äù</p>
<p>If you think that this is super redundant, you are not wrong, and we will see later how to write actual, reusable <em>functions</em>.
But there is more to them than meets the eye, so we will start tackling them much later.</p>
<p>:::</p>
<p>Finally, let‚Äôs turn the screen back on, and set a <a href="part2/../part1/palettes.html">background palette</a>.
Rather than writing the non-descript number <code>%10000001</code> (or $81 or 129, to taste), we make use of two constants graciously provided by <code>hardware.inc</code>: <code>LCDCF_ON</code> and <code>LCDCF_BGON</code>.
When written to <a href="https://gbdev.io/pandocs/LCDC"><code>rLCDC</code></a>, the former causes the PPU and screen to turn back on, and the latter enables the background to be drawn.
(There are other elements that could be drawn, but we are not enabling them yet.)
Combining these constants must be done using <code>|</code>, the <em>binary ‚Äúor‚Äù</em> operator; we‚Äôll see why later.</p>
<pre><code class="language-rgbasm linenos start=46">	; Turn the LCD on
	ld a, LCDCF_ON | LCDCF_BGON
	ld [rLCDC], a

	; During the first (blank) frame, initialize display registers
	ld a, %11100100
	ld [rBGP], a

Done:
	jp Done
</code></pre>
<p>There‚Äôs one last thing we need before we can build the ROM, and that‚Äôs the graphics.
We will draw the following screen:</p>
<p><img src="part2/../assets/part2/img/tilemap.png" alt="Layout of unbricked" /></p>
<p>In <code>hello-world.asm</code>, tile data had been written out by hand in hexadecimal; this was to let you see how the sausage is made at the lowest level, but <em>boy</em> is it impractical to write!
This time, we will employ a more friendly way, which will let us write each row of pixels more easily.
For each row of pixels, instead of writing <a href="part2/../part1/tiles.html#encoding">the bitplanes</a> directly, we will use a backtick (```) followed by 8 characters.
Each character defines a single pixel, intuitively from left to right; it must be one of 0, 1, 2, and 3, representing the corresponding color index in <a href="part2/../part1/palettes.html">the palette</a>.</p>
<div class="box tip">
<p>If the character selection isn‚Äôt to your liking, you can use <a href="https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.1#g">RGBASM‚Äôs <code>-g</code> option</a> or <a href="https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.5/#Changing_options_while_assembling"><code>OPT g</code></a> to pick others.
For example, <code>rgbasm -g '.xXO' (...)</code> or <code>OPT g.xXO</code> would swap the four characters to <code>.</code>, <code>x</code>, <code>X</code>, and <code>O</code> respectively.</p>
</div>
<p>For example:</p>
<pre><code class="language-rgbasm">	dw `01230123 ; This is equivalent to `db $55,$33`
</code></pre>
<p>You may have noticed that we are using <code>dw</code> instead of <code>db</code>; the difference between these two will be explained later.
We already have tiles made for this project, so you can copy <a href="https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tileset.asm">this premade file</a>, and paste it at the end of your code.</p>
<p>Then copy the tilemap from <a href="https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tilemap.asm">this file</a>, and paste it after the <code>TilesEnd</code> label.</p>
<p>You can build the ROM now, by running the following commands in your terminal:</p>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgbasm -L -o main.o main.asm</span>
<span class="console-line hljs-meta"></span><span class="language-bash">rgblink -o unbricked.gb main.o</span>
<span class="console-line hljs-meta"></span><span class="language-bash">rgbfix -v -p 0xFF unbricked.gb</span>
</code></pre>
<p>If you run this in your emulator, you should see the following:</p>
<p><img src="part2/../assets/part2/img/screenshot.png" alt="Screenshot of our game" /></p>
<p>That white square seems to be missing!
You may have noticed this comment earlier, somewhere in the tile data:</p>
<pre><code class="language-rgbasm linenos start=135">	dw `22322232
	dw `23232323
	dw `33333333
	; Paste your logo here:

TilesEnd:
</code></pre>
<p>The logo tiles were left intentionally blank so that you can choose your own.
You can use one of the following pre-made logos, or try coming up with your own!</p>
<ul>
<li>
<p><strong>RGBDS Logo</strong></p>
<p><img src="part2/../assets/part2/img/rgbds.png" alt="The RGBDS Logo" /></p>
<p><a href="https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/rgbds.asm">Source</a></p>
</li>
<li>
<p><strong>Duck</strong></p>
<p><img src="part2/../assets/part2/img/duck.png" alt="A pixel-art duck" /></p>
<p><a href="https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/duck.asm">Source</a></p>
</li>
<li>
<p><strong>Tail</strong></p>
<p><img src="part2/../assets/part2/img/tail.png" alt="A silhouette of a tail" /></p>
<p><a href="https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tail.asm">Source</a></p>
</li>
</ul>
<p>Add your chosen logo‚Äôs data (click one of the ‚ÄúSource‚Äù links above) after the comment, build the game again, and you should see your logo of choice in the bottom-right!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objects"><a class="header" href="#objects">Objects</a></h1>
<p>The background is very useful when the whole screen should move at once, but this is not ideal for everything.
For example, a cursor in a menu, NPCs and the player in a RPG, bullets in a shmup, or balls in an <em>Arkanoid</em> clone‚Ä¶ all need to move independently of the background.
Thankfully, the Game Boy has a feature that‚Äôs perfect for these!
In this lesson, we will talk about <em>objects</em> (sometimes called ‚ÄúOBJ‚Äù).</p>
<div class="box tip">
<p>The above description may have made you think of the term ‚Äúsprite‚Äù instead of ‚Äúobject‚Äù.
The term ‚Äúsprite‚Äù has a <em>lot</em> of meanings depending on context, so, to avoid confusion, this tutorial tries to use specific alternatives instead, such as <em>object</em>, <em>metasprite</em>, <em>actor</em>, etc.</p>
</div>
<p>Each object allows drawing one or two tiles (so 8√ó8 or 8√ó16 pixels, respectively) at any on-screen position‚Äîunlike the background, where all the tiles are drawn in a grid.
Therefore, an object consists of its on-screen position, a tile ID (like <a href="part2/../part1/tilemap.html">with the tilemap</a>), and some extra properties called ‚Äúattributes‚Äù.
These extra properties allow, for example, to display the tile flipped.
We‚Äôll see more about them later.</p>
<p>Just like how the tilemap is stored in VRAM, objects live in a region of memory called OAM, meaning <strong>Object Attribute Memory</strong>.
Recall from above that an object consists of:</p>
<ul>
<li>Its on-screen position</li>
<li>A tile ID</li>
<li>The ‚Äúattributes‚Äù</li>
</ul>
<p>These are stored in 4 bytes: one for the Y coordinate, one for the X coordinate, one for the tile ID, and one for the attributes.
OAM is 160 bytes long, and since 160 ‚àï 4 = 40, the Game Boy stores a total of <strong>40</strong> objects at any given time.</p>
<p>There is a catch, though: an object‚Äôs Y and X coordinate bytes in OAM do <em>not</em> store its on-screen position!
Instead, the <em>on-screen</em> X position is the <em>stored</em> X position <strong>minus 8</strong>, and the <em>on-screen</em> Y position is the <em>stored</em> Y position <strong>minus 16</strong>.
To stop displaying an object, we can simply put it off-screen, e.g. by setting its Y position to 0.</p>
<div class="box tip">
<p>These offsets are not arbitrary!
Consider an object‚Äôs maximum size: 8 by 16 pixels.
These offsets allow objects to be clipped by the left and top edges of the screen.
The NES, for example, lacks such offsets, so you will notice that objects always disappear after hitting the left or top edge of the screen.</p>
</div>
<p>Let‚Äôs discover objects by experimenting with them!</p>
<p>First off, when the Game Boy is powered on, OAM is filled with a bunch of semi-random values, which may cover the screen with some random garbage.
Let‚Äôs fix that by first clearing OAM before enabling objects for the first time.
Let‚Äôs add the following just after the <code>CopyTilemap</code> loop:</p>
<pre><code class="language-rgbasm linenos start=59">	ld a, 0
	ld b, 160
	ld hl, _OAMRAM
ClearOam:
	ld [hli], a
	dec b
	jp nz, ClearOam
</code></pre>
<p>This is a good time to do that, since just like VRAM, the screen must be off to safely access OAM.</p>
<p>Once OAM is clear, we can draw an object by writing its properties.</p>
<pre><code class="language-rgbasm linenos start=67">	ld hl, _OAMRAM
	ld a, 128 + 16
	ld [hli], a
	ld a, 16 + 8
	ld [hli], a
	ld a, 0
	ld [hli], a
	ld [hl], a
</code></pre>
<p>Remember that each object in OAM is 4 bytes, in the order Y, X, Tile ID, Attributes.
So, the object‚Äôs top-left pixel lies 128 pixels from the top of the screen, and 16 from its left.
The tile ID and attributes are both set to 0.</p>
<p>You may remember from the previous lesson that we‚Äôre already using tile ID 0, as it‚Äôs the start of our background‚Äôs graphics.
However, by default objects and backgrounds use a different set of tiles, at least for the first 128 IDs.
Tiles with IDs 128‚Äì255 are shared by both, which is useful if you have a tile that‚Äôs used both on the background and by an object.</p>
<p>If you go to ‚ÄúTools‚Äù, then ‚ÄúTile Viewer‚Äù in Emulicious‚Äô debugger, you should see three distinct sections.</p>
<p><img src="part2/../assets/img/vram_viewer.png" alt="image" /></p>
<p>Because we need to load this to a different area, we‚Äôll use the address $8000 and load a graphic for our game‚Äôs paddle.
Let‚Äôs do so right after <code>CopyTilemap</code>:</p>
<pre><code class="language-rgbasm linenos start=46">	; Copy the tile data
	ld de, Paddle
	ld hl, $8000
	ld bc, PaddleEnd - Paddle
CopyPaddle:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyPaddle
</code></pre>
<p>And don‚Äôt forget to add <code>Paddle</code> to the bottom of your code.</p>
<pre><code class="language-rgbasm">Paddle:
	dw `13333331
	dw `30000003
	dw `13333331
	dw `00000000
	dw `00000000
	dw `00000000
	dw `00000000
	dw `00000000
PaddleEnd:
</code></pre>
<p>Finally, let‚Äôs enable objects and see the result.
Objects must be enabled by the familiar <code>rLCDC</code> register, otherwise they just don‚Äôt show up.
(This is why we didn‚Äôt have to clear OAM in the previous lessons.)
We will also need to initialize one of the object palettes, <code>rOBP0</code>.
There are actually two object palettes, but we‚Äôre only going to use one.</p>
<pre><code class="language-rgbasm linenos start=76">	; Turn the LCD on
	ld a, LCDCF_ON | LCDCF_BGON | LCDCF_OBJON
	ld [rLCDC], a

	; During the first (blank) frame, initialize display registers
	ld a, %11100100
	ld [rBGP], a
	ld a, %11100100
	ld [rOBP0], a
</code></pre>
<h2 id="movement"><a class="header" href="#movement">Movement</a></h2>
<p>Now that you have an object on the screen, let‚Äôs move it around.
Previously, the <code>Done</code> loop did nothing; let‚Äôs rename it to <code>Main</code> and use it to move our object.
We‚Äôre going to wait for VBlank before changing OAM, just like we did before turning off the screen.</p>
<pre><code class="language-rgbasm linenos start=90">Main:
    ; Wait until it's *not* VBlank
    ld a, [rLY]
    cp 144
    jp nc, Main
WaitVBlank2:
	ld a, [rLY]
	cp 144
	jp c, WaitVBlank2

	; Move the paddle one pixel to the right.
	ld a, [_OAMRAM + 1]
	inc a
	ld [_OAMRAM + 1], a
	jp Main
</code></pre>
<div class="box tip decorated"><p>ü§®</p>
<p>Here, we are accessing OAM without turning the LCD off, but it‚Äôs still safe.
Explaining why requires a more thorough explanation of the Game Boy‚Äôs rendering, so let‚Äôs ignore it for now.</p>
</div>
<p>Now you should see the paddle moving‚Ä¶ very quickly.
Because it moves by a pixel every frame, it‚Äôs going at a speed of 60 pixels per second!
To slow this down, we‚Äôll use a <em>variable</em>.</p>
<p>So far, we have only worked with the CPU registers, but you can create global variables too!
To do this, let‚Äôs create another section, but putting it in <code>WRAM0</code> instead of <code>ROM0</code>.
Unlike ROM (‚ÄúRead-Only Memory‚Äù), RAM (‚ÄúRandom-Access Memory‚Äù) can be written to; thus, WRAM, or Work RAM, is where we can store our game‚Äôs variables.</p>
<p>Add this to the bottom of your file:</p>
<pre><code class="language-rgbasm linenos start=359">SECTION &quot;Counter&quot;, WRAM0
wFrameCounter: db
</code></pre>
<p>Now we‚Äôll use the <code>wFrameCounter</code> variable to count how many frames have passed since we last moved the paddle.
Every 15th frame, we‚Äôll move the paddle by one pixel, slowing it down to 4 pixels per second.
Don‚Äôt forget that RAM is filled with garbage values when the Game Boy starts, so we need to initialize our variables before first using them.</p>
<pre><code class="language-rgbasm linenos start=86">	; Initialize global variables
	ld a, 0
	ld [wFrameCounter], a

Main:
	ld a, [rLY]
	cp 144
	jp nc, Main
WaitVBlank2:
	ld a, [rLY]
	cp 144
	jp c, WaitVBlank2

	ld a, [wFrameCounter]
	inc a
	ld [wFrameCounter], a
	cp a, 15 ; Every 15 frames (a quarter of a second), run the following code
	jp nz, Main

	; Reset the frame counter back to 0
	ld a, 0
	ld [wFrameCounter], a

	; Move the paddle one pixel to the right.
	ld a, [_OAMRAM + 1]
	inc a
	ld [_OAMRAM + 1], a
	jp Main
</code></pre>
<p>Alright!
Up next is us taking control of that little paddle.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>So far, we have only written a single ‚Äúflow‚Äù of code, but we can already spot some snippets that look redundant.
Let‚Äôs use <strong>functions</strong> to ‚Äúfactor out‚Äù code!</p>
<p>For example, in three places, we are copying chunks of memory around.
Let‚Äôs write a function below the <code>jp Main</code>, and let‚Äôs call it <code>Memcpy</code>, like <a href="https://man7.org/linux/man-pages/man3/memcpy.3.html">the similar C function</a>:</p>
<pre><code class="language-rgbasm linenos start=94">; Copy bytes from one area to another.
; @param de: Source
; @param hl: Destination
; @param bc: Length
Memcopy:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, Memcopy
	ret
</code></pre>
<p>The new <code>ret</code> instruction should immediately catch our eye.
It is, unsurprisingly, what makes execution <em>return</em> to where the function was <em>called</em> from.
Importantly, many languages have a definite ‚Äúend‚Äù to a function: in C or Rust, that‚Äôs the closing brace <code>}</code>; in Pascal or Lua, the keyword <code>end</code>, and so on; the function implicitly returns when execution reaches its end.
However, <strong>this is not the case in assembly</strong>, so you must remember to add a <code>ret</code> instruction at the end of the function to return from it!
Otherwise, the results are unpredictable.</p>
<p>Notice the comment above the function, explaining which registers it takes as input.
This comment is important so that you know how to interface with the function; assembly has no formal parameters, so comments explaining them are even more important than with other languages.
We‚Äôll see more of those as we progress.</p>
<p>There are three places in the initialization code where we can use the <code>Memcpy</code> function.
Find each of these copy loops and replace them with a call to <code>Memcpy</code>; for this, we use the <code>call</code> instruction.
The registers serve as parameters to the function, so we‚Äôll leave them as-is.</p>
<div class="table-wrapper"><table><thead><tr><th>Before</th><th>After</th></tr></thead><tbody><tr><td>
<pre><code class="language-rgbasm linenos start=20">	; Copy the tile data
	ld de, Tiles
	ld hl, $9000
	ld bc, TilesEnd - Tiles
CopyTiles:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTiles
</code></pre>
</td><td>
<pre><code class="language-rgbasm linenos start=20">	; Copy the tile data
	ld de, Tiles
	ld hl, $9000
	ld bc, TilesEnd - Tiles
	call Memcopy
</code></pre>
</td></tr><tr><td>
<pre><code class="language-rgbasm linenos start=33">	; Copy the tilemap
	ld de, Tilemap
	ld hl, $9800
	ld bc, TilemapEnd - Tilemap
CopyTilemap:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTilemap
</code></pre>
</td><td>
<pre><code class="language-rgbasm linenos start=26">	; Copy the tilemap
	ld de, Tilemap
	ld hl, $9800
	ld bc, TilemapEnd - Tilemap
	call Memcopy
</code></pre>
</td></tr><tr><td>
<pre><code class="language-rgbasm linenos start=46">	; Copy the tile data
	ld de, Paddle
	ld hl, $8000
	ld bc, PaddleEnd - Paddle
CopyPaddle:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyPaddle
</code></pre>
</td><td>
<pre><code class="language-rgbasm linenos start=32">	; Copy the tile data
	ld de, Paddle
	ld hl, $8000
	ld bc, PaddleEnd - Paddle
	call Memcopy
</code></pre>
</td></tr></tbody></table></div>
<p>In the next chapter, we‚Äôll write another function, this time to read player input.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input"><a class="header" href="#input">Input</a></h1>
<p>We have the building blocks of a game here, but we‚Äôre still lacking player input.
A game that plays itself isn‚Äôt very much fun, so let‚Äôs fix that.</p>
<p>Paste this code below your <code>Main</code> loop.
Like <code>Memcpy</code>, this is a function that can be reused from different places, using the <code>call</code> instruction.</p>
<pre><code class="language-rgbasm linenos start=113">UpdateKeys:
  ; Poll half the controller
  ld a, P1F_GET_BTN
  call .onenibble
  ld b, a ; B7-4 = 1; B3-0 = unpressed buttons

  ; Poll the other half
  ld a, P1F_GET_DPAD
  call .onenibble
  swap a ; A3-0 = unpressed directions; A7-4 = 1
  xor a, b ; A = pressed buttons + directions
  ld b, a ; B = pressed buttons + directions

  ; And release the controller
  ld a, P1F_GET_NONE
  ldh [rP1], a

  ; Combine with previous wCurKeys to make wNewKeys
  ld a, [wCurKeys]
  xor a, b ; A = keys that changed state
  and a, b ; A = keys that changed to pressed
  ld [wNewKeys], a
  ld a, b
  ld [wCurKeys], a
  ret

.onenibble
  ldh [rP1], a ; switch the key matrix
  call .knownret ; burn 10 cycles calling a known ret
  ldh a, [rP1] ; ignore value while waiting for the key matrix to settle
  ldh a, [rP1]
  ldh a, [rP1] ; this read counts
  or a, $F0 ; A7-4 = 1; A3-0 = unpressed keys
.knownret
  ret
</code></pre>
<p>Unfortunately, reading input on the Game Boy is fairly involved (as you can see!), and it would be quite difficult to explain what this function does right now.
So, I ask that you make an exception, and trust me that this function <em>does</em> read input.
Alright? Good!</p>
<p>Now that we know how to use functions, let‚Äôs call the <code>UpdateKeys</code> function in our main loop to read user input.
<code>UpdateKeys</code> writes the held buttons to a location in memory that we called <code>wCurKeys</code>, which we can read from after the function returns.
Because of this, we only need to call <code>UpdateKeys</code> once per frame.</p>
<p>This is important, because not only is it faster to reload the inputs that we‚Äôve already processed, but it also means that we will always act on the same inputs, even if the player presses or releases a button mid-frame.</p>
<p>First, let‚Äôs set aside some room for the two variables that <code>UpdateKeys</code> will use; paste this at the end of the <code>main.asm</code>:</p>
<pre><code class="language-rgbasm linenos start=410">SECTION &quot;Input Variables&quot;, WRAM0
wCurKeys: db
wNewKeys: db
</code></pre>
<p>Each variable must reside in RAM, and not ROM, because ROM is ‚ÄúRead-Only‚Äù (so you can‚Äôt modify it).
Additionally, each variable only needs to be one byte large, so we use <code>db</code> (‚ÄúDefine Byte‚Äù) to reserve one byte of RAM for each.</p>
<p>Before we read these variables we will also want to initialize them.
We can do that below our initialization  of <code>wFrameCounter</code>.</p>
<pre><code class="language-rgbasm linenos start=65">	; Initialize global variables
	ld a, 0
	ld [wFrameCounter], a
	ld [wCurKeys], a
	ld [wNewKeys], a
</code></pre>
<p>We‚Äôre going to use the <code>and</code> opcode, which we can use to set the zero flag (<code>z</code>) to the value of the bit.
We can use this along with the <code>PADF</code> constants in hardware.inc to read a particular key.</p>
<pre><code class="language-rgbasm linenos start=71">Main:
	ld a, [rLY]
	cp 144
	jp nc, Main
WaitVBlank2:
	ld a, [rLY]
	cp 144
	jp c, WaitVBlank2

	; Check the current keys every frame and move left or right.
	call UpdateKeys

	; First, check if the left button is pressed.
CheckLeft:
	ld a, [wCurKeys]
	and a, PADF_LEFT
	jp z, CheckRight
Left:
	; Move the paddle one pixel to the left.
	ld a, [_OAMRAM + 1]
	dec a
	; If we've already hit the edge of the playfield, don't move.
	cp a, 15
	jp z, Main
	ld [_OAMRAM + 1], a
	jp Main

; Then check the right button.
CheckRight:
	ld a, [wCurKeys]
	and a, PADF_RIGHT
	jp z, Main
Right:
	; Move the paddle one pixel to the right.
	ld a, [_OAMRAM + 1]
	inc a
	; If we've already hit the edge of the playfield, don't move.
	cp a, 105
	jp z, Main
	ld [_OAMRAM + 1], a
	jp Main
</code></pre>
<p>Now, if you compile the project, you should be able to move the paddle left and right using the d-pad!!
Hooray, we have the beginnings of a game!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collision"><a class="header" href="#collision">Collision</a></h1>
<p>Being able to move around is great, but there‚Äôs still one object we need for this game: a ball!
Just like with the paddle, the first step is to create a tile for the ball and load it into VRAM.</p>
<h2 id="graphics"><a class="header" href="#graphics">Graphics</a></h2>
<p>Add this to the bottom of your file along with the other graphics:</p>
<pre><code class="language-rgbasm linenos start=573">Ball:
	dw `00033000
	dw `00322300
	dw `03222230
	dw `03222230
	dw `00322300
	dw `00033000
	dw `00000000
	dw `00000000
BallEnd:
</code></pre>
<p>Now copy it to VRAM somewhere in your initialization code, e.g. after copying the paddle‚Äôs tile.</p>
<pre><code class="language-rgbasm linenos start=38">	; Copy the ball tile
	ld de, Ball
	ld hl, $8010
	ld bc, BallEnd - Ball
	call Memcopy
</code></pre>
<p>In addition, we need to initialize an entry in OAM, following the code that initializes the paddle.</p>
<pre><code class="language-rgbasm linenos start=52">	; Initialize the paddle sprite in OAM
	ld hl, _OAMRAM
	ld a, 128 + 16
	ld [hli], a
	ld a, 16 + 8
	ld [hli], a
	ld a, 0
	ld [hli], a
	ld [hli], a
	; Now initialize the ball sprite
	ld a, 100 + 16
	ld [hli], a
	ld a, 32 + 8
	ld [hli], a
	ld a, 1
	ld [hli], a
	ld a, 0
	ld [hli], a
</code></pre>
<p>As the ball bounces around the screen its momentum will change, sending it in different directions.
Let‚Äôs create two new variables to track the ball‚Äôs momentum in each axis: <code>wBallMomentumX</code> and <code>wBallMomentumY</code>.</p>
<pre><code class="language-rgbasm linenos start=584">SECTION &quot;Counter&quot;, WRAM0
wFrameCounter: db

SECTION &quot;Input Variables&quot;, WRAM0
wCurKeys: db
wNewKeys: db

SECTION &quot;Ball Data&quot;, WRAM0
wBallMomentumX: db
wBallMomentumY: db
</code></pre>
<p>We will need to initialize these before entering the game loop, so let‚Äôs do so right after we write the ball to OAM.
By setting the X momentum to 1, and the Y momentum to -1, the ball will start out by going up and to the right.</p>
<pre><code class="language-rgbasm linenos start=61">	; Now initialize the ball sprite
	ld a, 100 + 16
	ld [hli], a
	ld a, 32 + 8
	ld [hli], a
	ld a, 1
	ld [hli], a
	ld a, 0
	ld [hli], a

	; The ball starts out going up and to the right
	ld a, 1
	ld [wBallMomentumX], a
	ld a, -1
	ld [wBallMomentumY], a
</code></pre>
<h2 id="prep-work"><a class="header" href="#prep-work">Prep work</a></h2>
<p>Now for the fun part!
Add a bit of code at the beginning of your main loop that adds the momentum to the OAM positions.
Notice that since this is the second OAM entry, we use <code>+ 4</code> for Y and <code>+ 5</code> for X.
This can get pretty confusing, but luckily we only have two objects to keep track of.
In the future, we‚Äôll go over a much easier way to use OAM.</p>
<pre><code class="language-rgbasm linenos start=93">Main:
	ld a, [rLY]
	cp 144
	jp nc, Main
WaitVBlank2:
	ld a, [rLY]
	cp 144
	jp c, WaitVBlank2

	; Add the ball's momentum to its position in OAM.
	ld a, [wBallMomentumX]
	ld b, a
	ld a, [_OAMRAM + 5]
	add a, b
	ld [_OAMRAM + 5], a

	ld a, [wBallMomentumY]
	ld b, a
	ld a, [_OAMRAM + 4]
	add a, b
	ld [_OAMRAM + 4], a
</code></pre>
<p>You might want to compile your game again to see what this does.
If you do, you should see the ball moving around, but it will just go through the walls and then fly offscreen.</p>
<p>To fix this, we need to add collision detection so that the ball can bounce around.
We‚Äôll need to repeat the collision check a few times, so we‚Äôre going to make use of two functions to do this.</p>
<div class="box tip">
<p>Please do not get stuck on the details of this next function, as it uses some techniques and instructions we haven‚Äôt discussed yet.
The basic idea is that it converts the position of the sprite to a location on the tilemap.
This way, we can check which tile our ball is touching so that we know when to bounce!</p>
</div>
<pre><code class="language-rgbasm linenos start=229">; Convert a pixel position to a tilemap address
; hl = $9800 + X + Y * 32
; @param b: X
; @param c: Y
; @return hl: tile address
GetTileByPixel:
	; First, we need to divide by 8 to convert a pixel position to a tile position.
	; After this we want to multiply the Y position by 32.
	; These operations effectively cancel out so we only need to mask the Y value.
	ld a, c
	and a, %11111000
	ld l, a
	ld h, 0
	; Now we have the position * 8 in hl
	add hl, hl ; position * 16
	add hl, hl ; position * 32
	; Convert the X position to an offset.
	ld a, b
	srl a ; a / 2
	srl a ; a / 4
	srl a ; a / 8
	; Add the two offsets together.
	add a, l
	ld l, a
	adc a, h
	sub a, l
	ld h, a
	; Add the offset to the tilemap's base address, and we are done!
	ld bc, $9800
	add hl, bc
	ret
</code></pre>
<p>The next function is called <code>IsWallTile</code>, and it‚Äôs going to contain a list of tiles which the ball can bounce off of.</p>
<pre><code class="language-rgbasm linenos start=261">; @param a: tile ID
; @return z: set if a is a wall.
IsWallTile:
	cp a, $00
	ret z
	cp a, $01
	ret z
	cp a, $02
	ret z
	cp a, $04
	ret z
	cp a, $05
	ret z
	cp a, $06
	ret z
	cp a, $07
	ret
</code></pre>
<p>This function might look a bit strange at first.
Instead of returning its result in a <em>register</em>, like <code>a</code>, it returns it in <a href="part2/../part1/operations.html#flags">a <em>flag</em></a>: <code>Z</code>!
If at any point a tile matches, the function has found a wall and exits with <code>Z</code> set.
If the target tile ID (in <code>a</code>) matches one of the wall tile IDs, the corresponding <code>cp</code> will leave <code>Z</code> set; if so, we return immediately (via <code>ret z</code>), with <code>Z</code> set.
But if we reach the last comparison and it still doesn‚Äôt set <code>Z</code>, then we will know that we haven‚Äôt hit a wall and don‚Äôt need to bounce.</p>
<h2 id="putting-it-together"><a class="header" href="#putting-it-together">Putting it together</a></h2>
<p>Time to use these new functions to add collision detection!
Add the following after the code that updates the ball‚Äôs position:</p>
<pre><code class="language-rgbasm linenos start=115">BounceOnTop:
	; Remember to offset the OAM position!
	; (8, 16) in OAM coordinates is (0, 0) on the screen.
	ld a, [_OAMRAM + 4]
	sub a, 16 + 1
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8
	ld b, a
	call GetTileByPixel ; Returns tile address in hl
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnRight
	ld a, 1
	ld [wBallMomentumY], a
</code></pre>
<p>You‚Äôll see that when we load the sprite‚Äôs positions, we subtract from them before calling <code>GetTileByPixel</code>.
You might remember from the last chapter that OAM positions are slightly offset; that is, (0, 0) in OAM is actually completely offscreen.
These <code>sub</code> instructions undo this offset.</p>
<p>However, there‚Äôs a bit more to this: you might have noticed that we subtracted an extra pixel from the Y position.
That‚Äôs because (as the label suggests), this code is checking for a tile above the ball.
We actually need to check <em>all four</em> sides of the ball so we know how to change the momentum according to which side collided, so‚Ä¶ let‚Äôs add the rest!</p>
<pre><code class="language-rgbasm linenos start=131">BounceOnRight:
	ld a, [_OAMRAM + 4]
	sub a, 16
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8 - 1
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnLeft
	ld a, -1
	ld [wBallMomentumX], a

BounceOnLeft:
	ld a, [_OAMRAM + 4]
	sub a, 16
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8 + 1
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnBottom
	ld a, 1
	ld [wBallMomentumX], a

BounceOnBottom:
	ld a, [_OAMRAM + 4]
	sub a, 16 - 1
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceDone
	ld a, -1
	ld [wBallMomentumY], a
BounceDone:
</code></pre>
<p>That was a lot, but now the ball bounces around your screen!
There‚Äôs just one last thing to do before this chapter is over, and thats ball-to-paddle collision.</p>
<h2 id="paddle-bounce"><a class="header" href="#paddle-bounce">Paddle bounce</a></h2>
<p>Unlike with the tilemap, there‚Äôs no position conversions to do here, just straight comparisons.
However, for these, we will need <a href="part2/../part1/operations.html#flags">the <em>carry</em> flag</a>.
The carry flag is notated as <code>C</code>, like how the zero flag is notated as <code>Z</code>, but don‚Äôt confuse it with the <code>c</code> register!</p>
<div class="box tip"><p class="box-title">A refresher on comparisons</p>
<p>Just like <code>Z</code>, you can use the carry flag to jump conditionally.
However, while <code>Z</code> is used to check if two numbers are equal, <code>C</code> can be used to check if a number is greater than or smaller than another one.
For example, <code>cp a, b</code> sets <code>C</code> if <code>a &lt; b</code>, and clears it if <code>a &gt;= b</code>.
(If you want to check <code>a &lt;= b</code> or <code>a &gt; b</code>, you can use <code>Z</code> and <code>C</code> in tandem with two <code>jp</code> instructions.)</p>
</div>
<p>Armed with this knowledge, let‚Äôs work through the paddle bounce code:</p>
<pre><code class="language-rgbasm linenos start=174">	; First, check if the ball is low enough to bounce off the paddle.
	ld a, [_OAMRAM]
	ld b, a
	ld a, [_OAMRAM + 4]
	cp a, b
	jp nz, PaddleBounceDone ; If the ball isn't at the same Y position as the paddle, it can't bounce.
	; Now let's compare the X positions of the objects to see if they're touching.
	ld a, [_OAMRAM + 5] ; Ball's X position.
	ld b, a
	ld a, [_OAMRAM + 1] ; Paddle's X position.
	sub a, 8
	cp a, b
	jp nc, PaddleBounceDone
	add a, 8 + 16 ; 8 to undo, 16 as the width.
	cp a, b
	jp c, PaddleBounceDone

	ld a, -1
	ld [wBallMomentumY], a

PaddleBounceDone:
</code></pre>
<p>The Y position‚Äôs check is simple, since our paddle is flat.
However, the X position has two checks which widen the area the ball can bounce on.
First we add 16 to the ball‚Äôs position; if the ball is more than 16 pixels to the right of the paddle, it shouldn‚Äôt bounce.
Then we undo this by subtracting 16, and while we‚Äôre at it, subtract another 8 pixels; if the ball is more than 8 pixels to the left of the paddle, it shouldn‚Äôt bounce.</p>
<svg viewBox="-10 -10 860 520">
	<style>
		text { text-anchor: middle; fill: var(--fg); font-size: 20px; }
		.left { text-anchor: start; }
		.right { text-anchor: end; }
		.grid { stroke: var(--fg); opacity: 0.7; }
		.ball { stroke: teal; }
		.paddle { stroke: orange; }
		.excl { stroke: red; } text.excl { stroke: initial; fill: red; font-family: "Source Code Pro", Consolas, "Ubuntu Mono", Menlo, "DejaVu Sans Mono", monospace, monospace !important; }
		/* Overlays */
		rect, polyline { opacity: 0.5; stroke-width: 3; }
		/* Arrow */
		polygon { stroke: inherit; fill: var(--bg); }
		use + line { stroke-dasharray: 0 32 999; stroke-width: 2; }
	</style>
	<defs>
		<polygon id="arrow-head" points="0,0 -40,-16 -32,0 -40,16" stroke="context-stroke"/>
		<pattern id="ball-hatched" viewBox="0 0 4 4" width="8" height="8" patternUnits="userSpaceOnUse">
			<line x1="5" y1="-1" x2="-1" y2="5" class="ball"/>
			<line x1="5" y1="3" x2="3" y2="5" class="ball"/>
			<line x1="1" y1="-1" x2="-1" y2="1" class="ball"/>
		</pattern>
		<pattern id="paddle-hatched" viewBox="0 0 4 4" width="8" height="8" patternUnits="userSpaceOnUse">
			<line x1="5" y1="-1" x2="-1" y2="5" class="paddle"/>
			<line x1="5" y1="3" x2="3" y2="5" class="paddle"/>
			<line x1="1" y1="-1" x2="-1" y2="1" class="paddle"/>
		</pattern>
		<pattern id="excl-hatched" viewBox="0 0 4 4" width="8" height="8" patternUnits="userSpaceOnUse">
			<line x1="5" y1="-1" x2="-1" y2="5" class="excl"/>
			<line x1="5" y1="3" x2="3" y2="5" class="excl"/>
			<line x1="1" y1="-1" x2="-1" y2="1" class="excl"/>
		</pattern>
	</defs>
	<image x="128" y="0" width="256" height="256" href="../assets/part2/img/ball.png"/>
	<rect x="128" y="0" width="32" height="32" fill="url(#ball-hatched)"/>
	<image x="288" y="256" width="256" height="256" href="../assets/part2/img/paddle.png"/>
	<rect x="288" y="256" width="32" height="32" fill="url(#paddle-hatched)"/>
	<line class="grid" x1="-10" y1="0" x2="850" y2="0"/>
	<line class="grid" x1="-10" y1="32" x2="850" y2="32"/>
	<line class="grid" x1="-10" y1="64" x2="850" y2="64"/>
	<line class="grid" x1="-10" y1="96" x2="850" y2="96"/>
	<line class="grid" x1="-10" y1="128" x2="850" y2="128"/>
	<line class="grid" x1="-10" y1="160" x2="850" y2="160"/>
	<line class="grid" x1="-10" y1="192" x2="850" y2="192"/>
	<line class="grid" x1="-10" y1="224" x2="850" y2="224"/>
	<line class="grid" x1="-10" y1="256" x2="850" y2="256"/>
	<line class="grid" x1="-10" y1="288" x2="850" y2="288"/>
	<line class="grid" x1="-10" y1="320" x2="850" y2="320"/>
	<line class="grid" x1="-10" y1="352" x2="850" y2="352"/>
	<line class="grid" x1="0" y1="-20" x2="0" y2="351"/>
	<line class="grid" x1="32" y1="-20" x2="32" y2="351"/>
	<line class="grid" x1="64" y1="-20" x2="64" y2="351"/>
	<line class="grid" x1="96" y1="-20" x2="96" y2="351"/>
	<line class="grid" x1="128" y1="-20" x2="128" y2="351"/>
	<line class="grid" x1="160" y1="-20" x2="160" y2="351"/>
	<line class="grid" x1="192" y1="-20" x2="192" y2="351"/>
	<line class="grid" x1="224" y1="-20" x2="224" y2="351"/>
	<line class="grid" x1="256" y1="-20" x2="256" y2="351"/>
	<line class="grid" x1="288" y1="-20" x2="288" y2="351"/>
	<line class="grid" x1="320" y1="-20" x2="320" y2="351"/>
	<line class="grid" x1="352" y1="-20" x2="352" y2="351"/>
	<line class="grid" x1="384" y1="-20" x2="384" y2="351"/>
	<line class="grid" x1="416" y1="-20" x2="416" y2="351"/>
	<line class="grid" x1="448" y1="-20" x2="448" y2="351"/>
	<line class="grid" x1="480" y1="-20" x2="480" y2="351"/>
	<line class="grid" x1="512" y1="-20" x2="512" y2="351"/>
	<line class="grid" x1="544" y1="-20" x2="544" y2="351"/>
	<line class="grid" x1="576" y1="-20" x2="576" y2="351"/>
	<line class="grid" x1="608" y1="-20" x2="608" y2="351"/>
	<line class="grid" x1="640" y1="-20" x2="640" y2="351"/>
	<line class="grid" x1="672" y1="-20" x2="672" y2="351"/>
	<line class="grid" x1="704" y1="-20" x2="704" y2="351"/>
	<line class="grid" x1="736" y1="-20" x2="736" y2="351"/>
	<line class="grid" x1="768" y1="-20" x2="768" y2="351"/>
	<line class="grid" x1="800" y1="-20" x2="800" y2="351"/>
	<line class="grid" x1="832" y1="-20" x2="832" y2="351"/>
	<rect x="128" y="0" width="256" height="256" class="ball" style="fill: none;"/>
	<polyline points="288,352 288,256 544,256 544,352" class="paddle" style="fill: none;"/>
	<rect x="-15" y="-15" width="47" height="440" class="excl" fill="url(#excl-hatched)"/>
	<text x="40" y="430" class="excl left">jp c, DoNotBounce</text>
	<rect x="800" y="-15" width="52" height="510" class="excl" fill="url(#excl-hatched)"/>
	<text x="790" y="500" class="excl right">jp nc, DoNotBounce</text>
	<use href="#arrow-head" x="48" y="380" transform="rotate(-180,48,380)" class="paddle"/><line x1="48" y1="380" x2="304" y2="380" class="paddle"/>
	<text x="176" y="400">- 8</text>
	<use href="#arrow-head" x="304" y="450" class="paddle"/><line x1="304" y1="450" x2="48" y2="450" class="paddle"/>
	<use href="#arrow-head" x="816" y="450" class="paddle"/><line x1="816" y1="450" x2="304" y2="450" class="paddle"/>
	<text x="432" y="470">+ 8 + 16</text>
</svg>
<div class="box tip"><p class="box-title">Paddle width</p>
<p>You might be wondering why we checked 16 pixels to the right but only 8 pixels to the left.
Remember that OAM positions represent the upper-<em>left</em> corner of a sprite, so the center of our paddle is actually 4 pixels to the right of the position in OAM.
When you consider this, we‚Äôre actually checking 12 pixels out on either side from the center of the paddle.</p>
<p>12 pixels might seem like a lot, but it gives some tolerance to the player in case their positioning is off.
If you‚Äôd prefer to make this easier or more difficult, feel free to adjust the values!</p>
</div>
<h2 id="bonus-tweaking-the-bounce-height"><a class="header" href="#bonus-tweaking-the-bounce-height">BONUS: tweaking the bounce height</a></h2>
<p>You might notice that the ball seems to ‚Äúsink‚Äù into the paddle a bit before bouncing. This is because the ball bounces when its top row of pixels aligns with the paddle‚Äôs top row (see the image above). If you want, try to adjust this so that the ball bounces when its bottom row of pixels touches the paddle‚Äôs top.</p>
<p>Hint: you can do this with just a single instruction!</p>
<details><summary>Answer:</summary>
<pre><code class="language-diff linenos start=174">	ld a, [_OAMRAM]
	ld b, a
	ld a, [_OAMRAM + 4]
+	add a, 6
	cp a, b
</code></pre>
<p>Alternatively, you can add <code>sub a, 6</code> just after <code>ld a, [_OAMRAM]</code>.</p>
<p>In both cases, try playing with that <code>6</code> value; see what feels right!</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bricks"><a class="header" href="#bricks">Bricks</a></h1>
<p>Up until this point our ball hasn‚Äôt done anything but bounce around, but now we‚Äôre going to make it destroy the bricks.</p>
<p>Before we start, let‚Äôs go over a new concept: constants.
We‚Äôve already used some constants, like <code>rLCDC</code> from <code>hardware.inc</code>, but we can also create our own for anything we want.
Let‚Äôs make three constants at the top of our file, representing the tile IDs of left bricks, right bricks, and blank tiles.</p>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;hardware.inc&quot;

DEF BRICK_LEFT EQU $05
DEF BRICK_RIGHT EQU $06
DEF BLANK_TILE EQU $08
</code></pre>
<p>Constants are a kind of <em>symbol</em> (which is to say, ‚Äúa thing with a name‚Äù).
Writing a constant‚Äôs name in an expression is equivalent to writing the number the constant is equal to, so <code>ld a, BRICK_LEFT</code> is the same as <code>ld a, $05</code>.
But I think we can all agree that the former is much clearer, right?</p>
<h2 id="destroying-bricks"><a class="header" href="#destroying-bricks">Destroying bricks</a></h2>
<p>Now we‚Äôll write a function that checks for and destroys bricks.
Our bricks are two tiles wide, so when we hit one we‚Äôll have to remove the adjacent tile as well.
If we hit the left side of a brick (represented by <code>BRICK_LEFT</code>), we need to remove it and the tile to its right (which should be the right side).
If we instead hit the right side, we need to remove the left!</p>
<pre><code class="language-rgbasm linenos start=285">; Checks if a brick was collided with and breaks it if possible.
; @param hl: address of tile.
CheckAndHandleBrick:
	ld a, [hl]
	cp a, BRICK_LEFT
	jr nz, CheckAndHandleBrickRight
	; Break a brick from the left side.
	ld [hl], BLANK_TILE
	inc hl
	ld [hl], BLANK_TILE
CheckAndHandleBrickRight:
	cp a, BRICK_RIGHT
	ret nz
	; Break a brick from the right side.
	ld [hl], BLANK_TILE
	dec hl
	ld [hl], BLANK_TILE
	ret
</code></pre>
<p>Just insert this function into each of your bounce checks now.
Make sure you don‚Äôt miss any!
It should go right <strong>before</strong> the momentum is modified.</p>
<pre><code class="language-diff linenos start=119">BounceOnTop:
	; Remember to offset the OAM position!
	; (8, 16) in OAM coordinates is (0, 0) on the screen.
	ld a, [_OAMRAM + 4]
	sub a, 16 + 1
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8
	ld b, a
	call GetTileByPixel ; Returns tile address in hl
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnRight
+	call CheckAndHandleBrick
	ld a, 1
	ld [wBallMomentumY], a

BounceOnRight:
	ld a, [_OAMRAM + 4]
	sub a, 16
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8 - 1
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnLeft
+	call CheckAndHandleBrick
	ld a, -1
	ld [wBallMomentumX], a

BounceOnLeft:
	ld a, [_OAMRAM + 4]
	sub a, 16
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8 + 1
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnBottom
+	call CheckAndHandleBrick
	ld a, 1
	ld [wBallMomentumX], a

BounceOnBottom:
	ld a, [_OAMRAM + 4]
	sub a, 16 - 1
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceDone
+	call CheckAndHandleBrick
	ld a, -1
	ld [wBallMomentumY], a
BounceDone:
</code></pre>
<p>That‚Äôs it!
Pretty simple, right?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="work-in-progress"><a class="header" href="#work-in-progress">Work in progress</a></h1>
<div class="box warning"><p class="box-title">üöß üöß üöß üöß üöß üöß üöß</p>
<p>As explained in the initial tutorial presentation, Part ‚Ö° consists of us building an <em>Arkanoid</em> game.
However, this is not finished yet; lessons are uploaded as they are made, so the tutorial just abruptly stops at some point.
Sorry!</p>
<p>Please hold tight while we are working on this, <a href="https://twitter.com/gbdev0">follow us on Twitter</a> for updates, and go to the next page to find out what you can do in the meantime!</p>
<p>Thank you for your patience üòä and see you around on GBDev!</p>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="introducing-galactic-armada"><a class="header" href="#introducing-galactic-armada">Introducing Galactic Armada</a></h1>
<img class="pixelated" src="part3/../assets/part3/img/rgbds-shmup-gameplay2.gif">
<p>This guide will help you create a classic shoot-em-up in RGBDS. This guide builds on knowledge from the previous tutorials, so some basic (or previously explained) concepts will not be explained.</p>
<h2 id="feature-set"><a class="header" href="#feature-set">Feature set</a></h2>
<p>Here‚Äôs a list of features that will be included in the final product.</p>
<ul>
<li>Vertical Scrolling Background</li>
<li>Basic HUD (via Window) &amp; Score</li>
<li>4-Directional Player Movement</li>
<li>Enemies</li>
<li>Bullets</li>
<li>Enemy/Bullet Collision</li>
<li>Enemy/Player Collision</li>
<li>Smooth Movement via Scaled Integers - Instead of using counters, smoother motion can be achieved using 16-bit (scaled) integers.</li>
<li>Multiple Game States: Title Screen, Gameplay, Story State</li>
<li>STAT Interrupts - used to properly draw the HUD at the top of gameplay.</li>
<li>RGBGFX &amp; INCBIN</li>
<li>Writing Text</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<p>This page is going to give you an idea of how the Galactic Armada project is structured. This includes the folders, resources, tools, entry point, and compilation process.</p>
<p>The code can be found at https://github.com/gbdev/gb-asm-tutorial/tree/master/galactic-armada.</p>
<h2 id="folder-layout"><a class="header" href="#folder-layout">Folder Layout</a></h2>
<p>For organizational purposes, many parts of the logic are separated into reusable functions. This is to reduce duplicate code, and make logic more clear.</p>
<p>Here‚Äôs a basic look at how the project is structured:</p>
<div class="box tip">
<p>Generated files should never be included in VCS repositories. It unneccessarily bloats the repo. The folders below marked with * contains assets generated from running the Makefile and are not included in the repository.</p>
</div>
<ul>
<li><code>libs</code> - Two assembly files for input and sprites are located here.</li>
<li><code>src</code>
<ul>
<li><code>generated</code> - the results of RGBGFX are stored here. *</li>
<li><code>resources</code> - Here exist some PNGs and Aseprite files for usage with RGBGFX</li>
<li><code>main</code> - All assembly files are located here, or in subfolders
<ul>
<li><code>states</code>
<ul>
<li><code>gameplay</code> - for gameplay related files
<ul>
<li><code>objects</code> - for gameplay objects like the player, bullets, and enemies
<ul>
<li>collision - for collision among objects</li>
</ul>
</li>
</ul>
</li>
<li><code>story</code> - for our story state‚Äôs related files</li>
<li><code>title-screen</code> - for our title screen‚Äôs related files</li>
</ul>
</li>
<li><code>utils</code> - Extra functions includes to assist with development
<ul>
<li><code>macros</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>dist</code> - The final ROM file will be created here. *</li>
<li><code>obj</code> - Intermediate files from the compile process. *</li>
<li><code>Makefile</code> - used to create the final ROM file and intermediate files</li>
</ul>
<h2 id="background--sprite-resources"><a class="header" href="#background--sprite-resources">Background &amp; Sprite Resources</a></h2>
<p>The following backgrounds and sprites are used in Galactic Armada:</p>
<ul>
<li>Backgrounds
<ul>
<li>Star Field</li>
<li>Title Screen</li>
<li>Text Font (Tiles only)</li>
</ul>
</li>
<li>Sprites
<ul>
<li>Enemy Ship</li>
<li>Player Ship</li>
<li>Bullet</li>
</ul>
</li>
</ul>
<img class="pixelated" src="part3/../assets/part3/img/star-field.png">
<img class="pixelated" src="part3/../assets/part3/img/title-screen.png">
<br>
<img class="pixelated" src="part3/../assets/part3/img/text-font.png" height="48px">
<br>
<img class="pixelated sprites" src="part3/../assets/part3/img/player-ship.png" height="48px">
<img class="pixelated sprites" src="part3/../assets/part3/img/enemy-ship.png" height="48px">
<img class="pixelated sprites" src="part3/../assets/part3/img/bullet.png" height="48x">
<p>These images were originally created in Aseprite. The original templates are also included in the repository. They were exported as a PNG <strong>with a specific color palette</strong>. Ater being exported as a PNG, when you run <code>make</code>, they are converted into <code>.2bpp</code> and <code>.tilemap</code> files via the RGBDS tool: RGBGFX.</p>
<blockquote>
<p>The¬†<strong><code>rgbgfx</code></strong>¬†program converts PNG images into data suitable for display on the Game Boy and Game Boy Color, or vice-versa.</p>
<p>The main function of¬†<strong><code>rgbgfx</code></strong>¬†is to divide the input PNG into 8√ó8 pixel¬†<em><a href="https://rgbds.gbdev.io/docs/v0.6.1/rgbgfx.1#squares">squares</a></em>, convert each of those squares into 1bpp or 2bpp tile data, and save all of the tile data in a file. It also has options to generate a tile map, attribute map, and/or palette set as well; more on that and how the conversion process can be tweaked below.</p>
</blockquote>
<p>RGBGFX can be found here: <a href="https://rgbds.gbdev.io/docs/v0.6.1/rgbgfx.1">https://rgbds.gbdev.io/docs/v0.6.1/rgbgfx.1</a></p>
<p>We‚Äôll use it to convert all of our graphics to .2bpp, and .tilemap formats (binary files)</p>
<pre><code class="language-bash linenos start=48">NEEDED_GRAPHICS = \
	$(GENSPRITES)/player-ship.2bpp \
	$(GENSPRITES)/enemy-ship.2bpp \
	$(GENSPRITES)/bullet.2bpp \
	$(GENBACKGROUNDS)/text-font.2bpp \
	$(GENBACKGROUNDS)/star-field.tilemap \
	$(GENBACKGROUNDS)/title-screen.tilemap

# Generate sprites, ensuring the containing directories have been created.
$(GENSPRITES)/%.2bpp: $(RESSPRITES)/%.png | $(GENSPRITES)
	$(GFX) -c &quot;#FFFFFF,#cfcfcf,#686868,#000000;&quot; --columns -o $@ $&lt;

# Generate background tile set, ensuring the containing directories have been created.
$(GENBACKGROUNDS)/%.2bpp: $(RESBACKGROUNDS)/%.png | $(GENBACKGROUNDS)
	$(GFX) -c &quot;#FFFFFF,#cbcbcb,#414141,#000000;&quot; -o $@ $&lt;

# Generate background tile map *and* tile set, ensuring the containing directories
# have been created.
$(GENBACKGROUNDS)/%.tilemap: $(RESBACKGROUNDS)/%.png | $(GENBACKGROUNDS)
	$(GFX) -c &quot;#FFFFFF,#cbcbcb,#414141,#000000;&quot; \
		--tilemap $@ \
		--unique-tiles \
		-o $(GENBACKGROUNDS)/$*.2bpp \
		$&lt;
</code></pre>
<p>From there, INCBIN commands are used to store reference the binary tile data.</p>
<pre><code class="language-rgbasm linenos start=2">
playerShipTileData: INCBIN &quot;src/generated/sprites/player-ship.2bpp&quot;
playerShipTileDataEnd:

enemyShipTileData:: INCBIN &quot;src/generated/sprites/enemy-ship.2bpp&quot;
enemyShipTileDataEnd::

bulletTileData:: INCBIN &quot;src/generated/sprites/bullet.2bpp&quot;
bulletTileDataEnd::

</code></pre>
<div class="box tip"><p class="box-title">Including binary files</p>
<p>You probably have some graphics, level data, etc. you‚Äôd like to include. Use¬†<strong><code>INCBIN</code></strong>¬†to include a raw binary file as it is. If the file isn‚Äôt found in the current directory, the include-path list passed to¬†<a href="https://rgbds.gbdev.io/docs/v0.6.1/rgbasm.1">rgbasm(1)</a>¬†(see the¬†<strong><code>-i</code></strong>¬†option) on the command line will be searched.</p>
<pre><code>INCBIN &quot;titlepic.bin&quot;
INCBIN &quot;sprites/hero.bin&quot;
</code></pre>
<p>You can also include only part of a file with¬†<strong><code>INCBIN</code></strong>. The example below includes 256 bytes from data.bin, starting from byte 78.</p>
<pre><code>INCBIN &quot;data.bin&quot;,78,256
</code></pre>
<p>The length argument is optional. If only the start position is specified, the bytes from the start position until the end of the file will be included.</p>
<p>See also: <a href="https://rgbds.gbdev.io/docs/v0.6.1/rgbasm.5#Including_binary_files">Including binary files - RGBASM documentation</a></p>
</div>
<h2 id="compilation"><a class="header" href="#compilation">Compilation</a></h2>
<p>Compilation is done via a Makefile. This Makefile can be run using the <code>make</code> command. Make should be preinstalled on Linux and Mac systems. For Windows users, check out <a href="https://www.cygwin.com/">cygwin</a>.</p>
<p>Without going over everything in detail, here‚Äôs what the Makefile does:</p>
<ul>
<li>Clean generated folders</li>
<li>Recreate generated folders</li>
<li>Convert PNGs in src/resources to <code>.2bpp</code>, and <code>.tilemap</code> formats</li>
<li>Convert <code>.asm</code> files to <code>.o</code></li>
<li>Use the <code>.o</code> files to build the ROM file</li>
<li>Apply the RGBDS ‚Äúfix‚Äù utility.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="entry-point"><a class="header" href="#entry-point">Entry Point</a></h2>
<p>We‚Äôll start this tutorial out like the previous, with our ‚Äúheader‚Äù section (at address: $100). We‚Äôre also going to declare some global variables that will be used throughout the game.</p>
<ul>
<li><code>wLastKeys</code> and <code>wCurKeys</code> are used for joypad input</li>
<li><code>wGameState</code> will keep track what our current game state is</li>
</ul>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;src/main/utils/hardware.inc&quot;

SECTION &quot;GameVariables&quot;, WRAM0

wLastKeys:: db
wCurKeys:: db
wNewKeys:: db
wGameState::db

SECTION &quot;Header&quot;, ROM0[$100]

	jp EntryPoint

	ds $150 - @, 0 ; Make room for the header

EntryPoint:
</code></pre>
<p>after our <code>EntryPoint</code> label, well do the following:</p>
<ul>
<li>set our default game state</li>
<li>initiate <a href="https://github.com/eievui5/gb-sprobj-lib">gb-sprobj-lib</a>, the sprite library we‚Äôre going to use</li>
<li>setup our display registers</li>
<li>load tile data for our font into VRAM.</li>
</ul>
<p>The tile data we are going to load is used by all game states, which is why we‚Äôll do it here &amp; now, for them all to use.</p>
<img class="pixelated" src="part3/../assets/part3/img/text-font-large.png">
<p>This character-set is called ‚ÄúArea51‚Äù. It, and more 8x8 pixel fonts can ne found here: <a href="https://damieng.com/typography/zx-origins/">https://damieng.com/typography/zx-origins/</a> . These 52 tiles will be placed at the beginning of our background/window VRAM region.</p>
<p><img src="part3/../assets/part3/img/TextFontDiagram.png" alt="TextFontDiagram.png" /></p>
<p>One important thing to note. Character maps for each letter must be defined. This let‚Äôs RGBDS know what byte value to give a specific letter.</p>
<p>For the Galactic Armada space mapping, we‚Äôre going off the ‚Äútext-font.png‚Äù image. Our space character is the first character in VRAM. Our alphabet starts at 26. Special additions could be added if desired. For now, this is all that we‚Äôll need. We‚Äôll define that map in ‚Äúsrc/main/utils/macros/text-macros.inc‚Äù.</p>
<pre><code class="language-rgbasm linenos start=1">; The character map for the text-font 
CHARMAP &quot; &quot;, 0
CHARMAP &quot;.&quot;, 24
CHARMAP &quot;-&quot;, 25
CHARMAP &quot;a&quot;, 26
CHARMAP &quot;b&quot;, 27
CHARMAP &quot;c&quot;, 28
CHARMAP &quot;d&quot;, 29
CHARMAP &quot;e&quot;, 30
CHARMAP &quot;f&quot;, 31
CHARMAP &quot;g&quot;, 32
CHARMAP &quot;h&quot;, 33
CHARMAP &quot;i&quot;, 34
CHARMAP &quot;j&quot;, 35
CHARMAP &quot;k&quot;, 36
CHARMAP &quot;l&quot;, 37
CHARMAP &quot;m&quot;, 38
CHARMAP &quot;n&quot;, 39
CHARMAP &quot;o&quot;, 40
CHARMAP &quot;p&quot;, 41
CHARMAP &quot;q&quot;, 42
CHARMAP &quot;r&quot;, 43
CHARMAP &quot;s&quot;, 44
CHARMAP &quot;t&quot;, 45
CHARMAP &quot;u&quot;, 46
CHARMAP &quot;v&quot;, 47
CHARMAP &quot;w&quot;, 48
CHARMAP &quot;x&quot;, 49
CHARMAP &quot;y&quot;, 50
CHARMAP &quot;z&quot;, 51
</code></pre>
<p>Getting back to our entry point. Were going to wait until a vertical blank begins to do all of this. We‚Äôll also turn the LCD off before loading our tile data into VRAM..</p>
<pre><code class="language-rgbasm linenos start=18">	; Shut down audio circuitry
	ld a, 0
	ld [rNR52], a

	ld a, 0
	ld [wGameState], a

	; Wait for the vertical blank phase before initiating the library
    call WaitForOneVBlank

	; from: https://github.com/eievui5/gb-sprobj-lib
	; The library is relatively simple to get set up. First, put the following in your initialization code:
	; Initilize Sprite Object Library.
	call InitSprObjLibWrapper

	; Turn the LCD off
	ld a, 0
	ld [rLCDC], a

	; Load our common text font into VRAM
	call LoadTextFontIntoVRAM

	; Turn the LCD on
	ld a, LCDCF_ON  | LCDCF_BGON|LCDCF_OBJON | LCDCF_OBJ16 | LCDCF_WINON | LCDCF_WIN9C00
	ld [rLCDC], a

	; During the first (blank) frame, initialize display registers
	ld a, %11100100
	ld [rBGP], a
    ld a, %11100100
	ld [rOBP0], a

</code></pre>
<div class="box tip">
<p>Even though we haven‚Äôt specifically defined a color palette. The <a href="https://emulicious.net/">emulicious</a> emulator may automatically apply a default color palette if in ‚ÄúAutomatic‚Äù or ‚ÄúGameboy Color‚Äù Mode</p>
</div>
<p>In the above snippet you saw use of a function called <code>WaitFOrOneVBLank</code>. We‚Äôve setup some vblank utility functions in the ‚Äúsrc/main/utils/vblank-utils.asm‚Äù file:</p>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;src/main/utils/hardware.inc&quot;

SECTION &quot;VBlankVariables&quot;, WRAM0

wVBlankCount:: db 

SECTION &quot;VBlankFunctions&quot;, ROM0

WaitForOneVBlank::

    ; Wait a small amount of time
    ; Save our count in this variable
    ld a, 1
    ld [wVBlankCount], a

WaitForVBlankFunction::

WaitForVBlankFunction_Loop::

	ld a, [rLY] ; Copy the vertical line to a
	cp 144 ; Check if the vertical line (in a) is 0
	jp c, WaitForVBlankFunction_Loop ; A conditional jump. The condition is that 'c' is set, the last operation overflowed

    ld a, [wVBlankCount]
    sub a, 1
    ld [wVBlankCount], a
    ret z

WaitForVBlankFunction_Loop2::

	ld a, [rLY] ; Copy the vertical line to a
	cp 144 ; Check if the vertical line (in a) is 0
	jp nc, WaitForVBlankFunction_Loop2 ; A conditional jump. The condition is that 'c' is set, the last operation overflowed

    jp WaitForVBlankFunction_Loop

</code></pre>
<p>In the next section, we‚Äôll go on next to setup our <code>NextGameState</code> label. Which is used for changing game states.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changing-game-states"><a class="header" href="#changing-game-states">Changing Game States</a></h1>
<p>In our GalacticArmada.asm file, we‚Äôll define label called ‚ÄúNextGameState‚Äù. Our game will have 3 game states:</p>
<ul>
<li>Title Screen</li>
<li>Story Screen</li>
<li>Gameplay</li>
</ul>
<p>Here is how they will flow:</p>
<p><img src="part3/../assets/part3/img/Game_States_Visualized.png" alt="Game States Visualized.png" /></p>
<p>When one game state wants to go to another, it will need to change our previously declared ‚ÄòwGameState‚Äô variable and then jump to the ‚ÄúNextGameState‚Äù label. There are some common things we want to accomplish when changing game states:</p>
<p>(during a Vertical Blank)</p>
<ul>
<li>Turn off the LCD</li>
<li>Reset our Background &amp; Window positions</li>
<li>Clear the Background</li>
<li>Disable Interrupts</li>
<li>Clear All Sprites</li>
<li>Initiate our NEXT game state</li>
<li>Jump to our NEXT game state‚Äôs (looping) update logic</li>
</ul>
<blockquote>
<p>It will be the responsibility of the ‚Äúinit‚Äù function for each game state to turn the LCD back on.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=50">
NextGameState::

	; Do not turn the LCD off outside of VBlank
    call WaitForOneVBlank

	call ClearBackground;


	; Turn the LCD off
	ld a, 0
	ld [rLCDC], a

	ld a, 0
	ld [rSCX],a
	ld [rSCY],a
	ld [rWX],a
	ld [rWY],a
	; disable interrupts
	call DisableInterrupts
	
	; Clear all sprites
	call ClearAllSprites

	; Initiate the next state
	ld a, [wGameState]
	cp a, 2 ; 2 = Gameplay
	call z, InitGameplayState
	ld a, [wGameState]
	cp a, 1 ; 1 = Story
	call z, InitStoryState
	ld a, [wGameState]
	cp a, 0 ; 0 = Menu
	call z, InitTitleScreenState

	; Update the next state
	ld a, [wGameState]
	cp a, 2 ; 2 = Gameplay
	jp z, UpdateGameplayState
	cp a, 1 ; 1 = Story
	jp z, UpdateStoryState
	jp UpdateTitleScreenState

</code></pre>
<p>The goal here is to ( as much as possible) give each new game state a <em>blank slate</em> to start with.</p>
<p>That‚Äôs it for the GalacticArmada.asm file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="title-screen"><a class="header" href="#title-screen">Title Screen</a></h1>
<p>The title screen shows a basic title image using the background and draws text asking the player to press A. Once the user presses A, it will go to the story screen.</p>
<img src="part3/../assets/part3/img/title-screen-large.png" class="pixelated">
<p>Our title screen has 3 pieces of data:</p>
<ul>
<li>The ‚ÄúPress A to play‚Äù text</li>
<li>The title screen tile data</li>
<li>The title screen tilemap</li>
</ul>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;src/main/utils/hardware.inc&quot;
INCLUDE &quot;src/main/utils/macros/text-macros.inc&quot;

SECTION &quot;TitleScreenState&quot;, ROM0

wPressPlayText::  db &quot;press a to play&quot;, 255
 
titleScreenTileData: INCBIN &quot;src/generated/backgrounds/title-screen.2bpp&quot;
titleScreenTileDataEnd:
 
titleScreenTileMap: INCBIN &quot;src/generated/backgrounds/title-screen.tilemap&quot;
titleScreenTileMapEnd:
</code></pre>
<h2 id="initiating-the-title-screen"><a class="header" href="#initiating-the-title-screen">Initiating the Title Screen</a></h2>
<p>In our title screen‚Äôs ‚ÄúInitTitleScreen‚Äù function, we‚Äôll do the following:</p>
<ul>
<li>draw the title screen graphic</li>
<li>draw our ‚ÄúPress A to play‚Äù</li>
<li>turn on the LCD. </li>
</ul>
<p>Here is what our ‚ÄúInitTitleScreenState‚Äù function looks like</p>
<pre><code class="language-rgbasm linenos start=13">InitTitleScreenState::

	call DrawTitleScreen
	
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Draw the press play text
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Call Our function that draws text onto background/window tiles
    ld de, $99C3
    ld hl, wPressPlayText
    call DrawTextTilesLoop

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Turn the LCD on
	ld a, LCDCF_ON  | LCDCF_BGON|LCDCF_OBJON | LCDCF_OBJ16
	ld [rLCDC], a

    ret;
</code></pre>
<p>In order to draw text in our game, we‚Äôve created a function called ‚ÄúDrawTextTilesLoop‚Äù. We‚Äôll pass this function which tile to start on in <code>de</code>, and the address of our text in <code>hl</code>.</p>
<pre><code class="language-rgbasm linenos start=15">DrawTextTilesLoop::

    ; Check for the end of string character 255
    ld a, [hl]
    cp 255
    ret z

    ; Write the current character (in hl) to the address
    ; on the tilemap (in de)
    ld a, [hl]
    ld [de], a

    inc hl
    inc de

    ; move to the next character and next background tile
    jp DrawTextTilesLoop
</code></pre>
<p>The ‚ÄúDrawTitleScreen‚Äù function puts the tiles for our title screen graphic in VRAM, and draws its tilemap to the background:</p>
<blockquote>
<p><strong>NOTE:</strong> Because of the text font, we‚Äôll add an offset of 52 to our tilemap tiles. We‚Äôve created a function that adds the 52 offset, since we‚Äôll need to do so more than once.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=36">DrawTitleScreen::
	
	; Copy the tile data
	ld de, titleScreenTileData ; de contains the address where data will be copied from;
	ld hl, $9340 ; hl contains the address where data will be copied to;
	ld bc, titleScreenTileDataEnd - titleScreenTileData ; bc contains how many bytes we have to copy.
	call CopyDEintoMemoryAtHL;
	
	; Copy the tilemap
	ld de, titleScreenTileMap
	ld hl, $9800
	ld bc, titleScreenTileMapEnd - titleScreenTileMap
	call CopyDEintoMemoryAtHL_With52Offset

	ret
</code></pre>
<p>The ‚ÄúCopyDEintoMemoryAtHL‚Äù and ‚ÄúCopyDEintoMemoryAtHL_With52Offset‚Äù functions are defined in ‚Äúsrc/main/utils/memory-utils.asm‚Äù:</p>
<pre><code class="language-rgbasm linenos start=1">SECTION &quot;MemoryUtilsSection&quot;, ROM0

CopyDEintoMemoryAtHL::
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyDEintoMemoryAtHL ; Jump to COpyTiles, if the z flag is not set. (the last operation had a non zero result)
	ret;

CopyDEintoMemoryAtHL_With52Offset::
	ld a, [de]
    add a, 52 
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyDEintoMemoryAtHL_With52Offset ; Jump to COpyTiles, if the z flag is not set. (the last operation had a non zero result)
	ret;
</code></pre>
<h2 id="updating-the-title-screen"><a class="header" href="#updating-the-title-screen">Updating the Title Screen</a></h2>
<p>The title screen‚Äôs update logic is the simplest of the 3. All we are going to do is wait until the A button is pressed. Afterwards, we‚Äôll go to the story screen game state.</p>
<pre><code class="language-rgbasm linenos start=52">UpdateTitleScreenState::

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Wait for A
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; Save the passed value into the variable: mWaitKey
    ; The WaitForKeyFunction always checks against this vriable
    ld a,PADF_A
    ld [mWaitKey], a

    call WaitForKeyFunction

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ld a, 1
    ld [wGameState],a
    jp NextGameState
</code></pre>
<p>Our ‚ÄúWaitForKeyFunction‚Äù is defined in ‚Äúsrc/main/utils/input-utils.asm‚Äù. We‚Äôll poll for input and infinitely loop until the specified button is pressed down.</p>
<pre><code class="language-rgbasm linenos start=1">SECTION &quot;InputUtilsVariables&quot;, WRAM0

mWaitKey:: db

SECTION &quot;InputUtils&quot;, ROM0

WaitForKeyFunction::

    ; Save our original value
    push bc

	
WaitForKeyFunction_Loop:

	; save the keys last frame
	ld a, [wCurKeys]
	ld [wLastKeys], a
    
	; This is in input.asm
	; It's straight from: https://gbdev.io/gb-asm-tutorial/part2/input.html
	; In their words (paraphrased): reading player input for gameboy is NOT a trivial task
	; So it's best to use some tested code
    call Input

    
	ld a, [mWaitKey]
    ld b,a
	ld a, [wCurKeys]
    and a, b
    jp z,WaitForKeyFunction_NotPressed
    
	ld a, [wLastKeys]
    and a, b
    jp nz,WaitForKeyFunction_NotPressed

	; restore our original value
	pop bc

    ret


WaitForKeyFunction_NotPressed:

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Wait a small amount of time
    ; Save our count in this variable
    ld a, 1
    ld [wVBlankCount], a

    ; Call our function that performs the code
    call WaitForVBlankFunction
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    jp WaitForKeyFunction_Loop
</code></pre>
<p>That‚Äôs it for our title screen. Next up is our story screen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="story-screen"><a class="header" href="#story-screen">Story Screen</a></h1>
<p>The story screen shows a basic story on 2 pages. Afterwards, it sends the player to the gameplay game state.</p>
<img src="part3/../assets/part3/img/GalacticArmada-1.png" class="pixelated" height="288px">
<img src="part3/../assets/part3/img/GalacticArmada-2.png" class="pixelated" height="288px">
<h2 id="initiating-up-the-story-screen"><a class="header" href="#initiating-up-the-story-screen">Initiating up the Story Screen</a></h2>
<p>In the <code>InitStoryState</code> we‚Äôll just going to turn on the LCD. Most of the game state‚Äôs logic will occur in its update function.</p>
<div class="box tip">
<p>The text macros file is included so our story text has the proper character maps.</p>
</div>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;src/main/utils/hardware.inc&quot;
INCLUDE &quot;src/main/utils/macros/text-macros.inc&quot;

SECTION &quot;StoryStateASM&quot;, ROM0

InitStoryState::

	; Turn the LCD on
	ld a, LCDCF_ON  | LCDCF_BGON|LCDCF_OBJON | LCDCF_OBJ16
	ld [rLCDC], a

    ret;
</code></pre>
<h2 id="updating-the-story-screen"><a class="header" href="#updating-the-story-screen">Updating the Story Screen</a></h2>
<p>Here‚Äôs the data for our story screen. We have this defined just above our <code>UpdateStoryState</code> function:</p>
<pre><code class="language-rgbasm linenos start=14">Story: 
    .Line1 db &quot;the galatic empire&quot;, 255
    .Line2 db &quot;rules the galaxy&quot;, 255
    .Line3 db &quot;with an iron&quot;, 255
    .Line4 db &quot;fist.&quot;, 255
    .Line5 db &quot;the rebel force&quot;, 255
    .Line6 db &quot;remain hopeful of&quot;, 255
    .Line7 db &quot;freedoms light&quot;, 255
	
</code></pre>
<p>The story text is shown using a typewriter effect. This effect is done similarly to the ‚Äúpress a to play‚Äù text that was done before, but here we wait for 3 vertical blank phases between writing each letter, giving some additional delay.</p>
<blockquote>
<p>You could bind this to a variable and make it configurable via an options screen too!</p>
</blockquote>
<p>For this effect, we‚Äôve defined a function in our ‚Äúsrc/main/utils/text-utils.asm‚Äù file:</p>
<pre><code class="language-rgbasm linenos start=33">DrawText_WithTypewriterEffect::

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Wait a small amount of time
    ; Save our count in this variable
    ld a, 3
    ld [wVBlankCount], a

    ; Call our function that performs the code
    call WaitForVBlankFunction
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    
    ; Check for the end of string character 255
    ld a, [hl]
    cp 255
    ret z

    ; Write the current character (in hl) to the address
    ; on the tilemap (in de)
    ld a, [hl]
    ld [de], a

    ; move to the next character and next background tile
    inc hl
    inc de

    jp DrawText_WithTypewriterEffect
</code></pre>
<p>We‚Äôll call the <code>DrawText_WithTypewriterEffect</code> function exactly how we called the <code>DrawTextTilesLoop</code> function. We‚Äôll pass this function which tile to start on in de, and the address of our text in hl.</p>
<p>We‚Äôll do that four times for the first page, and then wait for the A button to be pressed:</p>
<pre><code class="language-rgbasm linenos start=23">UpdateStoryState::

    ; Call Our function that typewrites text onto background/window tiles
    ld de, $9821
    ld hl, Story.Line1
    call DrawText_WithTypewriterEffect


    ; Call Our function that typewrites text onto background/window tiles
    ld de, $9861
    ld hl, Story.Line2
    call DrawText_WithTypewriterEffect


    ; Call Our function that typewrites text onto background/window tiles
    ld de, $98A1
    ld hl, Story.Line3
    call DrawText_WithTypewriterEffect


    ; Call Our function that typewrites text onto background/window tiles
    ld de, $98E1
    ld hl, Story.Line4
    call DrawText_WithTypewriterEffect

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Wait for A
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; Save the passed value into the variable: mWaitKey
    ; The WaitForKeyFunction always checks against this vriable
    ld a,PADF_A
    ld [mWaitKey], a

    call WaitForKeyFunction
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

</code></pre>
<p>Once the user presses the A button, we want to show the second page. To avoid any lingering ‚Äúleftover‚Äù letters, we‚Äôll clear the background. All this function does is turn off the LCD, fill our background tilemap with the first tile, then turn back on the lcd. We‚Äôve defined this function in the ‚Äúsrc/main/utils/background.utils.asm‚Äù file:</p>
<pre><code class="language-rgbasm linenos start=1">include &quot;src/main/utils/hardware.inc&quot;

SECTION &quot;Background&quot;, ROM0

ClearBackground::

	; Turn the LCD off
	ld a, 0
	ld [rLCDC], a

	ld bc,1024
	ld hl, $9800

ClearBackgroundLoop:

	ld a,0
	ld [hli], a

	
	dec bc
	ld a, b
	or a, c

	jp nz, ClearBackgroundLoop


	; Turn the LCD on
	ld a, LCDCF_ON  | LCDCF_BGON|LCDCF_OBJON | LCDCF_OBJ16
	ld [rLCDC], a


	ret
</code></pre>
<p>Getting back to our Story Screen: After we‚Äôve shown the first page and cleared the background, we‚Äôll do the same thing for page 2:</p>
<pre><code class="language-rgbasm linenos start=65">    ; Call Our function that typewrites text onto background/window tiles
    ld de, $9821
    ld hl, Story.Line5
    call DrawText_WithTypewriterEffect


    ; Call Our function that typewrites text onto background/window tiles
    ld de, $9861
    ld hl, Story.Line6
    call DrawText_WithTypewriterEffect


    ; Call Our function that typewrites text onto background/window tiles
    ld de, $98A1
    ld hl, Story.Line7
    call DrawText_WithTypewriterEffect


    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Wait for A
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; Save the passed value into the variable: mWaitKey
    ; The WaitForKeyFunction always checks against this vriable
    ld a,PADF_A
    ld [mWaitKey], a

    call WaitForKeyFunction
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    
</code></pre>
<p>With our story full shown, we‚Äôre ready to move onto the next game state: Gameplay. We‚Äôll end our <code>UpdateStoryState</code> function by updating our game state variable and jump back to the <code>NextGameState</code> label like previously discussed.</p>
<pre><code class="language-rgbasm linenos start=98">    ld a, 2
    ld [wGameState],a
    jp NextGameState
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gameplay-state"><a class="header" href="#gameplay-state">Gameplay State</a></h1>
<p>In this game state, the player will control a spaceship. Flying over a vertically scrolling space background. They‚Äôll be able to freely move in 4 directions , and shoot oncoming alien ships. As alien ships are destroyed by bullets, the player‚Äôs score will increase.</p>
<p><img src="part3/../assets/part3/img/rgbds-shmup-gameplay.gif" alt="rgbds-shmup-gameplay.gif" /></p>
<p>Gameplay is the core chunk of the source code. It also took the most time to create. Because of such, this game state has to be split into multiple sub-pages. Each page will explain a different gameplay concept.</p>
<p>Our gameplay state defines the following data and variables:</p>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;src/main/utils/hardware.inc&quot;
INCLUDE &quot;src/main/utils/macros/text-macros.inc&quot;

SECTION &quot;GameplayVariables&quot;, WRAM0

wScore:: ds 6
wLives:: db

SECTION &quot;GameplayState&quot;, ROM0

wScoreText::  db &quot;score&quot;, 255
wLivesText::  db &quot;lives&quot;, 255
</code></pre>
<p>For simplicity reasons, our score uses 6 bytes. Each byte repesents one digit in the score.</p>
<h2 id="initiating-the-gameplay-game-state"><a class="header" href="#initiating-the-gameplay-game-state">Initiating the Gameplay Game State:</a></h2>
<p>When gameplay starts we want to do all of the following:</p>
<ul>
<li>reset the player‚Äôs score to 0</li>
<li>reset the player‚Äôs lives to 3. </li>
<li>Initialize all of our gameplay elements ( background, player, bullets, and enemies)</li>
<li>Enable STAT interrupts for the HUD</li>
<li>Draw our ‚Äúscore‚Äù &amp; ‚Äúlives‚Äù  on the HUD.</li>
<li>Reset the window‚Äôs position back to 7,0</li>
<li>Turn the LCD on with the window enabled at $9C00</li>
</ul>
<pre><code class="language-rgbasm linenos start=14">InitGameplayState::

	ld a, 3
	ld [wLives+0], a

	ld a, 0
	ld [wScore+0], a
	ld [wScore+1], a
	ld [wScore+2], a
	ld [wScore+3], a
	ld [wScore+4], a
	ld [wScore+5], a

	call InitializeBackground
	call InitializePlayer
	call InitializeBullets
	call InitializeEnemies

	; Initiate STAT interrupts
	call InitStatInterrupts

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Call Our function that draws text onto background/window tiles
    ld de, $9c00
    ld hl, wScoreText
    call DrawTextTilesLoop

	; Call Our function that draws text onto background/window tiles
    ld de, $9c0D
    ld hl, wLivesText
    call DrawTextTilesLoop
	
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	call DrawScore
	call DrawLives

	ld a, 0
	ld [rWY], a

	ld a, 7
	ld [rWX], a

	; Turn the LCD on
	ld a, LCDCF_ON  | LCDCF_BGON|LCDCF_OBJON | LCDCF_OBJ16 | LCDCF_WINON | LCDCF_WIN9C00|LCDCF_BG9800
	ld [rLCDC], a

    ret;
</code></pre>
<p>The initialization logic for our the background, the player, the enemies, the bullets will be explained in later pages. Every game state is responsible for turning the LCD back on. The gameplay game state needs to use the window layer, so we‚Äôll make sure that‚Äôs enabled before we return.</p>
<h2 id="updating-the-gameplay-game-state"><a class="header" href="#updating-the-gameplay-game-state">Updating the Gameplay Game State</a></h2>
<p>Our ‚ÄúUpdateGameplayState‚Äù function doesn‚Äôt have very complicated logic. Most of the logic has been split into separate files for the background, player, enemies, and bullets.</p>
<p>During gameplay, we do all of the following:</p>
<ul>
<li>Poll for input</li>
<li>Reset our Shadow OAM</li>
<li>Reset our current shadow OAM sprite</li>
<li>Update our gameplay elements (player, background, enemies, bullets, background)</li>
<li>Remove any unused sprites from the screen</li>
<li>End gameplay if we‚Äôve lost all of our lives</li>
<li>inside of the vertical blank phase
<ul>
<li>Apply shadow OAM sprites </li>
<li>Update our background tilemap‚Äôs position</li>
</ul>
</li>
</ul>
<p>We‚Äôll poll for input like in the previous tutorial. We‚Äôll always save the previous state of the gameboy‚Äôs buttons in the ‚ÄúwLastKeys‚Äù variable.</p>
<pre><code class="language-rgbasm linenos start=66">UpdateGameplayState::

	; save the keys last frame
	ld a, [wCurKeys]
	ld [wLastKeys], a

	; This is in input.asm
	; It's straight from: https://gbdev.io/gb-asm-tutorial/part2/input.html
	; In their words (paraphrased): reading player input for gameboy is NOT a trivial task
	; So it's best to use some tested code
    call Input
</code></pre>
<p>Next, we‚Äôll reset our Shadow OAM and reset current Shadow OAM sprite address. </p>
<pre><code class="language-rgbasm linenos start=78">	; from: https://github.com/eievui5/gb-sprobj-lib
	; hen put a call to ResetShadowOAM at the beginning of your main loop.
	call ResetShadowOAM
	call ResetOAMSpriteAddress
</code></pre>
<p>Because we are going to be dealing with a lot of sprites on the screen, we will not be directly manipulating the gameboy‚Äôs OAM sprites. We‚Äôll define a set of ‚Äúshadow‚Äù (copy‚Äú) OAM sprites, that all objects will use instaed. At the end of the gameplay looop, we‚Äôll copy the shadow OAM sprite objects into the hardware.</p>
<p>Each object will use a random shadow OAM sprite. We need a way to keep track of what shadow OAM sprite is being used currently. For this, we‚Äôve created a 16-bit pointer called ‚ÄúwLastOAMAddress‚Äù. Defined in ‚Äúsrc/main/utils/sprites.asm‚Äù, this points to the data for the next inactive shadow OAM sprite. </p>
<p>When we reset our current Shadow OAM sprite address, we just set the ‚ÄúmLastOAMAddress‚Äù RAM variable to point to the first shadow OAM sprite. </p>
<blockquote>
<p><strong>NOTE:</strong> We also keep a counter on how many shadow OAM sprites are used. In our ‚ÄúResetOAMSpriteAddress‚Äù function, we‚Äôll reset that counter too.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=64">ResetOAMSpriteAddress::
    
    ld a, 0
    ld [wSpritesUsed], a

	ld a, LOW(wShadowOAM)
	ld [wLastOAMAddress+0], a
	ld a, HIGH(wShadowOAM)
	ld [wLastOAMAddress+1], a

    ret
</code></pre>
<p>Next we‚Äôll update our gameplay elements:</p>
<pre><code class="language-rgbasm linenos start=83">	call UpdatePlayer
	call UpdateEnemies
	call UpdateBullets
	call UpdateBackground
</code></pre>
<p>After all of that, at this point in time, the majority of gameplay is done for this iteration. We‚Äôll clear any remaining spirtes. This is very necessary becaus the number of active sprites changes from frame to frame. If there are any visible OAM sprites left onscreen, they will look weird and/or mislead the player. </p>
<pre><code class="language-rgbasm linenos start=88">	; Clear remaining sprites to avoid lingering rogue sprites
	call ClearRemainingSprites
</code></pre>
<p>The clear remaining sprites function, for all remaining shadow OAM sprites, moves the sprite offscreen so they are no longer visible. This function starts at wherever the ‚ÄúwLastOAMAddress‚Äù variable last left-off.</p>
<h4 id="end-of-the-gameplay-loop"><a class="header" href="#end-of-the-gameplay-loop">End of The Gameplay loop</a></h4>
<p>At this point in time, we need to check if gameplay needs to continue. When the vertical blank phase starts, we check if the player has lost all of their lives. If so, we end gameplay. We end gameplay similar to how we started it, we‚Äôll update our ‚ÄòwGameState‚Äô variable and jump to ‚ÄúNextGameState‚Äù.</p>
<p>If the player hasn‚Äôt lost all of their lives, we‚Äôll copy our shadow OAM sprites over to the actual hardware OAM sprites and loop background.</p>
<pre><code class="language-rgbasm linenos start=91">	ld a, [wLives]
	cp a, 250
	jp nc, EndGameplay

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Call our function that performs the code
    call WaitForOneVBlank
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; from: https://github.com/eievui5/gb-sprobj-lib
	; Finally, run the following code during VBlank:
	ld a, HIGH(wShadowOAM)
	call hOAMDMA

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Call our function that performs the code
    call WaitForOneVBlank
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
	jp UpdateGameplayState

EndGameplay:
	
    ld a, 0
    ld [wGameState],a
    jp NextGameState
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scrolling-background"><a class="header" href="#scrolling-background">Scrolling Background</a></h1>
<p>Scrolling the background is an easy task. However, for a SMOOTH slow scrolling background: scaled integers<sup class="footnote-reference"><a href="#1">1</a></sup> will be used.</p>
<blockquote>
<p>‚ö†Ô∏è Scaled Integers<sup class="footnote-reference"><a href="#1">1</a></sup> are a way to provide smooth ‚Äúsub-pixel‚Äù movement. They are slightly more difficult to understand &amp; implement than implementing a counter, but they provide smoother motion.</p>
</blockquote>
<h2 id="initializing-the-background"><a class="header" href="#initializing-the-background">Initializing the Background</a></h2>
<p>At the start of the gameplay game state we called the initialize background function. This function shows the star field background, and resets our background scroll variables:</p>
<blockquote>
<p>Just like with our title screen graphic, because our text font tiles are at the beginning of VRAM: we offset the tilemap values by 52</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;src/main/utils/hardware.inc&quot;
INCLUDE &quot;src/main/utils/macros/text-macros.inc&quot;

SECTION &quot;BackgroundVariables&quot;, WRAM0

mBackgroundScroll:: dw

SECTION &quot;GameplayBackgroundSection&quot;, ROM0

starFieldMap: INCBIN &quot;src/generated/backgrounds/star-field.tilemap&quot;
starFieldMapEnd:
 
starFieldTileData: INCBIN &quot;src/generated/backgrounds/star-field.2bpp&quot;
starFieldTileDataEnd:

InitializeBackground::

	; Copy the tile data
	ld de, starFieldTileData ; de contains the address where data will be copied from;
	ld hl, $9340 ; hl contains the address where data will be copied to;
	ld bc, starFieldTileDataEnd - starFieldTileData ; bc contains how many bytes we have to copy.
    call CopyDEintoMemoryAtHL

	; Copy the tilemap
	ld de, starFieldMap
	ld hl, $9800
	ld bc, starFieldMapEnd - starFieldMap
    call CopyDEintoMemoryAtHL_With52Offset

	ld a, 0
	ld [mBackgroundScroll+0],a
	ld a, 0
	ld [mBackgroundScroll+1],a

	ret
</code></pre>
<p>To scroll the background in a gameboy game, we simply need to gradually change the <code>SCX</code> or <code>SCX</code> registers. Our code is a tiny bit more complicated because of scaled integer usage. Our background‚Äôs scroll position is stored in a 16-bit integer called <code>mBackgroundScroll</code>. We‚Äôl increase that 16-bit integer by a set amount.</p>
<pre><code class="language-rgbasm linenos start=37">; This is called during gameplay state on every frame
UpdateBackground::

	; Increase our scaled integer by 5
	; Get our true (non-scaled) value, and save it for later usage in bc
	ld a , [mBackgroundScroll+0]
	add a , 5
    ld b,a
	ld [mBackgroundScroll+0], a
	ld a , [mBackgroundScroll+1]
	adc a , 0
    ld c,a
	ld [mBackgroundScroll+1], a
</code></pre>
<p>We won‚Äôt directly draw the background using this value. De-scaling a scaled integer simulates having a (more precise and useful for smooth movement) floating-point number. The value we draw our background at will be the de-scaled version of that 16-bit integer. To get that non-scaled version, we‚Äôll simply shift all of it‚Äôs bit rightward 4 places. The final result will saved for when we update our background‚Äôs y position.</p>
<pre><code class="language-rgbasm linenos start=51">    ; Descale our scaled integer 
    ; shift bits to the right 4 spaces
    srl c
    rr b
    srl c
    rr b
    srl c
    rr b
    srl c
    rr b

    ; Use the de-scaled low byte as the backgrounds position
    ld a,b
	ld [rSCY], a

	ret
</code></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/Scale_factor_(computer_science)">Scaled Factor on Wikipedia</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heads-up-interface"><a class="header" href="#heads-up-interface">Heads Up Interface</a></h1>
<p>The gameboy normally draws sprites over both the window and background, and the window over the background. In Galactic Armada, The background is vertically scrolling. This means the HUD (the score text and number) needs to be draw on the window, which is separate from the background. </p>
<p>On our HUD, we‚Äôll draw both our score and our lives. We‚Äôll also use STAT interrupts to make sure nothing covers the HUD.</p>
<h2 id="stat-interrupts--the-window"><a class="header" href="#stat-interrupts--the-window">STAT Interrupts &amp; the window</a></h2>
<p>The window is not enabled by default. We can enable the window using the <code>LCDC</code> register. RGBDS comes with constants that will help us. </p>
<blockquote>
<p>‚ö†Ô∏è NOTE: The window can essentially be a copy of the background. The <code>LCDCF_WIN9C00|LCDCF_BG9800</code> portion makes the background and window use different tilemaps when drawn.
There‚Äôs only one problem. Since the window is drawn between sprites and the background. Without any extra effort, our scrolling background tilemap will be covered by our window. In addition, our sprites will be drawn over our hud. For this, we‚Äôll need STAT interrupts. Fore more information on STAT interrupts, check out the pandocs: <a href="https://gbdev.io/pandocs/Interrupt_Sources.html">https://gbdev.io/pandocs/Interrupt_Sources.html</a></p>
</blockquote>
<p><img src="part3/../assets/part3/img/StatInterruptsVisualized.png" alt="InterruptsDiagram.png" /></p>
<blockquote>
<h3 id="using-the-stat-interrupt"><a class="header" href="#using-the-stat-interrupt"><strong><a href="https://gbdev.io/pandocs/Interrupt_Sources.html#using-the-stat-interrupt">Using the STAT interrupt</a></strong></a></h3>
<p>One very popular use is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to¬†<a href="https://github.com/gb-archive/DeadCScroll">perform special video effects</a>.</p>
<p>Example application: set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.</p>
</blockquote>
<p>With STAT interrupts, we can implement raster effects. in our case, we‚Äôll enable the window and stop drawing sprites on the first 8 scanlines. Afterwards, we‚Äôll show sprites and disable the window layer for the remaining scanlines. This makes sure nothing overlaps our HUD, and that our background is fully shown also.</p>
<h3 id="initiating--disabling-stat-interrupts"><a class="header" href="#initiating--disabling-stat-interrupts">Initiating &amp; Disabling STAT interrupts</a></h3>
<p>In our gameplay game state, at different points in time, we initialized and disabled interrupts. Here‚Äôs the logic for those functions in our ‚Äúsrc/main/states/gameplay/hud.asm‚Äù file:</p>
<pre><code class="language-rgbasm linenos start=2">INCLUDE &quot;src/main/utils/hardware.inc&quot;

 SECTION &quot;Interrupts&quot;, ROM0

 DisableInterrupts::
	ld a, 0
	ldh [rSTAT], a
	di
	ret

InitStatInterrupts::

    ld a, IEF_STAT
	ldh [rIE], a
	xor a, a ; This is equivalent to `ld a, 0`!
	ldh [rIF], a
	ei

	; This makes our stat interrupts occur when the current scanline is equal to the rLYC register
	ld a, STATF_LYC
	ldh [rSTAT], a

	; We'll start with the first scanline
	; The first stat interrupt will call the next time rLY = 0
	ld a, 0
	ldh [rLYC], a

    ret
</code></pre>
<h3 id="defining-stat-interrupts"><a class="header" href="#defining-stat-interrupts">Defining STAT interrupts</a></h3>
<p>Our actual STAT interrupts must be located at $0048. We‚Äôll define different paths depending on what our LYC variable‚Äôs value is when executed.</p>
<pre><code class="language-rgbasm linenos start=31">; Define a new section and hard-code it to be at $0048.
SECTION &quot;Stat Interrupt&quot;, ROM0[$0048]
StatInterrupt:

	push af

	; Check if we are on the first scanline
	ldh a, [rLYC]
	cp 0
	jp z, LYCEqualsZero

LYCEquals8:

	; Don't call the next stat interrupt until scanline 8
	ld a, 0
	ldh [rLYC], a

	; Turn the LCD on including sprites. But no window
	ld a, LCDCF_ON | LCDCF_BGON | LCDCF_OBJON | LCDCF_OBJ16 | LCDCF_WINOFF | LCDCF_WIN9C00
	ldh [rLCDC], a

	jp EndStatInterrupts

LYCEqualsZero:

	; Don't call the next stat interrupt until scanline 8
	ld a, 8
	ldh [rLYC], a

	; Turn the LCD on including the window. But no sprites
	ld a, LCDCF_ON | LCDCF_BGON | LCDCF_OBJOFF | LCDCF_OBJ16| LCDCF_WINON | LCDCF_WIN9C00
	ldh [rLCDC], a


EndStatInterrupts:

	pop af

	reti;
</code></pre>
<p>That should be all it takes to get a properly drawn HUD. For more details, check out the code in the repo or <a href="https://gbdev.io/gb-asm-tutorial/help-feedback.html">ask questions</a> on the gbdev discord server.</p>
<h2 id="keeping-score-and-drawing-score-on-the-hud"><a class="header" href="#keeping-score-and-drawing-score-on-the-hud">Keeping Score and Drawing Score on the HUD</a></h2>
<p>To keep things simple, back in our gameplay game state, we used 6 different bytes to hold our score.Each byte will hold a value between 0 and 9, and represents a specific digit in the score. So it‚Äôs easy to loop through and edit the score number on the HUD: The First byte represents the left-most digit, and the last byte represents the right-most digit. </p>
<p><img src="part3/../assets/part3/img/DrawingScoreVisualized.png" alt="DrawingScoreVisualized.png" /></p>
<p>When the score increases, we‚Äôll increase digits on the right. As they go higher than 9, we‚Äôll reset back to 0 and increase the previous byte .</p>
<pre><code class="language-rgbasm linenos start=6">IncreaseScore::

    ; We have 6 digits, start with the right-most digit (the last byte)
    ld c, 0
    ld hl, wScore+5

IncreaseScore_Loop:

    ; Increase the digit 
    ld a, [hl]
    inc a
    ld [hl], a

    ; Stop if it hasn't gone past 0
    cp a, 9
    ret c

; If it HAS gone past 9
IncreaseScore_Next:

    ; Increase a counter so we can not go out of our scores bounds
    ld a, c
    inc a 
    ld c, a

    ; Check if we've gone our o our scores bounds
    cp a, 6
    ret z

    ; Reset the current digit to zero
    ; Then go to the previous byte (visually: to the left)
    ld a, 0
    ld [hl], a
    ld [hld], a

    jp IncreaseScore_Loop
</code></pre>
<p>We can call that score whenever a bullet hits an enemy. This function however does not draw our score on the background. We do that the same way we drew text previously:</p>
<pre><code class="language-rgbasm linenos start=55">DrawScore::

    ; Our score has max 6 digits
    ; We'll start with the left-most digit (visually) which is also the first byte
    ld c, 6
    ld hl, wScore
    ld de, $9C06 ; The window tilemap starts at $9C00

DrawScore_Loop:

    ld a, [hli]
    add a, 10 ; our numeric tiles start at tile 10, so add to 10 to each bytes value
    ld [de], a

    ; Decrease how many numbers we have drawn
    ld a, c
    dec a
    ld c, a
		
    ; Stop when we've drawn all the numbers
    ret z

    ; Increase which tile we are drawing to
    inc de

    jp DrawScore_Loop
</code></pre>
<p>Because we‚Äôll only ever have 3 lives, drawing our lives is much easier. The numeric characters in our text font start at 10, so  we just need to put on the window, our lives plus 10.</p>
<pre><code class="language-rgbasm linenos start=44">DrawLives::

    ld hl, wLives
    ld de, $9C13 ; The window tilemap starts at $9C00

    ld a, [hl]
    add a, 10 ; our numeric tiles start at tile 10, so add to 10 to each bytes value
    ld [de], a

    ret
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprites--metasprites"><a class="header" href="#sprites--metasprites">Sprites &amp; Metasprites</a></h1>
<p>Before we dive into the player, bullets, and enemies; how they are drawn using metasprites should be explained.</p>
<p>For sprites, the following library is used:  https://github.com/eievui5/gb-sprobj-lib</p>
<blockquote>
<p>This is a small, lightweight library meant to facilitate the rendering of sprite objects, including Shadow OAM and OAM DMA, single-entry ‚Äúsimple‚Äù sprite objects, and Q12.4 fixed-point position metasprite rendering.</p>
</blockquote>
<p>All objects are drawn using ‚Äúmetasprites‚Äù, or groups of sprites that define one single object. A custom ‚Äúmetasprite‚Äù implementation is used in addition. Metasprite definitions should a multiple of 4 plus one additional byte for the end.</p>
<ul>
<li>Relative Y offset ( relative to the previous sprite, or the actual metasprite‚Äôs draw position)</li>
<li>Relative X offset ( relative to the previous sprite, or the actual metasprite‚Äôs draw position)</li>
<li>Tile to draw</li>
<li>Tile Props (not used in this project)</li>
</ul>
<p>The logic stops drawing when it reads 128. </p>
<p>An example of metasprite is the enemy ship:</p>
<pre><code class="language-rgbasm linenos start=501">
enemyShipMetasprite::
    .metasprite1    db 0,0,4,0
    .metasprite2    db 0,8,6,0
    .metaspriteEnd  db 128

</code></pre>
<p><img src="part3/../assets/part3/img/MetaspriteDIagram.png" alt="MetaspriteDIagram.png" /></p>
<p>The Previous snippet draws two sprites. One that the object‚Äôs actual position, which uses tile 4 and 5. The second sprite is 8 pixels to the right, and uses tile 6 and 7</p>
<blockquote>
<p>‚ö†Ô∏è <strong>NOTE</strong>: Sprites are in 8x16 mode for this project.</p>
</blockquote>
<p>I can later draw such metasprite by calling the ‚ÄúDrawMetasprite‚Äù function that</p>
<pre><code class="language-rgbasm linenos start=509">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; call the 'DrawMetasprites function. 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Save the x position
ld a, b
ld [wMetaspriteX],a

; Save the y position
ld a, c
ld [wMetaspriteY],a

; Actually call the 'DrawMetasprites function
call DrawMetasprites;
</code></pre>
<p>We previously mentioned a variable called ‚ÄúwLastOAMAddress‚Äù. The ‚ÄúDrawMetasprites‚Äù function can be found in the ‚Äúsrc/main/utils/metasprites.asm‚Äù file:</p>
<pre><code class="language-rgbasm linenos start=1">
include &quot;src/main/utils/constants.inc&quot;
SECTION &quot;MetaSpriteVariables&quot;, WRAM0

wMetaspriteAddress:: dw
wMetaspriteX:: db
wMetaspriteY::db

SECTION &quot;MetaSprites&quot;, ROM0

DrawMetasprites::


    ; get the metasprite address
    ld a, [wMetaspriteAddress+0]
    ld l, a
    ld a, [wMetaspriteAddress+1]
    ld h, a

    ; Get the y position
    ld a, [hli]
    ld b, a

    ; stop if the y position is 128 
    ld a, b
    cp 128
    ret z

    ld a, [wMetaspriteY]
    add a, b
    ld [wMetaspriteY],a

    ; Get the x position
    ld a, [hli]
    ld c, a

    ld a, [wMetaspriteX]
    add a,c
    ld [wMetaspriteX],a

    ; Get the tile position
    ld a, [hli]
    ld d, a

    ; Get the flag position
    ld a, [hli]
    ld e, a
    

    ;Get our offset address in hl
	ld a,[wLastOAMAddress+0]
    ld l, a
	ld a, HIGH(wShadowOAM)
    ld h, a

    ld a, [wMetaspriteY]
    ld [hli], a

    ld a, [wMetaspriteX]
    ld [hli], a

    ld a, d
    ld [hli], a

    ld a, e
    ld [hli], a

    call NextOAMSprite

     ; increase the wMetaspriteAddress
    ld a, [wMetaspriteAddress+0]
    add a, METASPRITE_BYTES_COUNT
    ld  [wMetaspriteAddress+0], a
    ld a, [wMetaspriteAddress+1]
    adc a, 0
    ld  [wMetaspriteAddress+1], a


    jp DrawMetasprites
</code></pre>
<p>When we call the ‚ÄúDrawMetasprites‚Äù function, the ‚ÄúwLastOAMAddress‚Äù variable will be advanced  to point at the next available shadow OAM sprite. This is done using the ‚ÄúNextOAMSprite‚Äù function in ‚Äúsrc/main/utils/sprites-utils.asm‚Äù</p>
<pre><code class="language-rgbasm linenos start=76">NextOAMSprite::

    ld a, [wSpritesUsed]
    inc a
    ld [wSpritesUsed], a

	ld a,[wLastOAMAddress+0]
    add a, sizeof_OAM_ATTRS
	ld [wLastOAMAddress+0], a
	ld a, HIGH(wShadowOAM)
	ld [wLastOAMAddress+1], a


    ret
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-pools"><a class="header" href="#object-pools">Object Pools</a></h1>
<p>Galactic Armada will use ‚Äúobject pools‚Äù for bullets and enemies. A fixed amount of bytes representing a specific maximum amount of objects. Each pool is just a collection of bytes. The number of bytes per ‚Äúpool‚Äù is the maximum number of objects in the pool, times the number of bytes needed for data for each object.</p>
<p>Constants are also created for the size of each object, and what each byte is. These constants are in the ‚Äúsrc/main/utils/constants.inc‚Äù file and utilize RGBDS offset constants (a really cool feature)</p>
<pre><code class="language-rgbasm linenos start=528">
; from https://rgbds.gbdev.io/docs/v0.6.1/rgbasm.5#EXPRESSIONS
; The RS group of commands is a handy way of defining structure offsets:
RSRESET
DEF bullet_activeByte            RB   1
DEF bullet_xByte                 RB   1
DEF bullet_yLowByte              RB   1
DEF bullet_yHighByte             RB   1
DEF PER_BULLET_BYTES_COUNT       RB   0


</code></pre>
<p>The two object types that we need to loop through are Enemies and Bullets.</p>
<p><strong>Bytes for an Enemy:</strong></p>
<ol>
<li>Active - Are they active</li>
<li>X - Position: horizontal coordinate</li>
<li>Y (low) - The lower byte of their 16-bit (scaled) y position</li>
<li>Y (high) - The higher byte of their 16-bit (scaled) y position</li>
<li>Speed - How fast they move</li>
<li>Health - How many bullets they can take</li>
</ol>
<pre><code class="language-rgbasm linenos start=540">
; Bytes: active, x , y (low), y (high), speed, health
wEnemies:: ds MAX_ENEMY_COUNT*PER_ENEMY_BYTES_COUNT

</code></pre>
<p><img src="part3/../assets/part3/img/EnemyBytesVisualized.png" alt="EnemyBytesVisualized.png" /></p>
<p><strong>Bytes for a Bullet:</strong></p>
<ol>
<li>Active - Are they active</li>
<li>X - Position: horizontal coordinate</li>
<li>Y (low) - The lower byte of their 16-bit (scaled) y position</li>
<li>Y (high) - The higher byte of their 16-bit (scaled) y position</li>
</ol>
<pre><code class="language-rgbasm linenos start=523">
; Bytes: active, x , y (low), y (high)
wBullets:: ds MAX_BULLET_COUNT*PER_BULLET_BYTES_COUNT

</code></pre>
<p><img src="part3/../assets/part3/img/BulletBytesVisualized.png" alt="BulletBytesVisualized.png" /></p>
<blockquote>
<p>‚ö†Ô∏è <strong>NOTE:</strong> Scaled integers are used for only the y positions of bullets and enemies. Scaled Integers are a way to provide smooth ‚Äúsub-pixel‚Äù movement. They only move vertically, so the x position can be 8-bit.</p>
</blockquote>
<p>When looping through an object pool, we‚Äôll check if an object is active. If it‚Äôs active, we‚Äôll run the logic for that object. Otherwise, we‚Äôll skip to the start of the next object‚Äôs bytes. </p>
<p>Both bullets and enemies do similar things. They move vertically until they are off the screen. In addition, enemies will check against bullets when updating. If they are found to be colliding, the bullet is destroyed and so is the enemy.</p>
<h1 id="activating-a-pooled-object"><a class="header" href="#activating-a-pooled-object">‚ÄúActivating‚Äù a pooled object</a></h1>
<p>To Activate a pooled object, we simply loop through each object. If the first byte, which tells us if it‚Äôs active or not, is 0: then we‚Äôll add the new item at that location and set that byte to be 1. If we loop through all possible objects and nothing is inactive, nothing happens.</p>
<p><img src="part3/../assets/part3/img/Spawning_Enemies.png" alt="Spawning Enemies.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-player"><a class="header" href="#the-player">The Player</a></h1>
<p>The player‚Äôs logic is pretty simple. The player can move in 4 directions and fire bullets. We update the player by checking our input directions and the A button. We‚Äôll move in the proper direction if its associated d-pad button is pressed. If the A button is pressed, we‚Äôll spawn a new bullet at the player‚Äôs position.</p>
<p>Our player will have 3 variables:</p>
<ul>
<li>wePlayerPositionX - a 16-bit scaled integer</li>
<li>wePlayerPositionY - a 16-bit scaled integer</li>
<li>wPlayerFlash - a 16-bit integer used when the player gets damaged</li>
</ul>
<blockquote>
<p>‚ö†Ô∏è <strong>NOTE</strong>: The player can move vertically AND horizontally. So, unlike bullets and enemies, it‚Äôs x position is a 16-bit scaled integer.</p>
</blockquote>
<p>These are declared at the top of the ‚Äúsrc/main/states/gameplay/objects/player.asm‚Äù file</p>
<pre><code class="language-rgbasm linenos start=1">include &quot;src/main/utils/hardware.inc&quot;
include &quot;src/main/utils/hardware.inc&quot;
include &quot;src/main/utils/constants.inc&quot;

SECTION &quot;PlayerVariables&quot;, WRAM0

; first byte is low, second is high (little endian)
wPlayerPositionX:: dw
wPlayerPositionY:: dw

mPlayerFlash: dw
</code></pre>
<p>Well draw our player, a simple ship, using the previously discussed metasprites implementation. Here is what we have for the players metasprites and tile data:</p>
<pre><code class="language-rgbasm linenos start=12">SECTION &quot;Player&quot;, ROM0

playerShipTileData: INCBIN &quot;src/generated/sprites/player-ship.2bpp&quot;
playerShipTileDataEnd:

playerTestMetaSprite::
    .metasprite1    db 0,0,0,0
    .metasprite2    db 0,8,2,0
    .metaspriteEnd  db 128
</code></pre>
<h2 id="initializing-the-player"><a class="header" href="#initializing-the-player">Initializing the Player</a></h2>
<p>Initializing the player is pretty simple. Here‚Äôs a list of things we need to do:</p>
<ul>
<li>Reset oir wPlayerFlash variable</li>
<li>Reset our wPlayerPositionX variable</li>
<li>Reset our wPlayerPositionU variable</li>
<li>Copy the player‚Äôs ship into VRAM</li>
</ul>
<p>We‚Äôll use a constant we declared in ‚Äúsrc/main/utils/constants.inc‚Äù to copy the player ship‚Äôs tile data into VRAM. Our enemy ship and player ship both have 4 tiles (16 bytes for each tile). In the snippet below, we can define where we‚Äôll place the tile data in VRAM relative to the _VRAM constant:</p>
<pre><code class="language-rgbasm linenos start=37">RSRESET
DEF spriteTilesStart            RB _VRAM
DEF PLAYER_TILES_START          RB 4*16
DEF ENEMY_TILES_START           RB 4*16
DEF BULLET_TILES_START          RB 0
</code></pre>
<p>Here‚Äôs what our ‚ÄúInitializePlayer‚Äù function looks like. Recall, this was called when initiating the gameplay game state:</p>
<pre><code class="language-rgbasm linenos start=22">InitializePlayer::

    ld a, 0
    ld [mPlayerFlash+0],a
    ld [mPlayerFlash+1],a

    ; Place in the middle of the screen
    ld a, 0
    ld [wPlayerPositionX+0], a
    ld [wPlayerPositionY+0], a

    ld a, 5
    ld [wPlayerPositionX+1], a
    ld [wPlayerPositionY+1], a

    
CopyPlayerTileDataIntoVRAM:
    ; Copy the player's tile data into VRAM
	ld de, playerShipTileData
	ld hl, PLAYER_TILES_START
	ld bc, playerShipTileDataEnd - playerShipTileData
    call CopyDEintoMemoryAtHL

    ret;
</code></pre>
<h2 id="updating-the-player"><a class="header" href="#updating-the-player">Updating the Player</a></h2>
<p>We can break our player‚Äôs update logic into 2 parts:</p>
<ul>
<li>Check for joypad input,  move with the d-pad, shoot with A</li>
<li>Depending on our ‚ÄúwPlayerFlash‚Äù variable: Draw our metasprites at our location</li>
</ul>
<p>Checking the joypad is done like the previous tutorials, we‚Äôll perform bitwise ‚Äúand‚Äù operations with constants for each d-pad direction.</p>
<pre><code class="language-rgbasm linenos start=47">UpdatePlayer::

UpdatePlayer_HandleInput:

	ld a, [wCurKeys]
	and a, PADF_UP
	call nz, MoveUp

	ld a, [wCurKeys]
	and a, PADF_DOWN
	call nz, MoveDown

	ld a, [wCurKeys]
	and a, PADF_LEFT
	call nz, MoveLeft

	ld a, [wCurKeys]
	and a, PADF_RIGHT
	call nz, MoveRight

	ld a, [wCurKeys]
	and a, PADF_A
	call nz, TryShoot
</code></pre>
<p>For player movement, our X &amp; Y are 16-bit integers. These both require two bytes. There is a little endian ordering, the first byte will be the low byte. The second byte will be the high byte. To increase/decrease these values, we add/subtract our change amount to/from the low byte. Then afterwards, we add/subtract the remainder of that operation to/from the high byte.</p>
<pre><code class="language-rgbasm linenos start=213">MoveUp:

    ; decrease the player's y position
    ld a, [wPlayerPositionY+0]
    sub a, PLAYER_MOVE_SPEED
    ld [wPlayerPositionY+0], a

    ld a, [wPlayerPositionY+1]
    sbc a, 0
    ld [wPlayerPositionY+1], a

    ret

MoveDown:

    ; increase the player's y position
    ld a, [wPlayerPositionY+0]
    add a, PLAYER_MOVE_SPEED
    ld [wPlayerPositionY+0], a

    ld a, [wPlayerPositionY+1]
    adc a, 0
    ld [wPlayerPositionY+1], a

    ret

MoveLeft:

    ; decrease the player's x position
    ld a, [wPlayerPositionX+0]
    sub a, PLAYER_MOVE_SPEED
    ld [wPlayerPositionX+0], a

    ld a, [wPlayerPositionX+1]
    sbc a, 0
    ld [wPlayerPositionX+1], a
    ret

MoveRight:

    ; increase the player's x position
    ld a, [wPlayerPositionX+0]
    add a, PLAYER_MOVE_SPEED
    ld [wPlayerPositionX+0], a

    ld a, [wPlayerPositionX+1]
    adc a, 0
    ld [wPlayerPositionX+1], a

    ret
</code></pre>
<p>When the player wants to shoot, we first check if the A button previously was down. If it was, we won‚Äôt shoot a new bullet. This avoids bullet spamming a little. For spawning bullets, we have a function called ‚ÄúFireNextBullet‚Äù. This function will need the new bullet‚Äôs 8-bit X coordinate and 16-bit Y coordinate, both set in a variable it uses called ‚ÄúwNextBullet‚Äù</p>
<pre><code class="language-rgbasm linenos start=189">TryShoot:
	ld a, [wLastKeys]
	and a, PADF_A
    ret nz

    call FireNextBullet;

    ret
</code></pre>
<p>After we‚Äôve potentially moved the player and/or shot a new bullet. We need to draw our player. However, to create the ‚Äúflashing‚Äù effect when damaged, we‚Äôll conditionally NOT draw our player sprite. We do this based on the ‚ÄúwPlayerFlash‚Äù variable.</p>
<ul>
<li>If the ‚ÄúwPlayerFlash‚Äù variable is 0, the player is not damaged, we‚Äôll skip to drawing our player sprite.</li>
<li>Otherwise, decrease the ‚ÄúwPlayerFlash‚Äù variable by 5.
<ul>
<li>We‚Äôll shift all the bits of the ‚ÄúwPlayerFlash‚Äù variable to the right 4 times</li>
<li>If the result is less than 5, we‚Äôll stop flashing and draw our player metasprite.</li>
<li>Otherwise, if the first bit of the decscaled ‚ÄúwPlayerFLash‚Äù variable is 1, we‚Äôll skip drawing the player.</li>
</ul>
</li>
</ul>
<blockquote>
<p>*<strong>NOTE:</strong> The following resumes from where the ‚ÄúUpdatePlayer_HandleInput‚Äù label ended above.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=72">    ld a, [mPlayerFlash+0]
    ld b, a

    ld a, [mPlayerFlash+1]
    ld c, a

UpdatePlayer_UpdateSprite_CheckFlashing:

    ld a, b
    or a, c
    jp z, UpdatePlayer_UpdateSprite

    ; decrease bc by 5
    ld a, b
    sub a, 5
    ld b, a
    ld a, c
    sbc a, 0
    ld c, a
    

UpdatePlayer_UpdateSprite_DecreaseFlashing:

    ld a, b
    ld [mPlayerFlash+0], a
    ld a, c
    ld [mPlayerFlash+1], a

    ; descale bc
    srl c
    rr b
    srl c
    rr b
    srl c
    rr b
    srl c
    rr b

    ld a, b
    cp a, 5
    jp c, UpdatePlayer_UpdateSprite_StopFlashing


    bit 0, b
    jp z, UpdatePlayer_UpdateSprite

UpdatePlayer_UpdateSprite_Flashing:

    ret;
UpdatePlayer_UpdateSprite_StopFlashing:

    ld a, 0
    ld [mPlayerFlash+0],a
    ld [mPlayerFlash+1],a
</code></pre>
<p>If we get past all of the ‚ÄúwPlayerFlash‚Äù logic, we‚Äôll draw our player using the ‚ÄúDrawMetasprite‚Äù function we previously discussed.</p>
<pre><code class="language-rgbasm linenos start=127">UpdatePlayer_UpdateSprite:

    ; Get the unscaled player x position in b
    ld a, [wPlayerPositionX+0]
    ld b, a
    ld a, [wPlayerPositionX+1]
    ld d, a
    
    srl d
    rr b
    srl d
    rr b
    srl d
    rr b
    srl d
    rr b

    ; Get the unscaled player y position in c
    ld a, [wPlayerPositionY+0]
    ld c, a
    ld a, [wPlayerPositionY+1]
    ld e, a

    srl e
    rr c
    srl e
    rr c
    srl e
    rr c
    srl e
    rr c
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Drawing the palyer metasprite
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


    ; Save the address of the metasprite into the 'wMetaspriteAddress' variable
    ; Our DrawMetasprites functoin uses that variable
    ld a, LOW(playerTestMetaSprite)
    ld [wMetaspriteAddress+0], a
    ld a, HIGH(playerTestMetaSprite)
    ld [wMetaspriteAddress+1], a


    ; Save the x position
    ld a, b
    ld [wMetaspriteX],a

    ; Save the y position
    ld a, c
    ld [wMetaspriteY],a

    ; Actually call the 'DrawMetasprites function
    call DrawMetasprites;

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ret
</code></pre>
<p>That‚Äôs the end our our ‚ÄúUpdatePlayer‚Äù function. The final bit of code for our player handles when they are damaged. When an enemy damages the player, we want to decrease our lives by one. We‚Äôll also start flashing  by giving our ‚ÄòmPlayerFlash‚Äô variable a non-zero value. In the gameplay game state, if we‚Äôve lost all lives, gameplay will end.</p>
<pre><code class="language-rgbasm linenos start=198">DamagePlayer::

    

    ld a, 0
    ld [mPlayerFlash+0], a
    ld a, 1
    ld [mPlayerFlash+1], a

    ld a, [wLives]
    dec a
    ld [wLives], a

    ret
</code></pre>
<p>That‚Äôs everything for our player. Next, we‚Äôll go over bullets and then onto the enemies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bullets"><a class="header" href="#bullets">Bullets</a></h1>
<p>Bullets are relatively simple, logic-wise. They all travel straight-forward, and de-activate themselves when they leave the screen.</p>
<p>At the top of our ‚Äúsrc/main/states/gameplay/objects/bullets.asm‚Äù file we‚Äôll setup some variables for bullets and include our tile data.</p>
<pre><code class="language-rgbasm linenos start=2">include &quot;src/main/utils/hardware.inc&quot;
include &quot;src/main/utils/constants.inc&quot;

SECTION &quot;BulletVariables&quot;, WRAM0

wSpawnBullet:db

; how many bullets are currently active
wActiveBulletCounter:: db

; how many bullet's we've updated
wUpdateBulletsCounter:db 

; Bytes: active, x , y (low), y (high)
wBullets:: ds MAX_BULLET_COUNT*PER_BULLET_BYTES_COUNT

SECTION &quot;Bullets&quot;, ROM0

bulletMetasprite::
    .metasprite1    db 0,0,8,0
    .metaspriteEnd  db 128

bulletTileData:: INCBIN &quot;src/generated/sprites/bullet.2bpp&quot;
bulletTileDataEnd::


</code></pre>
<p>We‚Äôll need to loop through the bullet object pool in the following sections. </p>
<h2 id="initiating-bullets"><a class="header" href="#initiating-bullets">Initiating Bullets</a></h2>
<p>In our ‚ÄúInitializeBullets‚Äù function, we‚Äôll copy the tile data for the bullet sprites into VRAM, and set every bullet as inactive. Each bullet is 4 bytes, the first byte signaling if the bullet is active or not. </p>
<p><img src="part3/../assets/part3/img/BulletBytesVisualized.png" alt="BulletBytesVisualized.png" /></p>
<p>We‚Äôll iterate through bullet object pool, named ‚ÄúwBullets‚Äù, and activate the first of the the four bytes. Then skipping the next 3 bytes, to go onto the next bullet. We‚Äôll do this until we‚Äôve looped for each bullet in our pool.</p>
<pre><code class="language-rgbasm linenos start=29">InitializeBullets::

    ld a, 0
    ld [wSpawnBullet], a

    ; Copy the bullet tile data intto vram
	ld de, bulletTileData
	ld hl, BULLET_TILES_START
	ld bc, bulletTileDataEnd - bulletTileData
    call CopyDEintoMemoryAtHL

    ; Reset how many bullets are active to 0
    ld a,0
    ld [wActiveBulletCounter],a

    ld b, 0
    ld hl, wBullets

InitializeBullets_Loop:

    ld a, 0
    ld [hl], a

    ; Increase the address
    ld a, l
    add a, PER_BULLET_BYTES_COUNT
    ld l, a
    ld a, h
    adc a, 0
    ld h, a

    ; Increase how many bullets we have initailized
    ld a, b
    inc a
    ld b ,a

    cp a, MAX_BULLET_COUNT
    ret z

    jp InitializeBullets_Loop
</code></pre>
<h2 id="updating-bullets"><a class="header" href="#updating-bullets">Updating Bullets</a></h2>
<p>When we want to update each of bullets, first we should check if any bullets are active. If no bullets are active we can stop early.</p>
<pre><code class="language-rgbasm linenos start=70">UpdateBullets::

    ; Make sure we have SOME active enemies
    ld a, [wSpawnBullet]
    ld b, a
    ld a, [wActiveBulletCounter]
    or a,b
    cp a, 0
    ret z
    
    ; Reset our counter for how many bullets we have checked
    ld a, 0
    ld [wUpdateBulletsCounter], a

    ; Get the address of the first bullet in hl
    ld a, LOW(wBullets)
    ld l,  a
    ld a, HIGH(wBullets)
    ld h, a

    jp UpdateBullets_PerBullet
</code></pre>
<p>If we have active bullets, we‚Äôll reset how many bullets we‚Äôve checked and set our ‚Äúhl‚Äù registers to point to the first bullets address. </p>
<p>When were updating each bullet, we‚Äôll check each byte, changing hl (the byte we want to read) as we go. At the start, ‚Äúhl‚Äù should point to the first byte. ‚Äúhl‚Äù should point to the first byte at the end too:</p>
<blockquote>
<p>HL should point to the first byte at the end so we can easily do one of two things:</p>
<ul>
<li>deactivate the bullet</li>
<li>jump to the next bullet (by simply adding 4 to hl)</li>
</ul>
</blockquote>
<p>For we each bullet, we‚Äôll do the following:</p>
<ul>
<li>Check if active</li>
<li>Get our x position, save into b</li>
<li>Get our y scaled positon, save into c (low byte), and d (high byte)</li>
<li>Decrease our y position to move the bullet upwards</li>
<li>Reset HL to the first byte of our bullet</li>
<li>Descale the y position we have in c &amp; d, and jump to our deactivation code if c (the low byte) is high enough</li>
<li>Draw our bullet metasprit, if it wasn‚Äôt previously deactivated</li>
</ul>
<pre><code class="language-rgbasm linenos start=113">UpdateBullets_PerBullet:

    ; The first byte is if the bullet is active
    ; If it's NOT  zero, it's active, go to the normal update section
    ld a, [hl]
    cp a, 0
    jp nz, UpdateBullets_PerBullet_Normal

    ; Do we need to spawn a bullet?
    ; If we dont, loop to the next enemy
    ld a, [wSpawnBullet]
    cp a, 0
    jp z, UpdateBullets_Loop
    
UpdateBullets_PerBullet_SpawnDeactivatedBullet:

    ; reset this variable so we don't spawn anymore
    ld a, 0
    ld [wSpawnBullet], a
    
    ; Increase how many bullets are active
    ld a,[wActiveBulletCounter]
    inc a
    ld [wActiveBulletCounter], a

    push hl

    ; Set the current bullet as  active
    ld a, 1
    ld [hli], a

    ; Get the unscaled player x position in b
    ld a, [wPlayerPositionX+0]
    ld b, a
    ld a, [wPlayerPositionX+1]
    ld d, a
    
    ; Descale the player's x position
    ; the result will only be in the low byt
    srl d
    rr b
    srl d
    rr b
    srl d
    rr b
    srl d
    rr b
    
    ; Set the x position to equal the player's x position
    ld a, b
    ld [hli], a

    ; Set the y position (low)
    ld a, [wPlayerPositionY+0]
    ld [hli], a

    ;Set the y position (high)
    ld a, [wPlayerPositionY+1]
    ld [hli], a

    pop hl

UpdateBullets_PerBullet_Normal:

    ; Save our active byte
    push hl

    inc hl

    ; Get our x position
    ld a, [hli]
    ld b, a

    ; get our 16-bit y position
    ld a, [hl]
    sub a, BULLET_MOVE_SPEED
    ld [hli], a
    ld c, a
    ld a, [hl] 
    sbc a, 0
    ld [hl], a
    ld d, a

    pop hl; go to the active byte

    ; Descale our y position
    srl d
    rr c
    srl d
    rr c
    srl d
    rr c
    srl d
    rr c

    ; See if our non scaled low byte is above 160
    ld a, c
    cp a, 178
    ; If it below 160, continue on  to deactivate
    jp nc, UpdateBullets_DeActivateIfOutOfBounds
    
</code></pre>
<h3 id="drawing-the-bullets"><a class="header" href="#drawing-the-bullets">Drawing the Bullets</a></h3>
<p>We‚Äôll draw our bullet metasprite like we drew the player, using our ‚ÄúDrawMetasprites‚Äù function. This function may alter the ‚Äòh‚Äô or ‚Äòl‚Äô registers, so we‚Äôll push the hl register onto the stack before hand. After drawing, we‚Äôll pop the hl register off of the stack to restore it‚Äôs value.</p>
<pre><code class="language-rgbasm linenos start=214">
    push hl

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Drawing a metasprite
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     ; Save the address of the metasprite into the 'wMetaspriteAddress' variable
    ; Our DrawMetasprites functoin uses that variable
    ld a, LOW(bulletMetasprite)
    ld [wMetaspriteAddress+0], a
    ld a, HIGH(bulletMetasprite)
    ld [wMetaspriteAddress+1], a

    ; Save the x position
    ld a, b
    ld [wMetaspriteX],a

    ; Save the y position
    ld a, c
    ld [wMetaspriteY],a

    ; Actually call the 'DrawMetasprites function
    call DrawMetasprites;
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    

    pop hl
    
    jp UpdateBullets_Loop
</code></pre>
<h3 id="deactivating-the-bullets"><a class="header" href="#deactivating-the-bullets">Deactivating the Bullets</a></h3>
<p>If a bullet needs to be deactivated, we simply set it‚Äôs first byte to 0. At this point in time, the ‚Äúhl‚Äù registers should point at our bullets first byte. This makes deactivation a really simple task. In addition to changing the first byte, we‚Äôll decrease how many bullets we have that are active.</p>
<pre><code class="language-rgbasm linenos start=246">UpdateBullets_DeActivateIfOutOfBounds:

    ; if it's y value is grater than 160
    ; Set as inactive
    ld a, 0
    ld [hl], a

    ; Decrease counter
    ld a,[wActiveBulletCounter]
    dec a
    ld [wActiveBulletCounter], a

    jp UpdateBullets_Loop
</code></pre>
<h3 id="updating-the-next-bullet"><a class="header" href="#updating-the-next-bullet">Updating the next bullet</a></h3>
<p>After we‚Äôve updated a single bullet, we‚Äôll increase how many bullet‚Äôs we‚Äôve updated. If we‚Äôve updated all the bullets, we can stop our ‚ÄúUpdateBullets‚Äù function. Otherwise, we‚Äôll add 4 bytes to the addressed stored in ‚Äúhl‚Äù, and update the next bullet.</p>
<pre><code class="language-rgbasm linenos start=92">UpdateBullets_Loop:

    ; Check our counter, if it's zero
    ; Stop the function
    ld a, [wUpdateBulletsCounter]
    inc a
    ld [wUpdateBulletsCounter], a

    ; Check if we've already
    ld a, [wUpdateBulletsCounter]
    cp a, MAX_BULLET_COUNT
    ret nc

    ; Increase the bullet data our address is pointingtwo
    ld a, l
    add a, PER_BULLET_BYTES_COUNT
    ld l, a
    ld a, h
    adc a, 0
    ld h, a
</code></pre>
<h2 id="firing-new-bullets"><a class="header" href="#firing-new-bullets">Firing New Bullets</a></h2>
<p>During the ‚ÄúUpdatePlayer‚Äù function previously, when use pressed A we called the ‚ÄúFireNextBullet‚Äù function.</p>
<p>This function will loop through each bullet in the bullet object pool. When it finds an inactive bullet, it will activate it and set it‚Äôs position equal to the players.</p>
<blockquote>
<p>Our bullets only use one 8-bit integer for their x position, so need to de-scale the player‚Äôs 16-bit scaled x position</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=260">FireNextBullet::

    ; Make sure we don't have the max amount of enmies
    ld a, [wActiveBulletCounter]
    cp a, MAX_BULLET_COUNT
    ret nc

    ; Set our spawn bullet variable to true
    ld a, 1
    ld [wSpawnBullet], a

    ret
</code></pre>
<p>That‚Äôs it for bullets logic. Next we‚Äôll cover enemies, and after that we‚Äôll step back into the world of bullets with ‚ÄúBullet vs Enemy‚Äù Collision.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enemies"><a class="header" href="#enemies">Enemies</a></h1>
<p>Enemies in SHMUPS often come in a variety of types, and travel also in a variety of patterns. To keep things simple for this tutorial, we‚Äôll have one enemy that flys straight downward. Because of this decision, the logic for enemies is going to be similar to bullets in a way. They both travel vertically and disappear when off screeen. Some differences to point out are:</p>
<ul>
<li>Enemies are not spawned by the player, so we need logic that spawns them at random times and locations.</li>
<li>Enemies must check for collision against the player</li>
<li>We‚Äôll check for collision against bullets in the enemy update function.</li>
</ul>
<p>Here are the RAM variables we‚Äôll use for our enemies:</p>
<ul>
<li>wCurrentEnemyX &amp; wCurrentEnemyY - When we check for collisions, we‚Äôll save the current enemy‚Äôs position in these two variables.</li>
<li>wNextEnemyXPosition - When this variable has a non-zero value, we‚Äôll spawn a new enemy at that position</li>
<li>wSpawnCounter - We‚Äôll decrease this, when it reaches zero we‚Äôll spawn a new enemy (by setting ‚ÄòwNextEnemyXPosition‚Äô to a non-zero value).</li>
<li>wActiveEnemyCounter - This tracks how many enemies we have on screen</li>
<li>wUpdateEnemiesCounter - This is used when updating enemies so we know how many we have updated.</li>
<li>wUpdateEnemiesCurrentEnemyAddress - When we check for enemy v. bullet collision, we‚Äôll save the address of our current enemy here.</li>
</ul>
<pre><code class="language-rgbasm linenos start=1">include &quot;src/main/utils/hardware.inc&quot;
include &quot;src/main/utils/constants.inc&quot;

SECTION &quot;EnemyVariables&quot;, WRAM0

wCurrentEnemyX:: db  
wCurrentEnemyY:: db  

wSpawnCounter: db  
wNextEnemyXPosition: db
wActiveEnemyCounter::db
wUpdateEnemiesCounter:db
wUpdateEnemiesCurrentEnemyAddress::dw

; Bytes: active, x , y (low), y (high), speed, health
wEnemies:: ds MAX_ENEMY_COUNT*PER_ENEMY_BYTES_COUNT

</code></pre>
<p>Just like with bullets, we‚Äôll setup ROM data for our enemies tile data and metasprites.</p>
<pre><code class="language-rgbasm linenos start=18">SECTION &quot;Enemies&quot;, ROM0

enemyShipTileData:: INCBIN &quot;src/generated/sprites/enemy-ship.2bpp&quot;
enemyShipTileDataEnd::

enemyShipMetasprite::
    .metasprite1    db 0,0,4,0
    .metasprite2    db 0,8,6,0
    .metaspriteEnd  db 128
</code></pre>
<h2 id="initializing-enemies"><a class="header" href="#initializing-enemies">Initializing Enemies</a></h2>
<p>When initializing the enemies (at the start of gameplay), we‚Äôll copy the enemy tile data into VRAM. Also, like with bullets, we‚Äôll loop through and make sure each enemy is set to inactive.</p>
<pre><code class="language-rgbasm linenos start=28">InitializeEnemies::

	ld de, enemyShipTileData
	ld hl, ENEMY_TILES_START
	ld bc, enemyShipTileDataEnd - enemyShipTileData
    call CopyDEintoMemoryAtHL

    ld a, 0
    ld [wSpawnCounter], a
    ld [wActiveEnemyCounter], a
    ld [wNextEnemyXPosition], a

    ld b, 0

    ld hl, wEnemies

InitializeEnemies_Loop:

    ; Set as inactive
    ld a, 0
    ld [hl], a
    
    ; Increase the address
    ld a, l
    add a, PER_ENEMY_BYTES_COUNT
    ld l, a
    ld a, h
    adc a, 0
    ld h, a

    ld a, b
    inc a
    ld b ,a

    cp a, MAX_ENEMY_COUNT
    ret z

    jp InitializeEnemies_Loop
</code></pre>
<h2 id="updating-enemies"><a class="header" href="#updating-enemies">Updating Enemies</a></h2>
<p>When ‚ÄúUpdateEnemies‚Äù is called from gameplay, the first thing we try to do is spawn new enemies. After that, if we have no active enemies (and are not trying to spawn a new enemy), we stop the ‚ÄúUpdateEnemies‚Äù function. From here, like with bullets, we‚Äôll save the address of our first enemy in hl and start looping through.</p>
<pre><code class="language-rgbasm linenos start=67">UpdateEnemies::

	call TryToSpawnEnemies

    ; Make sure we have active enemies
    ; or we want to spawn a new enemy
    ld a, [wNextEnemyXPosition]
    ld b, a
    ld a, [wActiveEnemyCounter]
    or a, b
    cp a, 0
    ret z
    
    ld a, 0
    ld [wUpdateEnemiesCounter], a

    ld a, LOW(wEnemies)
    ld l, a
    ld a, HIGH(wEnemies)
    ld h, a

    jp UpdateEnemies_PerEnemy
</code></pre>
<p>When we are  looping through our enemy object pool, let‚Äôs check if the current enemy is active. If it‚Äôs active, we‚Äôll update it like normal. If it isn‚Äôt active, the game checks if we want to spawn a new enemy. We specify we want to spawn a new enemy by setting ‚ÄòwNextEnemyXPosition‚Äô to a non-zero value. If we don‚Äôt want to spawn a new enemy, we‚Äôll move on to the next enemy.</p>
<p>If we want to spawn a new enemy, we‚Äôll set the current inactive enemy to active. Afterwards, we‚Äôll set it‚Äôs y position to zero, and it‚Äôs x position to whatever was in the ‚ÄòwNextEnemyXPosition‚Äô variable. After that, we‚Äôll increase our active enemy counter, and go on to update the enemy like normal.</p>
<pre><code class="language-rgbasm linenos start=111">UpdateEnemies_PerEnemy:

    ; The first byte is if the current object is active
    ; If it's not zero, it's active, go to the normal update section
    ld a, [hl]
    cp 0
    jp nz, UpdateEnemies_PerEnemy_Update

UpdateEnemies_SpawnNewEnemy:

    ; If this enemy is NOT active
    ; Check If we want to spawn a new enemy
    ld a, [wNextEnemyXPosition]
    cp 0

    ; If we don't want to spawn a new enemy, we'll skip this (deactivated) enemy
    jp z, UpdateEnemies_Loop

    push hl

    ; If they are deactivated, and we want to spawn an enemy
    ; activate the enemy
    ld a, 1
    ld [hli], a

    ; Put the value for our enemies x position
    ld a, [wNextEnemyXPosition]
    ld [hli], a

    ; Put the value for our enemies y position to equal 0
    ld a, 0
    ld [hli], a
    ld [hld], a

    ld a, 0
    ld [wNextEnemyXPosition], a

    pop hl
    
    ; Increase counter
    ld a,[wActiveEnemyCounter]
    inc a
    ld [wActiveEnemyCounter], a

</code></pre>
<p>When We are done updating a single enemy, we‚Äôll jump to the ‚ÄúUpdateEnemies_Loop‚Äù label. Here we‚Äôll increase how many enemies we‚Äôve updated, and end if we‚Äôve done them all. If we still have more enemies left, we‚Äôll increase the address stored in hl by 6 and update the next enemy.</p>
<blockquote>
<p>The ‚Äúhl‚Äù registers should always point to the current enemies first byte when this label is reached.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=89">UpdateEnemies_Loop:

    ; Check our coutner, if it's zero
    ; Stop the function
    ld a, [wUpdateEnemiesCounter]
    inc a
    ld [wUpdateEnemiesCounter], a

    ; Compare against the active count
    ld a, [wUpdateEnemiesCounter]
    cp a, MAX_ENEMY_COUNT
    ret nc

    ; Increase the enemy data our address is pointingtwo
    ld a, l
    add a, PER_ENEMY_BYTES_COUNT
    ld  l, a
    ld a, h
    adc a, 0
    ld  h, a
</code></pre>
<p>For updating enemies, we‚Äôll first get the enemies speed. Afterwards we‚Äôll increase the enemies 16-bit y position. Once we‚Äôve done that, we‚Äôll descale the y position so we can check for collisions and draw the ennemy.</p>
<pre><code class="language-rgbasm linenos start=156">UpdateEnemies_PerEnemy_Update:

    ; Save our first bytye
    push hl

    ; Get our move speed in e
    ld bc, enemy_speedByte
    add hl, bc
    ld a, [hl]
    ld e, a

    ; Go back to the first byte
    ; put the address toe the first byte back on the stack for later
    pop hl
    push hl

    inc hl

    ; Get our x position
    ld a, [hli]
    ld b, a
    ld [wCurrentEnemyX],a

    ; get our 16-bit y position
    ; increase it (by e), but also save it 
    ld a, [hl]
    add a, 10
    ld [hli], a
    ld c, a
    ld a, [hl]
    adc a, 0
    ld [hl], a
    ld d, a

    pop hl

    ; Descale the y psoition
    srl d
    rr c
    srl d
    rr c
    srl d
    rr c
    srl d
    rr c

    ld a, c
    ld [wCurrentEnemyY],a

</code></pre>
<h2 id="player--bullet-collision"><a class="header" href="#player--bullet-collision">Player &amp; Bullet Collision</a></h2>
<p>One of the differences between enemies and bullets is that enemies must check for collision against the player and also against bullets. For both of these cases, we‚Äôll use a simple Axis-Aligned Bounding Box test. We‚Äôll cover the specific logic in a later section.</p>
<p>If we have a collison against the player we need to damage the player, and redraw how many lives they have. In addition, it‚Äôs optional, but we‚Äôll deactivate the enemy too when they collide with the player.</p>
<blockquote>
<p>Our ‚Äúhl‚Äù registers should point to the active byte of the current enemy. We push and pop our ‚Äúhl‚Äù registers to make sure we get back to that same address for later logic.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=207">UpdateEnemies_PerEnemy_CheckPlayerCollision:

    push hl

    call CheckCurrentEnemyAgainstBullets

    pop hl
    push hl

    call CheckEnemyPlayerCollision

    pop hl

    ld a, [wResult]
    cp a, 0
    jp z, UpdateEnemies_NoCollisionWithPlayer 
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    push hl

    call DamagePlayer
    call DrawLives

    pop hl
    
    jp UpdateEnemies_DeActivateEnemy
</code></pre>
<p>If there is no collision with the player, we‚Äôll draw the enemies. This is done just as we did the player and bullets, with the ‚ÄúDrawMetasprites‚Äù function.</p>
<pre><code class="language-rgbasm linenos start=249">UpdateEnemies_NoCollisionWithPlayer::

    ; See if our non scaled low byte is above 160
    ld a, [wCurrentEnemyY]
    cp a, 160
    jp nc, UpdateEnemies_DeActivateEnemy

    push hl

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; call the 'DrawMetasprites function. setup variables and call
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; Save the address of the metasprite into the 'wMetaspriteAddress' variable
    ; Our DrawMetasprites functoin uses that variable
    ld a, LOW(enemyShipMetasprite)
    ld [wMetaspriteAddress+0], a
    ld a, HIGH(enemyShipMetasprite)
    ld [wMetaspriteAddress+1], a

    ; Save the x position
    ld a, [wCurrentEnemyX]
    ld [wMetaspriteX],a

    ; Save the y position
    ld a, [wCurrentEnemyY]
    ld [wMetaspriteY],a

    ; Actually call the 'DrawMetasprites function
    call DrawMetasprites;

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    pop hl
    
    jp UpdateEnemies_Loop
</code></pre>
<h2 id="deactivating-enemies"><a class="header" href="#deactivating-enemies">Deactivating Enemies</a></h2>
<p>Deactivating an enemy is just like with bullets. We‚Äôll set it‚Äôs first byte to 0, and decrease our counter variable.</p>
<blockquote>
<p>Here, we can just use the current address in HL. This is the second reason we wanted to keep the address of our first byte on the stack.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=235">UpdateEnemies_DeActivateEnemy:

    ; Set as inactive
    ld a, 0
    ld [hl], a

    ; Decrease counter
    ld a,[wActiveEnemyCounter]
    dec a
    ld [wActiveEnemyCounter], a

    jp UpdateEnemies_Loop

</code></pre>
<h2 id="spawning-enemies"><a class="header" href="#spawning-enemies">Spawning Enemies</a></h2>
<p>Randomly, we want to spawn enemies. We‚Äôll increase a counter called ‚ÄúwEnemyCounter‚Äù. When it reaches a preset maximum value, we‚Äôll <strong>maybe</strong> try to spawn a new enemy. </p>
<p>Firstly, We need to make sure we aren‚Äôt at maximum enemy capacity, if so, we will not spawn enemy more enemies. If we are not at maximum capacity, we‚Äôll try to get a x position to spawn the enemy at. If our x position is below 24 or above 150, we‚Äôll also NOT spawn a new enemy. </p>
<blockquote>
<p>All enemies are spawned with y position of 0, so we only need to get the x position.</p>
</blockquote>
<p>If we have a valid x position, we‚Äôll reset our spawn counter, and save that x position in the ‚ÄúwNextEnemyXPosition‚Äù variable. With this variable set, We‚Äôll later activate and update a enemy that we find in the inactive state.</p>
<pre><code class="language-rgbasm linenos start=290">TryToSpawnEnemies::

    ; Increase our spwncounter
    ld a, [wSpawnCounter]
    inc a
    ld [wSpawnCounter], a

    ; Check our spawn acounter
    ; Stop if it's below a given value
    ld a, [wSpawnCounter]
    cp a, ENEMY_SPAWN_DELAY_MAX
    ret c

    ; Check our next enemy x position variable
    ; Stop if it's non zero
    ld a, [wNextEnemyXPosition]
    cp a, 0
    ret nz

    ; Make sure we don't have the max amount of enmies
    ld a, [wActiveEnemyCounter]
    cp a, MAX_ENEMY_COUNT
    ret nc

GetSpawnPosition:

    ; Generate a semi random value
    call rand
    
    ; make sure it's not above 150
    ld a,b
    cp a, 150
    ret nc

    ; make sure it's not below 24
    ld a, b
    cp a, 24
    ret c

    ; reset our spawn counter
    ld a, 0
    ld [wSpawnCounter], a
    
    ld a, b
    ld [wNextEnemyXPosition], a


    ret
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collision-detection"><a class="header" href="#collision-detection">Collision Detection</a></h1>
<p>Collision Detection is cruical to games. It can be a very complicated topic. In Galactic Armada, things will be kept super simple. We‚Äôre going to perform a basic implementation of ‚ÄúAxis-Aligned Bounding Box Collision Detection‚Äù:</p>
<blockquote>
<p>One of the simpler forms of collision detection is between two rectangles that are axis aligned ‚Äî meaning no rotation. The algorithm works by ensuring there is no gap between any of the 4 sides of the rectangles. Any gap means a collision does not exist.<sup class="footnote-reference"><a href="#mdn_source">1</a></sup></p>
</blockquote>
<p>The easiest way to check for overlap, is to check the difference bewteen their centers. If the absolute value of their x &amp; y differences (I‚Äôll refer to as ‚Äúthe absolute difference‚Äù) are BOTH smaller than the sum of their half widths, we have a collision. This collision detection is run for bullets against enemies, and enemies against the player. Here‚Äôs a visualization with bullets and enemies.</p>
<p><img src="part3/../assets/part3/img/CollisionDetectionVisualized.png" alt="CollisionDetectionVisualized.png" /></p>
<p>For this, we‚Äôve created a basic function called ‚ÄúCheckObjectPositionDifference‚Äù. This function will help us check for overlap on the x or y axis. When the (absolute) difference between the first two values passed is greater than the third value passed, it jump‚Äôs to the label passed in the fourth parameter.</p>
<p>Here‚Äôs an example of how to call this function:</p>
<blockquote>
<p>We have the player‚Äôs x &amp; y position in registers d &amp; e respectively. We have the enemy‚Äôs x &amp; y position in registers b &amp; c respectively. If there is no overlap on the x or y axis, the program jumps to the ‚ÄúNoCollisionWithPlayer‚Äù label.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=696">
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Check the absolute distances. Jump to 'NoAxisOverlap' on failure
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


    ld a, b
    ld [wObject1Value], a

    ld a, d
    ld [wObject2Value], a

    ; Save if the minimum distance
    ld a, 16
    ld [wSize], a

    call CheckObjectPositionDifference

    ld a, [wResult]
    cp a, 0
    jp z, NoAxisOverlap

OverlapExists:

  ... There is an overlap

NoAxisOverlap:

  ... no overlap
    

</code></pre>
<p>When checking for collision, we‚Äôll use that function twice. Once for the x-axis, and again for the y-axis.</p>
<blockquote>
<p>NOTE: We don‚Äôt need to test the y-axis if the x-axis fails. </p>
</blockquote>
<p>The source code for that function looks like this:</p>
<pre><code class="language-rgbasm linenos start=1">include &quot;src/main/utils/hardware.inc&quot;
include &quot;src/main/utils/constants.inc&quot;
include &quot;src/main/utils/hardware.inc&quot;

SECTION &quot;CollisionUtilsVariables&quot;, WRAM0

wResult::db;
wSize::db;
wObject1Value:: db
wObject2Value:: db

SECTION &quot;CollisionUtils&quot;, ROM0

CheckObjectPositionDifference::

    ; at this point in time; e = enemy.y, b =bullet.y

    ld a, [wObject1Value]
    ld e, a
    ld a, [wObject2Value]
    ld b, a

    ld a, [wSize]
    ld d, a

    ; subtract  bullet.y, (aka b) - (enemy.y+8, aka e)
    ; carry means e&lt;b, means enemy.bottom is visually above bullet.y (no collision)

    ld a, e
    add a, d
    cp a, b

    ;  carry means  no collision
    jp c, CheckObjectPositionDifference_Failure

    ; subtract  enemy.y-8 (aka e) - bullet.y (aka b)
    ; no carry means e&gt;b, means enemy.top is visually below bullet.y (no collision)
    ld a, e
    sub a, d
    cp a, b

    ; no carry means no collision
    jp nc, CheckObjectPositionDifference_Failure

    ld a,1
    ld [wResult], a
    ret;

    
CheckObjectPositionDifference_Failure:

    ld a,0
    ld [wResult], a
    ret;

</code></pre>
<div class="footnote-definition" id="mdn_source"><sup class="footnote-definition-label">1</sup>
<p>From <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection">mdn web docs - 2D collision detection</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enemy-player-collision"><a class="header" href="#enemy-player-collision">Enemy-Player Collision</a></h1>
<p>Our enemy versus player collision detection starts with us getting our player‚Äôs unscaled x position. We‚Äôll store that value in d.</p>
<pre><code class="language-rgbasm linenos start=6">CheckEnemyPlayerCollision::

    ; Get our player's unscaled x position in d
    ld a, [wPlayerPositionX+0]
    ld d,a

    ld a, [wPlayerPositionX+1]
    ld e,a

    srl e
    rr d
    srl e
    rr d
    srl e
    rr d
    srl e
    rr d
    
</code></pre>
<p>With our player‚Äôs x position in d, we‚Äôll compare it against a previously saved enemy x position variable. If they are more than 16 pixels apart, we‚Äôll jump to the ‚ÄúNoCollisionWithPlayer‚Äù label.</p>
<pre><code class="language-rgbasm linenos start=25">
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Check the x distances. Jump to 'NoCollisionWithPlayer' on failure
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ld a, [wCurrentEnemyX]
    ld [wObject1Value], a

    ld a, d
    ld [wObject2Value], a

    ; Save if the minimum distance
    ld a, 16
    ld [wSize], a

    call CheckObjectPositionDifference

    ld a, [wResult]
    cp a, 0
    jp z, NoCollisionWithPlayer
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    
</code></pre>
<p>After checking the x axis, if the code gets this far there was an overlap. We‚Äôll do the same for the y axis next.</p>
<p>We‚Äôll get the player‚Äôs unscaled y position. We‚Äôll store that value in d for consistency.</p>
<pre><code class="language-rgbasm linenos start=49">    ; Get our player's unscaled y position in d
    ld a, [wPlayerPositionY+0]
    ld d,a

    ld a, [wPlayerPositionY+1]
    ld e,a

    srl e
    rr d
    srl e
    rr d
    srl e
    rr d
    srl e
    rr d

</code></pre>
<p>Just like before, we‚Äôll compare our player‚Äôs unscaled y position (stored in d) against a previously saved enemy y position variable. If they are more than 16 pixels apart, we‚Äôll jump to the ‚ÄúNoCollisionWithPlayer‚Äù label. </p>
<pre><code class="language-rgbasm linenos start=67">
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Check the y distances. Jump to 'NoCollisionWithPlayer' on failure
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


    ld a, [wCurrentEnemyY]
    ld [wObject1Value], a

    ld a, d
    ld [wObject2Value], a

    ; Save if the minimum distance
    ld a, 16
    ld [wSize], a

    call CheckObjectPositionDifference

    ld a, [wResult]
    cp a, 0
    jp z, NoCollisionWithPlayer
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

</code></pre>
<p>The ‚ÄúNoCollisionWithPlayer‚Äù, just set‚Äôs the ‚ÄúwResult‚Äù to 0 for failure. If overlap occurs on both axis, we‚Äôll isntead set 1 for success.</p>
<pre><code class="language-rgbasm linenos start=91">
    ld a, 1
    ld [wResult], a

    ret
    
NoCollisionWithPlayer::

    ld a, 0
    ld [wResult], a

    ret

</code></pre>
<p>That‚Äôs the enemy-player collision logic. Callers of the function can simply check the ‚ÄúwResult‚Äù variable to determine if there was collision.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enemy-bullet-collision"><a class="header" href="#enemy-bullet-collision">Enemy-Bullet Collision</a></h1>
<p>When we are udating enemies, we‚Äôll call a function called ‚ÄúCheckCurrentEnemyAgainstBullets‚Äù. This will check the current enemy against all active bullets.</p>
<p>This fuction needs to loop through the bullet object pool, and check if our current enemy overlaps any bullet on both the x and y axis. If so, we‚Äôll deactivate the enemy and bullet.</p>
<p>Our ‚ÄúCheckCurrentEnemyAgainstBullets‚Äù function starts off in a manner similar to how we updated enemies &amp; bullets.</p>
<blockquote>
<p>This function expects ‚Äúhl‚Äù points to the curent enemy. We‚Äôll save that in a variable for later usage.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=2">include &quot;src/main/utils/hardware.inc&quot;
include &quot;src/main/utils/constants.inc&quot;
include &quot;src/main/utils/hardware.inc&quot;

SECTION &quot;EnemyBulletCollisionVariables&quot;, WRAM0

wEnemyBulletCollisionCounter: db
wBulletAddresses: dw

SECTION &quot;EnemyBulletCollision&quot;, ROM0

; called from enemies.asm
CheckCurrentEnemyAgainstBullets::


    ld a, l
    ld [wUpdateEnemiesCurrentEnemyAddress+0], a
    ld a, h
    ld [wUpdateEnemiesCurrentEnemyAddress+1], a

    ld a, 0
    ld [wEnemyBulletCollisionCounter], a
    
    ; Copy our bullets address into wBulletAddress
    ld a, LOW(wBullets)
    ld l, a
    ld a, HIGH(wBullets)
    ld h, a

    jp CheckCurrentEnemyAgainstBullets_PerBullet
</code></pre>
<p>As we loop through the bullets, we need to make sure we only check active bullets. Inactive bullets will be skipped.</p>
<pre><code class="language-rgbasm linenos start=53">CheckCurrentEnemyAgainstBullets_PerBullet:

    ld a, [hl]
    cp a, 1
    jp nz, CheckCurrentEnemyAgainstBullets_Loop
</code></pre>
<p>First, we need to check if the current enemy and current bullet are overlapping on the x axis. We‚Äôll get the enemy‚Äôs x position in e, and the bullet‚Äôs x position in b. From there, we‚Äôll again call our ‚ÄúCheckObjectPositionDifference‚Äù function. If it returns a failure (wResult=0), we‚Äôll start with the next bullet.</p>
<blockquote>
<p>We add an offset to the x coordinates so they measure from their centers. That offset is half it‚Äôs respective object‚Äôs width.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=59">CheckCurrentEnemyAgainstBullets_Check_X_Overlap:

    ; Save our first byte address
    push hl

    inc hl

    ; Get our x position
    ld a, [hli]
    add a, 4
    ld b, a

    push hl

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Start: Checking the absolute difference
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; The first value
    ld a, b
    ld [wObject1Value], a

    ; The second value
    ld a, [wCurrentEnemyX]
    add a, 8
    ld [wObject2Value], a

    ; Save if the minimum distance
    ld a, 12
    ld [wSize], a

    call CheckObjectPositionDifference

    
    ld a, [wResult]
    cp a, 0
    jp z, CheckCurrentEnemyAgainstBullets_Check_X_Overlap_Fail

    
    pop hl

    jp CheckCurrentEnemyAgainstBullets_PerBullet_Y_Overlap

CheckCurrentEnemyAgainstBullets_Check_X_Overlap_Fail:

    pop hl
    pop hl

    jp CheckCurrentEnemyAgainstBullets_Loop
</code></pre>
<p>Next we restore our hl variable so we can get the y position of our current bullet. Once we have that y position, we‚Äôll get the current enemy‚Äôs y position and check for an overlap on the y axis. If no overlap is found, we‚Äôll loop to the next bullet. Otherwise, we have a collision.</p>
<pre><code class="language-rgbasm linenos start=113">    
CheckCurrentEnemyAgainstBullets_PerBullet_Y_Overlap:

    ; get our bullet 16-bit y position
    ld a, [hli]
    ld b, a

    ld a, [hli]
    ld c, a

    ; Descale our 16 bit y position
    srl c
    rr b
    srl c
    rr b
    srl c
    rr b
    srl c
    rr b

    ; preserve our first byte addresss
    pop hl
    push hl

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Start: Checking the absolute difference
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; The first value
    ld a, b
    ld [wObject1Value], a

    ; The second value
    ld a, [wCurrentEnemyY]
    ld [wObject2Value], a

    ; Save if the minimum distance
    ld a, 16
    ld [wSize], a

    call CheckObjectPositionDifference

    pop hl
    
    ld a, [wResult]
    cp a, 0
    jp z, CheckCurrentEnemyAgainstBullets_Loop
    jp CheckCurrentEnemyAgainstBullets_PerBullet_Collision

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; End: Checking the absolute difference
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
</code></pre>
<p>If a collision was detected (overlap on x and y axis), we‚Äôll set the current active byte for that bullet to 0. Also , we‚Äôll set the active byte for the current enemy to zero. Before we end the function, we‚Äôll increase and redraw the score, and decrease how many bullets &amp; enemies we have by one.</p>
<pre><code class="language-rgbasm linenos start=168">CheckCurrentEnemyAgainstBullets_PerBullet_Collision:

    ; set the active byte  and x value to 0 for bullets
    ld a, 0
    ld [hli], a
    ld [hl], a

    ld a, [wUpdateEnemiesCurrentEnemyAddress+0]
    ld l, a
    ld a, [wUpdateEnemiesCurrentEnemyAddress+1]
    ld h, a

    ; set the active byte  and x value to 0 for enemies
    ld a, 0
    ld [hli], a
    ld [hl], a
    
    call IncreaseScore;
    call DrawScore

    ; Decrease how many active enemies their are
    ld a, [wActiveEnemyCounter]
    dec a
    ld [wActiveEnemyCounter], a

    ; Decrease how many active bullets their are
    ld a, [wActiveBulletCounter]
    dec a
    ld [wActiveBulletCounter], a

    ret
</code></pre>
<p>If no collision happened, we‚Äôll continue our loop through the enemy bullets. When we‚Äôve checked all the bullets, we‚Äôll end the function.</p>
<pre><code class="language-rgbasm linenos start=33">CheckCurrentEnemyAgainstBullets_Loop:

    ; increase our counter
    ld a, [wEnemyBulletCollisionCounter]
    inc a
    ld [wEnemyBulletCollisionCounter], a

    ; Stop if we've checked all bullets
    cp a, MAX_BULLET_COUNT
    ret nc

    ; Increase the  data our address is pointing to
    ld a, l
    add a, PER_BULLET_BYTES_COUNT
    ld  l, a
    ld a, h
    adc a, 0
    ld  h, a
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>If you liked this tutorial, and you want to take things to the next level, here are some ideas:</p>
<ul>
<li>Add an options menu (for typewriter speed, difficulty, disable audio)</li>
<li>Add Ship Select and different player ships</li>
<li>Add the ability to upgrade your bullet type</li>
<li>Add dialogue and ‚Äúwaves‚Äù of enemies</li>
<li>Add different types of enemies</li>
<li>Add a boss</li>
<li>Add a level select</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="where-to-go-next"><a class="header" href="#where-to-go-next">Where to go next</a></h1>
<p>Oh.</p>
<p>Well, you‚Äôve reached the end of the tutorial‚Ä¶
And yes, as you can see, it‚Äôs not finished <em>yet</em>.</p>
<p>We‚Äôre actively working on new content (and improvement of the existing one).</p>
<p>In the meantime, the best course of action is to peruse the <a href="resources.html">resources</a> in the next section, and experiment by yourself.
Well, given that, it may be a good idea to <a href="help-feedback.html">ask around</a> for advice.
A lot of the problems and questions you will be encountering have already been solved, so others can‚Äîand will!‚Äîhelp you getting started faster.</p>
<p>If you enjoyed the tutorial, please consider <a href="index.html#contributing">contributing</a>, donating to our <a href="https://opencollective.com/gbdev">OpenCollective</a> or simply share the link to this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rgbds-cheatsheet"><a class="header" href="#rgbds-cheatsheet">RGBDS Cheatsheet</a></h1>
<p>The purpose of this page is to provide concise explanations and code snippets for common tasks.
For extra depth, clarity, and understanding, it‚Äôs recommended you read through the <a href="part1/setup.html">Hello World</a>, <a href="part2/getting-started.html">Part II - Our first game</a>, and <a href="part3/getting-started.html">Part III - Our second game</a> tutorials.</p>
<p>Assembly syntax &amp; CPU Instructions will not be explained, for more information see the <a href="https://rgbds.gbdev.io/docs/rgbasm.5">RGBDS Language Reference</a></p>
<p>Is there something common you think is missing? Check the <a href="https://github.com/gbdev/gb-asm-tutorial">github repository</a> to open an Issue or contribute to this page. Alternatively, you can reach out on one of the @gbdev <a href="https://gbdev.io/chat.html">community channels</a>.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="cheatsheet.html#rgbds-cheatsheet">RGBDS Cheatsheet</a>
<ul>
<li><a href="cheatsheet.html#table-of-contents">Table of Contents</a></li>
<li><a href="cheatsheet.html#display">Display</a>
<ul>
<li><a href="cheatsheet.html#wait-for-the-vertical-blank-phase">Wait for the vertical blank phase</a></li>
<li><a href="cheatsheet.html#turn-onoff-the-lcd">Turn on/off the LCD</a></li>
<li><a href="cheatsheet.html#turn-onoff-the-background">Turn on/off the background</a></li>
<li><a href="cheatsheet.html#turn-onoff-the-window">Turn on/off the window</a></li>
<li><a href="cheatsheet.html#switch-which-tilemaps-are-used-by-the-window-andor-background">Switch which tilemaps are used by the window and/or background</a></li>
<li><a href="cheatsheet.html#turn-onoff-sprites">Turn on/off sprites</a></li>
<li><a href="cheatsheet.html#turn-onoff-tall-8x16-sprites">Turn on/off tall (8x16) sprites</a></li>
</ul>
</li>
<li><a href="cheatsheet.html#backgrounds">Backgrounds</a>
<ul>
<li><a href="cheatsheet.html#put-backgroundwindow-tile-data-into-vram">Put background/window tile data into VRAM</a></li>
<li><a href="cheatsheet.html#draw-on-the-backgroundwindow">Draw on the Background/Window</a></li>
<li><a href="cheatsheet.html#move-the-background">Move the background</a></li>
<li><a href="cheatsheet.html#move-the-window">Move the window</a></li>
</ul>
</li>
<li><a href="cheatsheet.html#joypad-input">Joypad Input</a>
<ul>
<li><a href="cheatsheet.html#check-if-a-button-is-down">Check if a button is down</a></li>
<li><a href="cheatsheet.html#check-if-a-button-was-just-pressed">Check if a button was JUST pressed</a></li>
<li><a href="cheatsheet.html#wait-for-a-button-press">Wait for a button press</a></li>
</ul>
</li>
<li><a href="cheatsheet.html#hud">HUD</a>
<ul>
<li><a href="cheatsheet.html#draw-text">Draw text</a></li>
<li><a href="cheatsheet.html#draw-a-bottom-hud">Draw a bottom HUD</a></li>
</ul>
</li>
<li><a href="cheatsheet.html#sprites">Sprites</a>
<ul>
<li><a href="cheatsheet.html#put-sprite-tile-data-in-vram">Put sprite tile data in VRAM</a></li>
<li><a href="cheatsheet.html#manipulate-hardware-oam-sprites">Manipulate hardware OAM sprites</a></li>
<li><a href="cheatsheet.html#implement-a-shadow-oam-using-eievui5s-sprite-object-library">Implement a Shadow OAM using @eievui5‚Äôs Sprite Object Library</a></li>
<li><a href="cheatsheet.html#manipulate-shadow-oam-oam-sprites">Manipulate Shadow OAM OAM sprites</a></li>
</ul>
</li>
<li><a href="cheatsheet.html#micelaneous">Micelaneous</a>
<ul>
<li><a href="cheatsheet.html#save-data">Save Data</a></li>
<li><a href="cheatsheet.html#generate-random-numbers">Generate random numbers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="display"><a class="header" href="#display">Display</a></h2>
<p>The <code>rLCDC</code> register controls all of the following:</p>
<ul>
<li>The screen</li>
<li>The background</li>
<li>The window</li>
<li>Sprite objects</li>
</ul>
<p>For more information on LCD control, refer to the <a href="https://gbdev.io/pandocs/LCDC.html">Pan Docs</a></p>
<h3 id="wait-for-the-vertical-blank-phase"><a class="header" href="#wait-for-the-vertical-blank-phase">Wait for the vertical blank phase</a></h3>
<p>To check for the vertical blank phase, use the <code>rLY</code> register. Compare that register‚Äôs value against the height of the Game Boy screen in pixels: 144.</p>
<pre><code class="language-rgbasm linenos">WaitUntilVerticalBlankStart:
    ldh a, [rLY]
    cp 144
    jp c, WaitUntilVerticalBlankStart
</code></pre>
<h3 id="turn-onoff-the-lcd"><a class="header" href="#turn-onoff-the-lcd">Turn on/off the LCD</a></h3>
<p>You can turn the LCD on and off by altering the most significant bit of the <code>rLCDC</code> register. hardware.inc a constant for this: <code>LCDCF_ON</code> .</p>
<p><strong>To turn the LCD on:</strong></p>
<pre><code class="language-rgbasm linenos">ld a, LCDCF_ON
ldh [rLCDC], a
</code></pre>
<p><strong>To turn the LCD off:</strong></p>
<p>::: warning</p>
<p>Do not turn the LCD off outside of the Vertical Blank Phase. See ‚Äú<a href="cheatsheet.html#how-to-wait-for-the-vertical-blank-phase">How to wait for vertical blank phase</a>‚Äù.</p>
<p>:::</p>
<pre><code class="language-rgbasm linenos">; Turn the LCD off
ld a, LCDCF_OFF
ldh [rLCDC], a
</code></pre>
<h3 id="turn-onoff-the-background"><a class="header" href="#turn-onoff-the-background">Turn on/off the background</a></h3>
<p>To turn the background layer on and off, alter the least significant bit of the <code>rLCDC</code> register. You can use the <code>LCDCF_BGON</code> constant for this.</p>
<p><strong>To turn the background on:</strong></p>
<pre><code class="language-rgbasm linenos">; Turn the background on
ldh a, [rLCDC]
or a, LCDCF_BGON
ldh [rLCDC], a
</code></pre>
<p><strong>To turn the background off:</strong></p>
<pre><code class="language-rgbasm linenos">; Turn the background off
ldh a, [rLCDC]
and a, ~LCDCF_BGON
ldh [rLCDC], a
</code></pre>
<h3 id="turn-onoff-the-window"><a class="header" href="#turn-onoff-the-window">Turn on/off the window</a></h3>
<p>To turn the window layer on and off, alter the least significant bit of the <code>rLCDC</code> register. You can use the <code>LCDCF_WINON</code> and <code>LCDCF_WINOFF</code> constants for this.</p>
<p><strong>To turn the window on:</strong></p>
<pre><code class="language-rgbasm linenos">; Turn the window on
ldh a, [rLCDC]
or a, LCDCF_WINON
ldh [rLCDC], a
</code></pre>
<p><strong>To turn the window off:</strong></p>
<pre><code class="language-rgbasm linenos">; Turn the window off
ldh a, [rLCDC]
and a, LCDCF_WINOFF
ldh [rLCDC], a
</code></pre>
<h3 id="switch-which-tilemaps-are-used-by-the-window-andor-background"><a class="header" href="#switch-which-tilemaps-are-used-by-the-window-andor-background">Switch which tilemaps are used by the window and/or background</a></h3>
<p>By default, the window and background layer will use the same tilemap.</p>
<p>For the window and background, there are 2 memory regions they can use: <code>$9800</code> and <code>$9C00</code>. For more information, refer to the <a href="https://gbdev.io/pandocs/Tile_Maps.html">Pan Docs</a></p>
<p>Which region the background uses is controlled by the 4th bit of the <code>rLCDC</code> register. Which region the window uses is controlled by the 7th bit.</p>
<p>You can use one of the 4 constants to specify which layer uses which region:</p>
<ul>
<li>LCDCF_WIN9800</li>
<li>LCDCF_WIN9C00</li>
<li>LCDCF_BG9800</li>
<li>LCDCF_BG9C00</li>
</ul>
<p>::: tip Note</p>
<p>You still need to make sure the window and background are turned on when using these constants.</p>
<p>:::</p>
<h3 id="turn-onoff-sprites"><a class="header" href="#turn-onoff-sprites">Turn on/off sprites</a></h3>
<p>Sprites (or objects) can be toggled on and off using the 2nd bit of the <code>rLCDC</code> register. You can use the <code>LCDCF_OBJON</code> and <code>LCDCF_OBJOFF</code> constants for this.</p>
<p><strong>To turn sprite objects on:</strong></p>
<pre><code class="language-rgbasm linenos">; Turn the sprites on
ldh a, [rLCDC]
or a, LCDCF_OBJON
ldh [rLCDC], a
</code></pre>
<p><strong>To turn sprite objects off:</strong></p>
<pre><code class="language-rgbasm linenos">; Turn the sprites off
ldh a, [rLCDC]
and a, LCDCF_OBJOFF
ldh [rLCDC], a
</code></pre>
<p>::: tip</p>
<p>Sprites are in 8x8 mode by default.</p>
<p>:::</p>
<h3 id="turn-onoff-tall-8x16-sprites"><a class="header" href="#turn-onoff-tall-8x16-sprites">Turn on/off tall (8x16) sprites</a></h3>
<p>Once sprites are enabled, you can enable tall sprites using the 3rd bit of the <code>rLCDC</code> register: <code>LCDCF_OBJ16</code></p>
<p>::: tip</p>
<p>You can not have some 8x8 sprites and some 8x16 sprites. All sprites must be of the same size.</p>
<p>:::</p>
<pre><code class="language-rgbasm linenos">; Turn tall sprites on
ldh a, [rLCDC]
or a, LCDCF_OBJ16
ldh [rLCDC], a
</code></pre>
<h2 id="backgrounds"><a class="header" href="#backgrounds">Backgrounds</a></h2>
<h3 id="put-backgroundwindow-tile-data-into-vram"><a class="header" href="#put-backgroundwindow-tile-data-into-vram">Put background/window tile data into VRAM</a></h3>
<p>The region in VRAM dedicated for the background/window tilemaps is from $9000 to $97FF. hardware.inc defines a <code>_VRAM9000</code> constant you can use for that.</p>
<p>MyBackground:
INCBIN ‚Äúsrc/path/to/my-background.2bpp‚Äù
.end</p>
<p>CopyBackgroundWindowTileDataIntoVram:
; Copy the tile data
ld de, myBackground
ld hl, _VRAM
ld bc, MyBackground.end - MyBackground
.loop:
ld a, [de]
ld [hli], a
inc de
dec bc
ld a, b
or a, c
jr nz, .Loop</p>
<h3 id="draw-on-the-backgroundwindow"><a class="header" href="#draw-on-the-backgroundwindow">Draw on the Background/Window</a></h3>
<p>The Game Boy has 2 32x32 tilemaps, one at <code>$9800</code> and another at <code>$9C00</code>. Either can be used for the background or window. By default, they both use the tilemap at <code>$9800</code>.</p>
<p>Drawing on the background or window is as simple as copying bytes starting at one of those addresses:</p>
<pre><code class="language-rgbasm  lineno">CopyTilemapTo
   ; Copy the tilemap
    ld de, Tilemap
    ld hl, $9800
    ld bc, TilemapEnd - Tilemap
CopyTilemap:
    ld a, [de]
    ld [hli], a
    inc de
    dec bc
    ld a, b
    or a, c
    jp nz, CopyTilemap
</code></pre>
<p>::: tip</p>
<p>Make sure the layer you‚Äôre targetting has been turned on. See <a href="cheatsheet.html#turn-onoff-the-window">‚ÄúTurn on/off the window‚Äù</a> and <a href="cheatsheet.html#turn-onoff-the-background">‚ÄúTurn on/off the background‚Äù</a></p>
<p>:::</p>
<p>::: tip</p>
<p>In terms of tiles, The background/window tilemaps are 32x32. The Game Boy‚Äôs screen is 20x18. When copying tiles, understand that RGBDS or the Game Boy won‚Äôt automatically jump to the next visible row after you‚Äôve reached the 20th column.</p>
<p>:::</p>
<h3 id="move-the-background"><a class="header" href="#move-the-background">Move the background</a></h3>
<p>You can move the background horizontally &amp; vertically using the <code>$FF43</code> and <code>$FF42</code> registers, respectively. Hardware.inc defines two constants for that: <code>rSCX</code> and <code>rSCY</code>.</p>
<p><strong>How to change the background‚Äôs X Position:</strong></p>
<pre><code class="language-rgbasm linenos">ld a,64
ld [rSCX], a
</code></pre>
<p><strong>How to change the background‚Äôs Y Position:</strong></p>
<pre><code class="language-rgbasm linenos">ld a,64
ld [rSCY], a
</code></pre>
<p>Check out the Pan Docs for more info on the <a href="https://gbdev.io/pandocs/Scrolling.html#ff42ff43--scy-scx-background-viewport-y-position-x-position">Background viewport Y position, X position</a></p>
<h3 id="move-the-window"><a class="header" href="#move-the-window">Move the window</a></h3>
<p>Moving the window is the same as moving the background, except using the <code>$FF4B</code> and <code>$FF4A</code> registers. Hardware.inc defines two constants for that: <code>rWX</code> and <code>rWY</code>.</p>
<p>::: tip</p>
<p>The window layer has a -7 pixel horizontal offset. This means setting <code>rWX</code> to 7 places the window at the left side of the screen, and setting <code>rWX</code> to 87 places the window with its left side halfway across the screen.</p>
<p>:::</p>
<p><strong>How to change the window‚Äôs X Position:</strong></p>
<pre><code class="language-rgbasm linenos">ld a,64
ld [rWX], a
</code></pre>
<p><strong>How to change the window‚Äôs Y Position:</strong></p>
<pre><code class="language-rgbasm linenos">ld a,64
ld [rWY], a
</code></pre>
<p>Check out the Pan Docs for more info on the <a href="https://gbdev.io/pandocs/Scrolling.html#ff4aff4b--wy-wx-window-y-position-x-position-plus-7">WY, WX: Window Y position, X position plus 7</a></p>
<h2 id="joypad-input"><a class="header" href="#joypad-input">Joypad Input</a></h2>
<p>Reading joypad input is not a trivial task. For more info see <a href="https://gbdev.io/gb-asm-tutorial/part2/input.html">Tutorial #2</a>, or the <a href="https://gbdev.io/pandocs/Joypad_Input.html">Joypad Input Page</a> in the Pan Docs. Paste this code somewhere in your project:</p>
<pre><code class="language-rgbasm linenos start=113">UpdateKeys:
  ; Poll half the controller
  ld a, P1F_GET_BTN
  call .onenibble
  ld b, a ; B7-4 = 1; B3-0 = unpressed buttons

  ; Poll the other half
  ld a, P1F_GET_DPAD
  call .onenibble
  swap a ; A3-0 = unpressed directions; A7-4 = 1
  xor a, b ; A = pressed buttons + directions
  ld b, a ; B = pressed buttons + directions

  ; And release the controller
  ld a, P1F_GET_NONE
  ldh [rP1], a

  ; Combine with previous wCurKeys to make wNewKeys
  ld a, [wCurKeys]
  xor a, b ; A = keys that changed state
  and a, b ; A = keys that changed to pressed
  ld [wNewKeys], a
  ld a, b
  ld [wCurKeys], a
  ret

.onenibble
  ldh [rP1], a ; switch the key matrix
  call .knownret ; burn 10 cycles calling a known ret
  ldh a, [rP1] ; ignore value while waiting for the key matrix to settle
  ldh a, [rP1]
  ldh a, [rP1] ; this read counts
  or a, $F0 ; A7-4 = 1; A3-0 = unpressed keys
.knownret
  ret
</code></pre>
<p>Next setup 2 variables in working ram:</p>
<pre><code class="language-rgbasm linenos start=410">SECTION &quot;Input Variables&quot;, WRAM0
wCurKeys: db
wNewKeys: db
</code></pre>
<p>Finally, during your game loop, be sure to call the <code>UpdateKeys</code> function during the Vertical Blank phase.</p>
<pre><code class="language-rgbasm linenos">; Check the current keys every frame and move left or right.
call UpdateKeys
</code></pre>
<h3 id="check-if-a-button-is-down"><a class="header" href="#check-if-a-button-is-down">Check if a button is down</a></h3>
<p>You can check if a button is down using any of the following constants from hardware.inc:</p>
<ul>
<li>PADF_DOWN</li>
<li>PADF_UP</li>
<li>PADF_LEFT</li>
<li>PADF_RIGHT</li>
<li>PADF_START</li>
<li>PADF_SELECT</li>
<li>PADF_B</li>
<li>PADF_A</li>
</ul>
<p>You can check if the associataed button is down using the <code>wCurKeys</code> variable:</p>
<pre><code class="language-rgbasm linenos">ld a, [wCurKeys]
and a, PADF_LEFT
jp nz, LeftIsPressedDown
</code></pre>
<h3 id="check-if-a-button-was-just-pressed"><a class="header" href="#check-if-a-button-was-just-pressed">Check if a button was JUST pressed</a></h3>
<p>You can tell if a button was JUST pressed using the <code>wNewKeys</code> variable</p>
<pre><code class="language-rgbasm linenos">ld a, [wNewKeys]
and a, PADF_A
jp nz, AWasJustPressed
</code></pre>
<h3 id="wait-for-a-button-press"><a class="header" href="#wait-for-a-button-press">Wait for a button press</a></h3>
<p>To wait <strong>indefinitely</strong> for a button press, create a loop where you:</p>
<ul>
<li>check if the button has JUST been pressed</li>
<li>If not:
<ul>
<li>Wait until the next vertical blank phase completes</li>
<li>call the <code>UpdateKeys</code> function again</li>
<li>Loop background to the beginning</li>
</ul>
</li>
</ul>
<p>::: tip</p>
<p>This will halt all other logic (outside of interrupts), be careful if you need any logic running simultaneously.</p>
<p>:::</p>
<pre><code class="language-rgbasm  linenos">WaitForAButtonToBePressed:
    ld a, [wNewKeys]
    and a, PADF_A
    ret nz
WaitUntilVerticalBlankStart:
    ld a, [rLY]
    cp 144
    jp nc, WaitUntilVerticalBlankStart
WaitUntilVerticalBlankEnd:
    ld a, [rLY]
    cp 144
    jp c, WaitUntilVerticalBlankEnd
    call UpdateKeys
    jp WaitForAButtonToBePressed
</code></pre>
<h2 id="hud"><a class="header" href="#hud">HUD</a></h2>
<p>Heads Up Displays, or HUDs; are commonly used to prevent extra information to the player. Good examples are: Score, Health, and the current level. The window layer is drawn on top of the background, and cannot move like the background. For this reason, commonly the window layer is used for HUDs. See <a href="cheatsheet.html#how-to-draw-on-the-backgroundwindow">‚ÄúHow to Draw on the Background/Window‚Äù</a>.</p>
<h3 id="draw-text"><a class="header" href="#draw-text">Draw text</a></h3>
<p>Drawing text on the window is essentially drawing tiles (with letters/numbers/punctuation on them) on the window and/or background layer.</p>
<p>To simplify the process you can define constant strings.</p>
<p>::: tip</p>
<p>These constants end with a literal 255, which our code will read as the end of the string.</p>
<p>:::</p>
<pre><code class="language-rgbasm  lineno">
SECTION &quot;Text ASM&quot;, ROM0

wScoreText::  db &quot;score&quot;, 255

</code></pre>
<p>RGBDS has a character map functionality. You can read more in the <a href="https://rgbds.gbdev.io/docs/rgbasm.5#DEFINING_DATA">RGBDS Assembly Syntax Documentation</a>. This functionality, tells the compiler how to map each letter:</p>
<p>::: tip</p>
<p>You need to have your text font tiles in VRAM at the locations specified in the map. See <a href="cheatsheet.html#how-to-put-backgroundwindow-tile-data-into-vram">How to put background/window tile data in VRAM</a></p>
<p>:::</p>
<pre><code class="language-rgbasm  lineno">
CHARMAP &quot; &quot;, 0
CHARMAP &quot;.&quot;, 24
CHARMAP &quot;-&quot;, 25
CHARMAP &quot;a&quot;, 26
CHARMAP &quot;b&quot;, 27
CHARMAP &quot;c&quot;, 28
CHARMAP &quot;d&quot;, 29
CHARMAP &quot;e&quot;, 30
CHARMAP &quot;f&quot;, 31
CHARMAP &quot;g&quot;, 32
CHARMAP &quot;h&quot;, 33
CHARMAP &quot;i&quot;, 34
CHARMAP &quot;j&quot;, 35
CHARMAP &quot;k&quot;, 36
CHARMAP &quot;l&quot;, 37
CHARMAP &quot;m&quot;, 38
CHARMAP &quot;n&quot;, 39
CHARMAP &quot;o&quot;, 40
CHARMAP &quot;p&quot;, 41
CHARMAP &quot;q&quot;, 42
CHARMAP &quot;r&quot;, 43
CHARMAP &quot;s&quot;, 44
CHARMAP &quot;t&quot;, 45
CHARMAP &quot;u&quot;, 46
CHARMAP &quot;v&quot;, 47
CHARMAP &quot;w&quot;, 48
CHARMAP &quot;x&quot;, 49
CHARMAP &quot;y&quot;, 50
CHARMAP &quot;z&quot;, 51

</code></pre>
<p>The above character mapping would convert (by the compiler) our <code>wScoreText</code> text to:</p>
<ul>
<li>s =&gt; 44</li>
<li>c =&gt; 28</li>
<li>o =&gt; 40</li>
<li>r =&gt; 43</li>
<li>e =&gt; 30</li>
<li>255</li>
</ul>
<p>With that setup, we would loop though the bytes of <code>wScoreText</code> and copy each byte to the background/window layer. After we copy each byte, we‚Äôll increment where we will copy to, and which byte in <code>wScoreText</code> we are reading. When we read 255, our code will end.</p>
<p>::: tip</p>
<p>This example implies that your font tiles are located in VRAM at the locations specified in the character mapping.</p>
<p>:::</p>
<p>** Drawing ‚Äòscore‚Äô on the window **</p>
<pre><code class="language-rgbasm  lineno">
DrawTextTiles::

    ld hl, wScoreText
    ld de, $9C00 ; The window tilemap starts at $9C00

DrawTextTilesLoop::

    ; Check for the end of string character 255
    ld a, [hl]
    cp 255
    ret z

    ; Write the current character (in hl) to the address
    ; on the tilemap (in de)
    ld a, [hl]
    ld [de], a

    inc hl
    inc de

    ; move to the next character and next background tile
    jp DrawTextTilesLoop
</code></pre>
<h3 id="draw-a-bottom-hud"><a class="header" href="#draw-a-bottom-hud">Draw a bottom HUD</a></h3>
<ul>
<li>Enable the window (with a different tilemap than the background)</li>
<li>Move the window downwards, so only 1 or 2 rows show at the bottom of the screen</li>
<li>Draw your text, score, and icons on the top of the window layer.</li>
</ul>
<p>::: tip</p>
<p>Sprites will still show over the window. To fully prevent that, you can use STAT interrupts to hide sprites where the bottom HUD will be shown.</p>
<p>:::</p>
<h2 id="sprites"><a class="header" href="#sprites">Sprites</a></h2>
<h3 id="put-sprite-tile-data-in-vram"><a class="header" href="#put-sprite-tile-data-in-vram">Put sprite tile data in VRAM</a></h3>
<p>The region in VRAM dedicated for sprites is from <code>$8000</code> to <code>$87F0</code>. Hardware.inc defines a <code>_VRAM</code> constant you can use for that. To copy sprite tile data into VRAM, you can use a loop to copy the bytes.</p>
<pre><code class="language-rgbasm linenos">mySprite: INCBIN &quot;src/path/to/my/sprite.2bpp&quot;
mySpriteEnd:

CopySpriteTileDataIntoVram:
    ; Copy the tile data
    ld de, Paddle
    ld hl, _VRAM
    ld bc, mySpriteEnd - mySprite
CopySpriteTileDataIntoVram_Loop:
    ld a, [de]
    ld [hli], a
    inc de
    dec bc
    ld a, b
    or a, c
    jp nz, CopySpriteTileDataIntoVram_Loop
</code></pre>
<h3 id="manipulate-hardware-oam-sprites"><a class="header" href="#manipulate-hardware-oam-sprites">Manipulate hardware OAM sprites</a></h3>
<p>Each hardware sprite has 4 bytes: (in this order)</p>
<ul>
<li>Y position</li>
<li>X Position</li>
<li>Tile ID</li>
<li>Flags/Props (priority, y flip, x flip, palette 0 [DMG], palette 1 [DMG], bank 0 [GBC], bank 1 [GBC])</li>
</ul>
<p>Check out the Pan Docs page on <a href="https://gbdev.io/pandocs/OAM.html">Object Attribute Memory (OAM)</a> for more info.</p>
<p>The bytes controlling hardware OAM sprites start at <code>$FE00</code>, for which hardware.inc has defined a constant as <code>_OAMRAM</code>.</p>
<p><strong>Moving (the first) OAM sprite, one pixel downwards:</strong></p>
<pre><code class="language-rgbasm  linenos">ld a, [_OAMRAM]
inc a
ld [_OAMRAM], a
</code></pre>
<p><strong>Moving (the first) OAM sprite, one pixel to the right:</strong></p>
<pre><code class="language-rgbasm  linenos">ld a, [_OAMRAM + 1]
inc a
ld [_OAMRAM + 1], a
</code></pre>
<p><strong>Setting the tile for the first OAM sprite:</strong></p>
<pre><code class="language-rgbasm  linenos">ld a, 3
ld [_OAMRAM+2], a
</code></pre>
<p><strong>Moving (the fifth) OAM sprite, one pixel downwards:</strong></p>
<pre><code class="language-rgbasm  linenos">ld a, [_OAMRAM + 20]
inc a
ld [_OAMRAM + 20], a
</code></pre>
<p>TODO - Explanation on limitations of direct OAM manipulation.</p>
<p>::: tip</p>
<p>It‚Äôs recommended that developers implement a shadow OAM, like @eievui5‚Äôs <a href="https://github.com/eievui5/gb-sprobj-lib">Sprite Object Library</a></p>
<p>:::</p>
<h3 id="implement-a-shadow-oam-using-eievui5s-sprite-object-library"><a class="header" href="#implement-a-shadow-oam-using-eievui5s-sprite-object-library">Implement a Shadow OAM using @eievui5‚Äôs Sprite Object Library</a></h3>
<p>GitHub URL: <a href="https://github.com/eievui5/gb-sprobj-lib">https://github.com/eievui5/gb-sprobj-lib</a></p>
<blockquote>
<p>This is a small, lightweight library meant to facilitate the rendering of sprite objects, including Shadow OAM and OAM DMA, single-entry ‚Äúsimple‚Äù sprite objects, and Q12.4 fixed-point position metasprite rendering.</p>
</blockquote>
<p><strong>Usage</strong></p>
<p>The library is relatively simple to get set up. First, put the following in your initialization code:</p>
<pre><code class="language-rgbasm  linenos">    ; Initilize Sprite Object Library.
    call InitSprObjLib

    ; Reset hardware OAM
    xor a, a
    ld b, 160
    ld hl, _OAMRAM
.resetOAM
    ld [hli], a
    dec b
    jr nz, .resetOAM
</code></pre>
<p>Then put a call to <code>ResetShadowOAM</code> at the beginning of your main loop.</p>
<p>Finally, run the following code during VBlank:</p>
<pre><code class="language-rgbasm  linenos">ld a, HIGH(wShadowOAM)
call hOAMDMA
</code></pre>
<h3 id="manipulate-shadow-oam-oam-sprites"><a class="header" href="#manipulate-shadow-oam-oam-sprites">Manipulate Shadow OAM OAM sprites</a></h3>
<p>Once you‚Äôve set up @eievui5‚Äôs Sprite Object Library, you can manipulate shadow OAM sprites the exact same way you would manipulate normal hardware OAM sprites. Except, this time you would use the library‚Äôs <code>wShadowOAM</code> constant instead of the <code>_OAMRAM</code> register.</p>
<p><strong>Moving (the first) OAM sprite, one pixel downwards:</strong></p>
<pre><code class="language-rgbasm  linenos">ld a,LOW(wShadowOAM)
ld l, a
ld a, HIGH(wShadowOAM)
ld h, a

ld a, [hl]
inc a
ld [wShadowOAM], a
</code></pre>
<h2 id="micelaneous"><a class="header" href="#micelaneous">Micelaneous</a></h2>
<h3 id="save-data"><a class="header" href="#save-data">Save Data</a></h3>
<p>If you want to save data in your game, your game‚Äôs header needs to specify the correct MBC/cartridge type, and it needs to have a non-zero SRAM size. This should be done in your makefile by passing special parameters to <a href="https://rgbds.gbdev.io/docs/rgbfix.1">rgbfix</a>.</p>
<ul>
<li>Use the <code>-m</code> or <code>--mbc-type</code> parameters to set the mbc/cartidge type, 0x147, to a given value from 0 to 0xFF. <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0147--cartridge-type">More Info</a></li>
<li>Use the <code>-r</code> or <code>--ram-size</code> parameters to set the RAM size, 0x149, to a given value from 0 to 0xFF. <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0149--ram-size">More Info</a>.</li>
</ul>
<p>To save data you need to store variables in Static RAM. This is done by creating a new SRAM ‚ÄúSECTION‚Äù. <a href="https://rgbds.gbdev.io/docs/rgbasm.5#SECTIONS">More Info</a></p>
<pre><code class="language-rgbasm  linenos">SECTION &quot;SaveVariables&quot;, SRAM

wCurrentLevel:: db

</code></pre>
<p>To access SRAM, you need to write <code>CART_SRAM_ENABLE</code> to the <code>rRAMG</code> register. When done, you can disable SRAM using the <code>CART_SRAM_DISABLE</code> constant.</p>
<p><strong>To enable read/write access to SRAM:</strong></p>
<pre><code class="language-rgbasm  linenos">
ld a, CART_SRAM_ENABLE
ld [rRAMG], a

</code></pre>
<p><strong>To disable read/write access to SRAM:</strong></p>
<pre><code class="language-rgbasm  linenos">
ld a, CART_SRAM_DISABLE
ld [rRAMG], a

</code></pre>
<p><strong>Initiating Save Data</strong></p>
<p>By default, save data for your game may or may not exist. When the save data does not exist, the value of the bytes dedicated for saving will be random.</p>
<p>You can dedicate a couple bytes towards creating a pseudo-checksum. When these bytes have a <strong>very specific</strong> value, you can be somewhat sure the save data has been initialized.</p>
<pre><code class="language-rgbasm  linenos">SECTION &quot;SaveVariables&quot;, SRAM

wCurrentLevel:: db
wCheckSum1:: db
wCheckSum2:: db
wCheckSum3:: db
</code></pre>
<p>When initializing your save data, you‚Äôll need to</p>
<ul>
<li>enable SRAM access</li>
<li>set your checksum bytes</li>
<li>give your other variables default values</li>
<li>disable SRAM access</li>
</ul>
<pre><code class="language-rgbasm  linenos">
;; Setup our save data
InitSaveData::

    ld a, CART_SRAM_ENABLE
    ld [rRAMG], a

    ld a, 123
    ld [wCheckSum1], a

    ld a, 111
    ld [wCheckSum2], a

    ld a, 222
    ld [wCheckSum3], a

    ld a, 0
    ld [wCurrentLevel], a

    ld a, CART_SRAM_DISABLE
    ld [rRAMG], a

    ret
</code></pre>
<p>Once your save file has been initialized, you can access any variable normally once SRAM is enabled.</p>
<pre><code class="language-rgbasm  linenos">
;; Setup our save data
StartNextLevel::

    ld a, CART_SRAM_ENABLE
    ld [rRAMG], a

    ld a, [wCurrentLevel]
    cp a, 3
    call z, StartLevel3

    ld a, CART_SRAM_DISABLE
    ld [rRAMG], a

    ret
</code></pre>
<h3 id="generate-random-numbers"><a class="header" href="#generate-random-numbers">Generate random numbers</a></h3>
<p>Random number generation is a <a href="https://en.wikipedia.org/wiki/Random_number_generation">complex task in software</a>. What you can implement is a ‚Äúpseudorandom‚Äù generator, giving you a very unpredictable sequence of values. Here‚Äôs a <code>rand</code> function (from <a href="https://github.com/pinobatch">Damian Yerrick</a>) you can use.</p>
<pre><code class="language-rgbasm  lineno">
SECTION &quot;MathVariables&quot;, WRAM0
randstate:: ds 4

SECTION &quot;Math&quot;, ROM0

;; From: https://github.com/pinobatch/libbet/blob/master/src/rand.z80#L34-L54
; Generates a pseudorandom 16-bit integer in BC
; using the LCG formula from cc65 rand():
; x[i + 1] = x[i] * 0x01010101 + 0xB3B3B3B3
; @return A=B=state bits 31-24 (which have the best entropy),
; C=state bits 23-16, HL trashed
rand::
  ; Add 0xB3 then multiply by 0x01010101
  ld hl, randstate+0
  ld a, [hl]
  add a, $B3
  ld [hl+], a
  adc a, [hl]
  ld [hl+], a
  adc a, [hl]
  ld [hl+], a
  ld c, a
  adc a, [hl]
  ld [hl], a
  ld b, a
  ret
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h2 id="help-channels"><a class="header" href="#help-channels">Help channels</a></h2>
<ul>
<li><a href="https://gbdev.io">GBDev community home page</a> and <a href="https://gbdev.io/chat">chat channels</a>.</li>
</ul>
<h2 id="other-tutorials"><a class="header" href="#other-tutorials">Other tutorials</a></h2>
<ul>
<li><a href="https://evie.gbdev.io/resources/interrupts">evie‚Äôs interrupts tutorial</a> should help you understand how to use interrupts, and what they are useful for.</li>
<li><a href="https://github.com/tbsp/simple-gb-asm-examples">tbsp‚Äôs ‚ÄúSimple GB ASM examples‚Äù</a> is a collection of ROMs, each built from a single, fairly short source file.
If you found this tutorial too abstract and/or want to get your feet wet, this is a good place to go to!</li>
<li><a href="https://github.com/daid/gameboy-assembly-by-example">GB assembly by example</a>, Daid‚Äôs collection of code snippets.
Consider this a continuation of the tutorial, but without explanations; it‚Äôs still useful to peruse them and ask about it, they are overall good quality.</li>
</ul>
<h2 id="complements"><a class="header" href="#complements">Complements</a></h2>
<p>Did you enjoy the tutorial or one of the above?
The following should prove useful along the rest of your journey!</p>
<ul>
<li><a href="https://rgbds.gbdev.io/docs/">RGBDS‚Äô online documentation</a> is always useful!
Notably, you‚Äôll find <a href="https://rgbds.gbdev.io/docs/gbz80.7">an instruction reference</a> and <a href="https://rgbds.gbdev.io/docs/rgbasm.5">the reference on RGBASM‚Äôs syntax and features</a>.</li>
<li><a href="https://gbdev.io/pandocs">Pan Docs</a> are <em>the</em> reference for all Game Boy hardware.
It‚Äôs a good idea to consult it if you aare unsure how a register works, or if you‚Äôre wondering how to do something.</li>
<li><a href="https://gbdev.io/gb-opcodes/optables">gb-optables</a> is a more compact instruction table, it becomes more useful when you stop needing the instructions‚Äô descriptions.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="special-thanks"><a class="header" href="#special-thanks">Special Thanks</a></h1>
<p>Big thank you to <a href="https://www.pouet.net/user.php?who=21982">Twoflower/Triad</a> for making the Hello World graphic.</p>
<p>I can‚Äôt thank enough Chlo√© and many others for their continued support.</p>
<p>Thanks to the GBDev community for being so nice throughout the years.</p>
<p><strong>You are all great. Thank you so very much.</strong></p>
<hr />
<p>Thank you to the <a href="https://www.rust-lang.org">Rust language</a> team for making <a href="https://github.com/rust-lang/mdBook">mdBook</a>, which powers this book (this honestly slick design is the stock one!!)</p>
<p>Greets to AYCE, Phantasy, TPPDevs/RainbowDevs, Plutiedev, lft/kryo :)</p>
<p>Shoutouts to <a href="https://eievui.ml">Eievui</a>, <a href="https://github.com/Rangi42">Rangi</a>, <a href="https://github.com/MarkSixtyFour">MarkSixtyFour</a>, <a href="https://github.com/aaaaaa123456789">ax6</a>, <a href="https://github.com/basxto">Ba≈ùto</a>, <a href="https://github.com/bbbbbr">bbbbbr</a>, and <a href="https://github.com/bitnenfer">bitnenfer</a>!</p>
<p>The Italian translation is curated by <a href="https://github.com/Street-Philosopher">Antonio Guido Leoni</a>, <a href="https://github.com/avivace">Antonio Vivace</a>, <a href="https://github.com/MattiaFortunati">Mattia Fortunati</a>, Matilde Della Morte and <a href="https://github.com/mte90">Daniele Scasciafratte</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="js/linenos.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
